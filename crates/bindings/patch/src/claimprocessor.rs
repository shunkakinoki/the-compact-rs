/**

Generated by the following Solidity interface...
```solidity
interface ClaimProcessor {
    struct BasicClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct BatchClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct BatchClaimComponent {
        uint256 id;
        uint256 allocatedAmount;
        uint256 amount;
    }
    struct BatchClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct BatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct BatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ExogenousBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ExogenousMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousQualifiedBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ExogenousQualifiedBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ExogenousQualifiedMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousQualifiedMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousQualifiedSplitBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        SplitBatchClaimComponent[] claims;
    }
    struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        SplitBatchClaimComponent[] claims;
    }
    struct ExogenousQualifiedSplitMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct ExogenousQualifiedSplitMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct ExogenousSplitBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        SplitBatchClaimComponent[] claims;
    }
    struct ExogenousSplitBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        SplitBatchClaimComponent[] claims;
    }
    struct ExogenousSplitMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct ExogenousSplitMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct MultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct MultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedBatchClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct QualifiedBatchClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct QualifiedBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct QualifiedBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct QualifiedClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedSplitBatchClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        SplitBatchClaimComponent[] claims;
    }
    struct QualifiedSplitBatchClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        SplitBatchClaimComponent[] claims;
    }
    struct QualifiedSplitBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        SplitBatchClaimComponent[] claims;
    }
    struct QualifiedSplitBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        SplitBatchClaimComponent[] claims;
    }
    struct QualifiedSplitClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct QualifiedSplitClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct QualifiedSplitMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct QualifiedSplitMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitBatchClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        SplitBatchClaimComponent[] claims;
    }
    struct SplitBatchClaimComponent {
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] portions;
    }
    struct SplitBatchClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        SplitBatchClaimComponent[] claims;
    }
    struct SplitBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        SplitBatchClaimComponent[] claims;
    }
    struct SplitBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        SplitBatchClaimComponent[] claims;
    }
    struct SplitClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitComponent {
        address claimant;
        uint256 amount;
    }
    struct SplitMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }

    error OnlyDirectCalls();
    error TStoreAlreadyActivated();
    error TStoreNotSupported();
    error TloadTestContractDeploymentFailed();

    function __activateTstore() external;
    function claim(ExogenousSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedMultichainClaim memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousMultichainClaim memory claimPayload) external returns (bool);
    function claim(ExogenousSplitMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(SplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(BatchClaim memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedClaim memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedMultichainClaim memory claimPayload) external returns (bool);
    function claim(BasicClaim memory claimPayload) external returns (bool);
    function claim(SplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(BatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(SplitClaimWithWitness memory claimPayload) external returns (bool);
    function claim(BatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(ExogenousSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedSplitClaim memory claimPayload) external returns (bool);
    function claim(BatchClaimWithWitness memory claimPayload) external returns (bool);
    function claim(SplitMultichainClaim memory claimPayload) external returns (bool);
    function claim(SplitClaim memory claimPayload) external returns (bool);
    function claim(SplitBatchClaim memory claimPayload) external returns (bool);
    function claim(SplitBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedBatchClaim memory claimPayload) external returns (bool);
    function claim(MultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(MultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitBatchClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(SplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitBatchClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(MultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(BatchClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitBatchClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(BatchClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(MultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(BasicClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(BatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(BatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousSplitMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedBatchClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "__activateTstore",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BasicClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct MultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct MultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct MultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct MultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BasicClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "error",
    "name": "OnlyDirectCalls",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TStoreAlreadyActivated",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TStoreNotSupported",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TloadTestContractDeploymentFailed",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod ClaimProcessor {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6101a06040523461007157610012610094565b60405161329b9081610234823960805181611041015260a05181611011015260c05181612d8f015260e05181612d1a01526101005181612e5c01526101205181611a5701526101405181611a3601526101605181505061018051815050f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040513d5f823e3d90fd5b696002601e613d5c3d52f35f52600a60165ff06001600160a01b03811615610224575f80808084600a5a04fa3d1561021f573d6001600160401b0381116102055760405190601f8101601f19908116603f011682016001600160401b038111838210176102055760405281525f60203d92013e5b801561020a57600160c052600360e0526005610100525b60a05260805246610120526101b34660a090604051907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208301527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d604083015260608201523060808201522090565b61014052604051613e2a8082016001600160401b038111838210176102055782916134cf833903905ff0801561020057610160526e22d473030f116ddee9f6b43ac78ba33b151561018052565b610089565b610075565b600260c052600460e05260066101005261011f565b610108565b632aea588760e01b5f5260045ffdfe60806040526004361015610011575f80fd5b5f3560e01c806303417d721461162e57806306659b7f1461161957806306e8cc181461160457806308e600ee146115ef5780630a133cf2146115da5780630d57fec9146115c55780630f5eeadf146115b0578063107d4ee41461156957806312a1e6ea1461155457806312f9d21e1461153f57806313589bfe1461152a578063138cd8191461150457806314865907146114ef578063176f405a1461148e5780631b98b63f146114795780631bb81a81146114645780631d474b141461144f578063206620a1146113fc57806325d7776b146113d25780632737edb9146113bb5780632acd5dc3146113a65780632c4bbd171461138f5780632e4d55cc1461137a57806332e2a80314611365578063341056c5146113505780633f458a1914611339578063409b3a7e14611324578063414fd9141461130f578063418a23f5146112fa57806344b97d78146112c75780634ad5205e146112b05780634c102416146112995780634d585fbf146112825780634e55a5481461126b578063548439e114611254578063577cdc641461123d57806359202128146112265780635ac2ccf11461120f5780635d76a382146111fa5780635e6c91ff146111e557806362a420bb146111ae57806363f5b1ad1461117157806364870556146111335780636af2791b1461111e57806371f5012714611107578063721f6292146110cc5780637423eb3c14610ff857806376d531d414610fe3578063843719f014610f935780638678555914610f7e57806388d247c414610f6757806388da84d414610f5057806389ce066114610efb578063935ed2ba14610eb75780639730f4fd14610ea0578063996d3aac14610e755780639be5f53714610e5e578063a4c7bd9314610e24578063aa41c87e14610dd7578063b20abc4814610dc2578063b24849b714610d98578063b324438914610d62578063b4039fc214610d35578063b54baefd14610d00578063b602ae0214610cc2578063b7ace04714610c91578063b8a5bbad14610c53578063bc95bd7a14610bff578063c4d195e814610bb8578063ca6cc39f14610b6b578063d204f11e14610b1a578063d2a1805f14610af9578063d34ddc8214610ae2578063d350188c14610acd578063d3917f3c14610a7f578063d921f36a14610a38578063db04bc7214610a23578063e0565c49146109d5578063e05c6e7d14610988578063e6c5b65414610949578063e8672f9314610934578063ea14532e146108cd578063eaa6748314610896578063eb1960081461085c578063eb43182114610820578063ebcbd7b5146107c9578063eea77a7814610754578063eed634ad1461073f578063eed93572146106f4578063f23d923d14610686578063f2f0def114610641578063f44a3452146105e3578063f745381c146105ad578063f95d3d1614610573578063fa1c550014610511578063fb75fb69146104ab5763fcfe431a14610444575f80fd5b346104a757602061049d6017603461045b36611779565b61018061047c61047661047083850185611900565b90611bfe565b83612c2a565b9290919361048e610160820135611935565b92610497611a34565b95611dc6565b6040519015158152f35b5f80fd5b346104a757602061049d60336104c036611675565b6104e26104da6104d4610100840184611b04565b90611efd565b82602f612723565b906101006104f236158484612287565b9161050060013615176119ba565b92610509611a34565b94602161316f565b346104a757602061049d6033610526366116a9565b610537610470610100830183611900565b906105453615928383611ff3565b91610100610562600261055b60e0860135611935565b93176119ba565b9261056b611a34565b94602661316f565b346104a757602061049d603461058836611641565b610120610599604036151783612be9565b929193906105a5611a34565b94602461316f565b346104a757602061049d601760336105c436611711565b6105cd81612601565b906101006105d9611a34565b93361592806121e3565b346104a757602061049d60346105f836611675565b61061361060b61047060e0840184611900565b82602a612723565b9060e061062236158484612287565b9161063060013615176119ba565b92610639611a34565b94601f61316f565b346104a757602061049d6017603461065836611745565b61067161066b6104d460e0840184611b04565b8261291a565b9060e061067c611a34565b93361592806120e9565b346104a757602061049d603461069b36611641565b36156101006106cb6106c360408417859060e0910160c08101355f52013560205260405f2090565b84602f612723565b926106e360026106dc858785612287565b94176119ba565b926106ec611a34565b94602361316f565b346104a757602061049d603461070936611641565b61072361071d610470610140840184611900565b82612baa565b9091610140610736610120830135611935565b9161056b611a34565b346104a757602061049d603361070936611641565b346104a757602061049d603461076936611779565b36159061079761078f60808417839060e0910160c08101355f52013560205260405f2090565b826031612723565b916101406107a6828585612287565b926107ba60026106dc610120840135611935565b936107c3611a34565b95611b39565b346104a757602061049d60336107de366117ad565b61018061080561047660c0361517849060e0910160c08101355f52013560205260405f2090565b92909193610817610160820135611935565b926107c3611a34565b346104a757602061049d6033610835366116a9565b61012061085061084a6104d483850185611b04565b83612bca565b92919390610509611a34565b346104a757602061049d603461087136611711565b61010061087d8261265c565b91909261088d60023615176119ba565b926105a5611a34565b346104a757602061049d60336108ab36611745565b6108be61060b6104d460e0840184611b04565b9060e06104f236158484612287565b346104a757602061049d601760336108e436611711565b6108f861078f6104d4610140840184611b04565b9061090536158383612287565b90610140610917610120830135611935565b9161092560023615176119ba565b9361092e611a34565b956120e9565b346104a757602061049d603361058836611641565b346104a757602061049d603361095e366116a9565b61096781611fd3565b90361560c0610978600283176119ba565b92610981611a34565b9480611b39565b346104a757602061049d603461099d36611711565b6109a681612197565b906109b460e0820135611935565b6101006109c460023615176119ba565b926109cd611a34565b94602561316f565b346104a757602061049d60336109ea36611641565b6101003615610a18610a1260408317859060e0910160c08101355f52013560205260405f2090565b84612b86565b929093610981611a34565b346104a757602061049d60336105f836611675565b346104a757602061049d60176034610a4f366116dd565b610180610a646104766104d483850185611b04565b92909193610a76610160820135611935565b9261092e611a34565b346104a757602061049d6034610a9436611779565b610140610ac1610abb6080361517849060e0910160c08101355f52013560205260405f2090565b83612bf9565b929193906106ec611a34565b346104a757602061049d603361087136611711565b346104a757602061049d6017603361065836611745565b346104a757602061049d6034610b0e366116dd565b61014061059982612684565b346104a757602061049d60176033610b3136611815565b610b4a610b446104d460a0840184611b04565b826126e1565b90361560a0610b5b600183176119ba565b92610b64611a34565b94806120e9565b346104a757602061049d6034610b8036611641565b610b8981612197565b90610b9760e0820135611935565b610100610ba760023615176119ba565b92610bb0611a34565b94602261316f565b346104a757602061049d60176034610bcf366116a9565b610be9610be3610470610100840184611900565b82612b86565b90610100610bf5611a34565b9336159280611dc6565b346104a757602061049d60176034610c1636611745565b610c2661047060c0830183611900565b90610c343615928383611f59565b9160c0610c43600283176119ba565b92610c4c611a34565b9480611dc6565b346104a757602061049d60176033610c6a36611745565b610c7381612231565b90361560a0610c81826119ba565b92610c8a611a34565b94806121e3565b346104a757602061049d60176033610ca836611675565b610cb181611fd3565b90361560c0610c81600283176119ba565b346104a757602061049d6034610cd736611675565b610ce081612231565b3615610ceb816119ba565b91610cf4611a34565b9360a083179180611b39565b346104a757602061049d60176033610d1736611675565b610d2a61066b61047060e0840184611900565b9060e0610bf5611a34565b346104a757602061049d6033610d4a366116a9565b60e0610d55826125b4565b91909261088d36156119ba565b346104a757602061049d6033610d7736611641565b610140610d8c610abb61047083850185611900565b92919390610639611a34565b346104a757602061049d6033610dad36611711565b610120610d8c61084a61047083850185611900565b346104a757602061049d6034610dad36611711565b346104a757602061049d6033610dec36611711565b610e0061071d6104d4610140840184611b04565b9091610140610e13610120830135611935565b91610e1c611a34565b94602761316f565b346104a757602061049d6033610e39366116dd565b610e42816125d2565b9091610140610e55610120830135611935565b916109cd611a34565b346104a757602061049d60176033610c1636611745565b346104a757602061049d60176033610e8c366116a9565b610e958161285a565b9060e06105d9611a34565b346104a757602061049d60176033610bcf366116a9565b346104a757602061049d60176033610ece36611848565b610ede6104d460c0830183611b04565b90610eec3615928383611f59565b9160c0610b5b600283176119ba565b346104a757602061049d6034610f1036611779565b610f3461071d6080361517839060e0910160c08101355f52013560205260405f2090565b9091610140610f47610120830135611935565b91610bb0611a34565b346104a757602061049d601760346108e436611711565b346104a757602061049d60176034610ece36611848565b346104a757602061049d6033610cd736611675565b346104a757602061049d60176034610faa366116dd565b610fb38161262c565b9091610140610fc6610120830135611935565b91610fd460023615176119ba565b93610fdd611a34565b956121e3565b346104a757602061049d603461095e366116a9565b346104a7575f3660031901126104a7573233036110bd577f000000000000000000000000000000000000000000000000000000000000000080156110b2575b6110a3575f8080807f0000000000000000000000000000000000000000000000000000000000000000600a5a04fa3d1561109e576110743d6118aa565b5f60203d92013e5b1561108f575f805460ff19166001179055005b6370a4078f60e01b5f5260045ffd5b61107c565b630f45b98b60e41b5f5260045ffd5b5060ff5f5416611037565b63096650c560e21b5f5260045ffd5b346104a757602061049d601760346110e336611848565b6110f6610b4461047060a0840184611900565b90361560a0610c43600183176119ba565b346104a757602061049d60176034610c6a36611745565b346104a757602061049d603361076936611779565b346104a757602061049d6017603461114a366117e1565b610180611156826126b6565b92909193611168610160820135611935565b92610fdd611a34565b346104a757602061049d603361118636611711565b361560e061119960408317846028612723565b926106e36111a8848684612287565b936119ba565b346104a757602061049d601760346111c536611675565b6111d9610be36104d4610100840184611b04565b9061010061067c611a34565b346104a757602061049d6033610f1036611779565b346104a757602061049d6034610dec36611711565b346104a757602061049d6017603361045b36611779565b346104a757602061049d601760336110e336611848565b346104a757602061049d601760336111c536611675565b346104a757602061049d60176034610b3136611815565b346104a757602061049d60176034610d1736611675565b346104a757602061049d6017603361114a366117e1565b346104a757602061049d60176033610faa366116dd565b346104a757602061049d60176034610e8c366116a9565b346104a757602061049d60336112dc36611711565b6112e58161285a565b9060e06112f0611a34565b9336159280611b39565b346104a757602061049d60346107de366117ad565b346104a757602061049d6033610b0e366116dd565b346104a757602061049d603361099d36611711565b346104a757602061049d601760346105c436611711565b346104a757602061049d6034610e39366116dd565b346104a757602061049d6033610b8036611641565b346104a757602061049d60346112dc36611711565b346104a757602061049d60176033610a4f366116dd565b346104a757602061049d6034610526366116a9565b346104a757602061049d60176034610ca836611675565b346104a757602061049d60346113e736611711565b610140610850610abb6104d483850185611b04565b346104a757602061049d603461141136611675565b6114226104d4610100830183611b04565b906114303615928383611ff3565b91610100611446600261055b60e0860135611935565b92610e1c611a34565b346104a757602061049d6033610a9436611779565b346104a757602061049d603461118636611711565b346104a757602061049d60346109ea36611641565b346104a757602061049d601760336114a536611641565b6114b961078f610470610140840184611900565b906114c636158383612287565b906101406114d8610120830135611935565b916114e660023615176119ba565b93610497611a34565b346104a757602061049d6034610d7736611641565b346104a757602061049d6034611519366116dd565b610120610ac1604036151783612be9565b346104a757602061049d60346108ab36611745565b346104a757602061049d603361069b36611641565b346104a757602061049d60336113e736611711565b346104a757602061049d603361157e366116a9565b6115926104da610470610100840184611900565b906101006115a236158484612287565b9161063060023615176119ba565b346104a757602061049d603461157e366116a9565b346104a757602061049d6033611519366116dd565b346104a757602061049d60346104c036611675565b346104a757602061049d6034610835366116a9565b346104a757602061049d6034610d4a366116a9565b346104a757602061049d603361141136611675565b346104a757602061049d601760346114a5365b60206003198201126104a757600435906001600160401b0382116104a7576101809082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101209082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101409082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101a09082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101609082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101009082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101c09082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576102009082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101e09082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a75760c09082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a75760e09082900360031901126104a75760040190565b6001600160401b03811161189657601f01601f191660200190565b634e487b7160e01b5f52604160045260245ffd5b906118b48261187b565b6040519290601f01601f191683016001600160401b03811184821017611896576040528252565b602460106020939284936014526370a0823160601b5f525afa601f3d11166020510290565b903590601e19813603018212156104a757018035906001600160401b0382116104a7576020019160608202360383136104a757565b60a090604051907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208301527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d604083015260608201523060808201522090565b90604051917fcdca950b17b5efc016b74b912d8527dfba5e404a688cbc3dab16cb943287fec25f527f5a7fee8000a237929ef9be08f2933c4b4f320b00b38809f3c7aa104d5421049f6020527f5ca9a66b8bbf0d2316e90dfa3df465f0790b277b25393a3ef4d67e1f5086505760405260051b5191604052565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000004618611a7f5790565b5060a06040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208201527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d60408201524660608201523060808201522090565b903590601e19813603018212156104a757018035906001600160401b0382116104a757602001918160051b360383136104a757565b9391959094979692860195863595602088013597606081013598611b5d89876121c3565b898110611b9c575091611b99999a9391611b939593604060018060a01b03910135169760016001605c1b038a60a01c1690611c6e565b90612c51565b90565b8990633078b2f65f526020526040526044601cfd5b90611bbb826118aa565b91611bc8601f199161187b565b01366020840137565b9015611bda5790565b634e487b7160e01b5f52603260045260245ffd5b9190811015611bda576060020190565b8160061b82810460401483151715611c5a57611c1990611bb1565b915f5b818110611c30575050506020815191012090565b80611c3e6001928486611bee565b604060208360061b880192803582850152013591015201611c1c565b634e487b7160e01b5f52601160045260245ffd5b939196959694909483358401916020850135850190813560018060a01b036040880135169a6080606089013598013542811115611db657506744036fc77deaed23605c1b8a1754998a15611da65750604051928a6020526303f37b1a600c52886040526037602820600181549a60ff161b8a8116611d9557611d1e9a179055836040528781150201928215158885141517918215611d68575b5050611d52575b50505085823592602001916122b6565b5f52339060018060a01b0316837f770c32a2314b700d6239ee35ba23a9690f2fceb93a55d8c753e953059b3b18d460205fa4565b611d60926020018b896122b6565b5f8080611d0e565b9091508c60148301526368a30dd0825289603483015260548201526058601c429201205411155f80611d07565b63dbc205b160601b600c526044601cfd5b63cf90c3a85f526020526024601cfd5b63f80dbaea5f526020526024601cfd5b98979380959196611e0b939894890198893581019860208a81019a359b013597611e03611df38d8d611bd1565b3560a01c60016001605c1b031690565b9d8e9161316f565b90611e168686611bd1565b95611e3f6020611e33878a35809b60408101359485910135612406565b83151798868686612c51565b506bffffffffffffffffffffffff60019916985b818110611e715750505050505050611e6c919250612417565b600190565b611e7c818389611bee565b80359889918860408201359b8c926020013592611e9893612406565b8c8360a01c60016001605c1b03161415171798611eb791878787612c51565b50600101611e53565b9015611bda57803590605e19813603018212156104a7570190565b9190811015611bda5760051b81013590605e19813603018212156104a7570190565b8160061b82810460401483151715611c5a57611f1890611bb1565b915f5b818110611f2f575050506020815191012090565b80611f3d6001928486611edb565b604060208360061b880192803582850152013591015201611f1b565b60a092916040606092815194848601525f51602061326f5f395f51905f5285528560208601933385524684880152608087208752820101358101803560051b80916020018537602001852060808601527f5ca9a66b8bbf0d2316e90dfa3df465f0790b277b25393a3ef4d67e1f5086505785520190372090565b611b999060c08101355f5260e081013560205260405f2090361590611f59565b6040519260608401525f51602061326f5f395f51905f5283526020830191338352466040850152608084209082019060a082013583019060c0823560051b93013560051b5f905f5b85811061208557505050505091604060609260a09594602001852060808601527f5ca9a66b8bbf0d2316e90dfa3df465f0790b277b25393a3ef4d67e1f5086505785520190372090565b80890160208483018701013581528282146120a4575b5060200161203b565b602090810185905292508261209b565b903590601e19813603018212156104a757018035906001600160401b0382116104a757602001918160061b360383136104a757565b94919584919796612116948101358101988960200199359a61210e611df38d8d611ec0565b98899161316f565b8515956bffffffffffffffffffffffff5f9416935b8181106121425750505050505050611e6c90612417565b8061219087612154600194868c611edb565b80359b8c8a60016001605c1b0361216b8c8461242a565b9260a01c16141517179b87602061218560408501856120b4565b919094013593612454565b500161212b565b611b999036156121bd60408217839060e0910160c08101355f52013560205260405f2090565b91611ff3565b8160ff1c15901517156121d35750565b63a06356f55f526020526024601cfd5b9584906122129399949692968a01998a3597889660408d013583019a60016001605c1b038960a01c169161316f565b95612223602092611b9998946121c3565b013592803590602001612454565b60e09060c0604051916060604036158301927fcdca950b17b5efc016b74b912d8527dfba5e404a688cbc3dab16cb943287fec2865233602087015201604085013760a081013560a0840152013560c08201522090565b60a0916040519382019160c0830135019081359384930135855260208501526020016040840137604001902090565b604080516119015f9081526020979097529181526042601e20918152919390929091606483019083146001600160a01b0386166041851481612311575b505050505050503314171561230457565b638baa579f5f526004601cfd5b909192939495975060405192885f526123b6575b612377575b60209495965f60605282604052630b135d3f60e11b83526004830152602482019586946040865281604485015260648401375afa9051630b135d3f60e11b1416905f8080808080806122f3565b60408401355f1a60205260408481376020600160805f825afa5181183d151761232a575094505050506001915f6060526040525f8080808080806122f3565b60208581013560ff81901c601b01825286356040526001600160ff1b0316606052600160805f825afa5182183d151761232557505094505050506001915f6060526040525f8080808080806122f3565b92612411919261242a565b91101790565b61241d57565b633a03d3bb5f526004601cfd5b60ff1c6002811015612440576001149015151690565b634e487b7160e01b5f52602160045260245ffd5b91959094935f93928492909187155b888510156124ad576020600686901b850190810135888101988910909217979590356001600160a01b03811681036104a757600192886124a4928e8d612c51565b50019395612463565b95975095509650505050828210176124c6575050600190565b633078b2f65f526020526040526044601cfd5b906040519160c08101350191823580937f4d756c7469636861696e436f6d7061637428616464726573732073706f6e736f83527f722c75696e74323536206e6f6e63652c75696e7432353620657870697265732c60208401527f5365676d656e745b5d207365676d656e7473295365676d656e7428616464726560408401527535365b325d5b5d20696473416e64416d6f756e74732c60768401527f737320617262697465722c75696e7432353620636861696e49642c75696e74326060840152602001609683013782604301605382012092609601902090565b90611b996125c86040361517846028612723565b9283361591612287565b6125fd906125f76080361517829060e0910160c08101355f52013560205260405f2090565b90612baa565b9091565b6125fd906126266040361517829060e0910160c08101355f52013560205260405f2090565b90612b86565b90611b996125c86126546080361517859060e0910160c08101355f52013560205260405f2090565b846031612723565b90611b996125c86106c36040361517859060e0910160c08101355f52013560205260405f2090565b6126af906126a96080361517829060e0910160c08101355f52013560205260405f2090565b90612bf9565b9192909190565b6126af906126db60c0361517829060e0910160c08101355f52013560205260405f2090565b90612c2a565b60c091606060408051937f5a7fee8000a237929ef9be08f2933c4b4f320b00b38809f3c7aa104d5421049f855233602086015201604084013760a08201522090565b9190918060311461284a578060301461283d5780602f1461282d5780602a146127e95780602e146127dc57806028146127885760321461277157634e487b7160e01b5f52605160045260245ffd5b60e0910160c08101355f52013560205260405f2090565b5060c060e092606060408051948301927fcdca950b17b5efc016b74b912d8527dfba5e404a688cbc3dab16cb943287fec2865233602087015201604085013760a081013560a0840152013560c08201522090565b50611b9991361590611f59565b509060c091606060408051937f5a7fee8000a237929ef9be08f2933c4b4f320b00b38809f3c7aa104d5421049f855233602086015201604084013760a08201522090565b50611b9991604036151790611f59565b50611b9991361590611ff3565b50611b9991604036151790611ff3565b9061010060405160a060c085013585019460608635967f436f6d70616374286164647265737320617262697465722c6164647265737320855260208501977f73706f6e736f722c75696e74323536206e6f6e63652c75696e7432353620657889528060408701927f70697265732c75696e743235362069642c75696e7432353620616d6f756e742c845260200184880137820185209788865233905260408301903760e0810135828401528381013560c0840152013560e0820152209190565b60e09092919260a06040519160c081013581019560608735977f4261746368436f6d70616374286164647265737320617262697465722c616464865260208601987f726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e74328a52656f756e74732c60468801528060408801927f353620657870697265732c75696e743235365b325d5b5d20696473416e64416d8452602001606689013760660186209889875233905260408401903782840152013560c0820152209190565b92919280602b14612ac557602914612a0357634e487b7160e01b5f52605160045260245ffd5b6101009060a0604051918360c082013582019660608835987f436f6d70616374286164647265737320617262697465722c6164647265737320875260208701997f73706f6e736f722c75696e74323536206e6f6e63652c75696e743235362065788b528060408901927f70697265732c75696e743235362069642c75696e7432353620616d6f756e742c8452602001848a013782018720998a8852339052604085019037820160e081013584860152013560c0840152013560e0820152209190565b5060e09060a06040519160c081013581019560608735977f4261746368436f6d70616374286164647265737320617262697465722c616464865260208601987f726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e74328a52656f756e74732c60468801528060408801927f353620657870697265732c75696e743235365b325d5b5d20696473416e64416d8452602001606689013760660186209889875233905260408401903782840152013560c0820152209190565b9190612ba690612b95846124d9565b94908591604036151790602c613011565b9190565b9190612ba690612bb9846124d9565b94908591604036151790602d613011565b91612bda612ba69284602b6129dd565b92909384604036151791612287565b91612bda612ba6928460296129dd565b91612ba6604093612c2093612c0d826124d9565b959091863615936080851786602c613011565b9586911791612287565b91612ba6604093612c2093612c3e826124d9565b959091863615936080851786602d613011565b9390929380603414612d1457603314612c7857634e487b7160e01b5f52605160045260245ffd5b67edcaa89a8229394060205282601452835f5260405f208054808311831517612d0757829003905581601452835f5260405f20805490828201918210612cfa5755335f5260205260018060a01b03169060018060a01b03167f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac72885960405fa4600190565b6389560ca15f526004601cfd5b63f4d678b85f526004601cfd5b509190827f000000000000000000000000000000000000000000000000000000000000000080600414612fe55780600314612fd35780600914612fc05780600a14612f8357600814612d7457634e487b7160e01b5f52605160045260245ffd5b612d8668929eee149b4bd21268612231565b805b612f7357507f000000000000000000000000000000000000000000000000000000000000000080600214612f4657600114612dd157634e487b7160e01b5f52605160045260245ffd5b3368929eee149b4bd212685d5b6001600160a01b0385169081612ee95750505f9081808538935af115612edc575b67edcaa89a8229394060205280601452825f5260405f2091825492838211612d0757815f9403905533835260205260018060a01b03167f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859604083a47f000000000000000000000000000000000000000000000000000000000000000080600614612eaf57600514612e9e57634e487b7160e01b5f52605160045260245ffd5b5f68929eee149b4bd212685d600190565b505f5460ff1615612ecb575f68929eee149b4bd212685d600190565b5f68929eee149b4bd2126855600190565b63b12d13eb5f526004601cfd5b9091929350612ef830836118db565b9260145260345263a9059cbb60601b5f5260205f6044601082855af13d1560015f5114171615612f3957612f31905f60345230906118db565b900390612dff565b6390b8ec185f526004601cfd5b505f5460ff1615612f62573368929eee149b4bd212685d612dde565b3368929eee149b4bd2126855612dde565b63f57c448b5f526020526024601cfd5b50612fba361560e06040821768929eee149b4bd212680160c08101355f52013560205260405f209068929eee149b4bd21268611ff3565b80612d88565b50612fba68929eee149b4bd21268611fd3565b5068929eee149b4bd212685c80612d88565b505f5460ff16156130015768929eee149b4bd212685c80612d88565b68929eee149b4bd2126854612fba565b9594939190929580602c146130f857602d1461303b57634e487b7160e01b5f52605160045260245ffd5b6040519360608501528584525f51602061326f5f395f51905f5260208501963388524660408701521415806130e9575b60051b60800184209083019060a082013584019060c0823560051b93013560051b5f905f5b8581106130ba57505050505060609260a09596926040926020018620608087015285520190372090565b80890160208483018701013581528282146130d9575b50602001613090565b60209081018590529250826130d0565b60a0840135608086015261306b565b5060609260a095969286604093845197878901528588525f51602061326f5f395f51905f52602089019633885246878b0152141580613161575b60051b60800188208852830101358201803560051b809160200186376020018620608087015285520190372090565b8285013560808a0152613132565b96959493929190968060271461325b5780602414613246578060211461323157806023146132215780601f1461320c57806026146131f957806022146131ee57806025146131db576017146131d257634e487b7160e01b5f52605160045260245ffd5b611b9996611c6e565b50906017959493929187611b99986121e3565b5086611b9997611b39565b50906017959493929187611b9998611dc6565b5091611b999691601796959493361593611dc6565b5090611b99969291361593611b39565b5091611b9996916017969594933615936120e9565b5091611b9996916017969594933615936121e3565b50906017959493929187611b99986120e956fe295feb095767cc67d7e74695da0adaddede54d7b7194a8a5426fe8f0351e0337a164736f6c634300081c000a60808060405234601557613e10908161001a8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c8062ad800c146137045780634e41a1fb146136965763d637ca8d14610039575f80fd5b3461367e57366003190160a0811261367e5760801361367e576040516080810181811067ffffffffffffffff82111761368257604052600435906001600160a01b0382169081830361367e57828152602435906001600160a01b038216820361367e576020810191825260443592600884101561367e576040820193845260643594600286101561367e5760608381019687521b6bffffffffffffffffffffffff191661366c575061011c6040516100f2604082613793565b600c81526b2730ba34bb32902a37b5b2b760a11b6020820152925b516001600160a01b03166138a1565b9251600881101561365857610130906139c8565b935160028110156136585761014490613bba565b8151610158906001600160a01b03166137b5565b825190919061016f906001600160a01b0316613834565b925163313ce56760049081525f81905260209182919082906001600160a01b0316620186a0fa3d601f10166020510260ff166101aa90613c59565b916040519560208701977103d913730b6b2911d101121b7b6b830b1ba160751b89528786518060208901603284015e810161088b60f21b603282015203603201601d19810189526002016101fe9089613793565b6040519460208601947f226465736372697074696f6e223a2022436f6d7061637420000000000000000086528451806020870160388a015e87016038810161040560f31b90528951908160208c01603a83015e01603801600281017f29207265736f75726365206c6f636b207769746820616c6c6f6361746f72200090528451908160208701602183015e0160020193601f85017401030b732103932b9b2ba103832b934b7b21037b31605d1b905287845160208601968188603483015e01601f0161088b60f21b601582015203601501601d19810189526002016102e39089613793565b6102ee608435613c59565b604051906102fd604083613793565b6002825261125160f21b602083015261031591613c9e565b9960405190610325604083613793565b600d82526c546f6b656e204164647265737360981b602083015261034891613c9e565b9560405190610358604083613793565b600a825269546f6b656e204e616d6560b01b602083015261037891613c9e565b9860405190610388604083613793565b600c82526b151bdad95b8814de5b589bdb60a21b60208301526103aa91613c9e565b92604051906103ba604083613793565b600e82526d546f6b656e20446563696d616c7360901b60208301526103de91613c9e565b90604051906103ee604083613793565b600982526820b63637b1b0ba37b960b91b602083015261040d91613c9e565b916040519061041d604083613793565b600582526453636f706560d81b602083015261043891613c9e565b9260405195610448604088613793565b600c875260208701906b14995cd95d0814195c9a5bd960a21b825260405190610472602083613793565b5f8252604051978893602085019a6f3d913a3930b4ba2fba3cb832911d101160811b8c52518091603087015e8401906c111610113b30b63ab2911d101160991b6030830152518092603d83015e0160300161227d60f01b600d82015281516020819301600f83015e01600d01600281015f905203600201601f19810186526104fa9086613793565b604051998a97602089019c8d6e2261747472696275746573223a205b60881b905280516020819201602f8c015e8901602f8101915f83528051926020849201905e01602f015f815281516020819301825e015f815281516020819301825e015f815281516020819301825e015f815281516020819301825e015f815281516020819301825e01905f8252518092825e01615d7d60f01b815203601d19810184526002016105a79084613793565b604051906105b76127c083613793565b61278e82527f22696d616765223a2022646174613a696d6167652f7376672b786d6c3b62617360208084019182527f6536342c5044393462577767646d567963326c76626a30694d5334774969426c6040808601919091527f626d4e765a476c755a7a306961584e764c5467344e546b744d53492f5067304b60608601527f504345744c5342485a57356c636d4630623349364945466b62324a6c49456c7360808601527f6248567a64484a68644739794944497a4c6a41754e53776755315a484945563460a08601527f63473979644342516248566e4c556c754943346755315a4849465a6c636e4e7060c08601527f62323436494459754d444167516e5670624751674d436b67494330745067304b60e08601527f50484e325a7942325a584a7a61573975505349784c6a4569494868746247357a6101008601527f50534a6f644852774f693876643364334c6e637a4c6d39795a7938794d4441776101208601527f4c334e325a79496765473173626e4d3665477870626d7339496d6830644841366101408601527f4c79393364336375647a4d7562334a6e4c7a45354f546b7665477870626d73696101608601527f49486739496a427765434967655430694d4842344967304b43534232615756336101808601527f516d393450534977494441674e446b79494451354d69496763335235624755396101a08601527f496d567559574a735a53316959574e725a334a766457356b4f6d356c647941776101c08601527f494441674e446b79494451354d6a7369494868746244707a6347466a5a5430696101e08601527f63484a6c63325679646d55695067304b5047636761575139496b31686333526c6102008601527f636c394d59586c6c636c3879496a344e436a77765a7a344e436a786e49476c6b6102208601527f50534a4d59586c6c636c3878496a344e43676b385a7a344e43676b4a5047632b6102408601527f44516f4a43516b385a7a344e43676b4a43516b385a7a344e43676b4a43516b4a6102608601527f50484268644767676333523562475539496d5a7062477774636e56735a54706c6102808601527f646d56756232526b4f324e7361584174636e56735a54706c646d56756232526b6102a08601527f4f325a7062477736497a49784d6a45794d54736949475139496b307a4d6a45756102c08601527f4d7a41344c4449354e4334344e6a526a4e53347a4e5449734e53347a4d6a67736102e08601527f4f5334304e5459734d5449754d5451304c4445314c6a63354d6977344c6a677a6103008601527f4d67304b43516b4a43516b4a597a49754e4451344c5445754d6a63794c4455756103208601527f4d4459304c544d754d446b324c4463754d7a49744e5334794e545a6a4d7934336103408601527f4e4451744d7934314e7a59734f4334794e5459744f5334314d6a67734e4334326103608601527f4e5459744d5451754d6a686a4c5445794c6a51314e6930784d5334354e7a59746103808601527f4d7a59754d7a67304c544d794c6a45784d69307a4e6934304e5459744d7a49756103a08601527f4d54594e43676b4a43516b4a435777334c6a55324c5467754e545934597a41756103c08601527f4d4449304c4441754d4449304c4455754d5459734e4334314d7a59734d5445756103e08601527f4f444d794c4445774c6a67794e474d344c6a59344f4377344c6a49774f4377796104008601527f4d4334344e5459734d5459754d6977794e6934334d7a59734d6a51754e4441346104208601527f44516f4a43516b4a43516c6a4d79347a4d5449734e4334324d4467734d6934326104408601527f4d5459734d5449754e7a51304c4441754f4459304c4445334c6a5579597930786104608601527f4c6a4d354d69777a4c6a67304c5451754d5441304c4463754e4459304c5463756104808601527f4d7a49734d5441754e544d325979307a4c6a41794e4377794c6a6b774e4330326104a08601527f4c6a59734e5334304c546b754f5459734e7934784d6a674e43676b4a43516b4a6104c08601527f43574d744d79347a4f4451734d5334334e5449744e6934334f5449734d6934336104e08601527f4e6930354c6a59354e6977794c6a63344e474d744d4334774f5459734d4334306105008601527f4e5459744d4334794d5459734d4334354d7a59744d43347a4d7a59734d53347a6105208601527f4f544a6a4c5441754f5459734d7934794e43307a4c6a41794e4377324c6a41336105408601527f4d6930314c6a59784e6977344c6a514e43676b4a43516b4a43574d744d69347a6105608601527f4d6a67734d6934774f4467744e5334784d7a59734d7934344d5459744e7934356105808601527f4e4451734e5334774e6a526a4c544d754d4463794c4445754d7a51304c5459756105a08601527f4d6a67344c4449754d5445794c546b754d5459344c4449754d545a6a4c5441756105c08601527f4d446b324c4441754f544d324c5441754d6a67344c4445754f4451344c5441756105e08601527f4e5455794c4449754e7a594e43676b4a43516b4a43574d744d4334354e69777a6106008601527f4c6a49304c544d754d4449304c4459754d4463794c5455754e6a45324c4467756106208601527f4e474d744d69347a4d6a67734d6934774f4467744e5334784d7a59734d7934346106408601527f4d5459744e7934354e4451734e5334774e6a526a4c5451754d5449344c4445756106608601527f4f4449304c5467754e5451304c4449754e5459344c5445794c4445754f5459346106808601527f44516f4a43516b4a43516c6a4c5441754d5449734d5334794d6a51744d43347a6106a08601527f4e6977794c6a51744d4334324f5459734d7934314d4452324d4334774d6a526a6106c08601527f4c5445754d444d794c444d754d7a67304c544d734e6934794e4330314c6a55796106e08601527f4c4467754d7a5579597930794c6a55794c4449754d5445794c5455754e546b796107008601527f4c444d754e4467744f4334344e5459734d7934354d7a594e43676b4a43516b4a6107208601527f43574d744d7934354e6977774c6a55314d6930344c6a45324c5441754d6a51746107408601527f4d5445754f5441304c5449754e6a6734597930784c6a417a4d6930774c6a59336107608601527f4d6930794c6a45324c5445754e544d324c544d754e4467744d6934314f544a736107808601527f4c5441754e7a51304c5441754e546332624330784d5334784e6930344c6a59786107a08601527f4e6d77324c6a6b324c546b754d444930624445784c6a45324c4467754e6a45326107c08601527f44516f4a43516b4a43516c734d4334334e4451734d4334314e7a5a6a4d5334776107e08601527f4d7a49734d4334334f5449734d5334344f5459734d5334304f4467734d6934336108008601527f4f4451734d6934774e474d784c6a49354e6977774c6a67324e4377794c6a637a6108208601527f4e6977784c6a45794f4377304c6a41344c4441754f545a6a4d5334784d6a67746108408601527f4d4334784e6a67734d6934784f4451744d4334324e4467734d7934774e7a49746108608601527f4d53347a4f54494e43676b4a43516b4a43574d774c6a67324e4330774c6a63796108808601527f4c4445754e5459744d5334334d6a67734d5334354d6930794c6a6b774e4777776108a08601527f4c44426a4d4334304e5459744d5334314e6977774c6a4d344e43307a4c6a55776108c08601527f4e4330774c6a51314e6930314c6a6332597930354c6a55794f4330784d7934796108e08601527f4f5459744d6a6b754e4451344c5449354c6a51794e4330794f5334304f5459746109008601527f4d6a6b754e44637944516f4a43516b4a43516c734e7934794c5467754f4455326109208601527f597a41754d4451344c4441754d4449304c4467754d5445794c4459754e5463326109408601527f4c4445324c6a63314d6977784e5334774d6a526a4d69347a4d4451734d6934796109608601527f4e5459734e4334344e4467734e4334334e5449734e7934314d5449734e7934786109808601527f4d6a686a4d4334304f4377774c6a517a4d6977774c6a6b344e4377774c6a67326109a08601527f4e4377784c6a51324e4377784c6a49354e67304b43516b4a43516b4a624441736109c08601527f4d4777774c44426a4d4334774f5459734d4334774f5459734d4334794d5459736109e08601527f4d4334784f5449734d43347a4d5449734d4334794f44686a4d4334324d6a5173610a008601527f4d4334314e5449734d5334794e4467734d5334784d6a67734d5334344e7a4973610a208601527f4d5334334d44526a4d6934784d5449734d5334344f5459734e4334794c444d75610a408601527f4f4445324c4459754d7a67304c4455754e446b3244516f4a43516b4a43516c6a610a608601527f4d6934314f5449734d5334344e4467734d6934314e4451734d6934794d7a4973610a808601527f4e5334304f5459734d53347a4e44526a4d4334324d6a51744d4334784f544973610aa08601527f4d5334794f5459744d4334314d6a67734d6934774d5459744d4334344e474d78610ac08601527f4c6a63334e6930774c6a63324f43777a4c6a55774e4330784c6a67304f437730610ae08601527f4c6a67354e69307a4c6a41354e67304b43516b4a43516b4a597a45754d544934610b008601527f4c5445754d444d794c4445754f546b794c5449754d5445794c4449754d7a4130610b208601527f4c544d754d545934597a41754d6a51744d4334344e4377774c6a41334d693078610b408601527f4c6a67304f4330774c6a63304e4330794c6a6b334e6d4d744f5334314e7a5974610b608601527f4d544d754d7a49744d7a55754f5441304c544d324c6a51314e69307a4e533435610b808601527f4e7a59744d7a59754e544934624463754e5459744f4334314e6a674e43676b4a610ba08601527f43516b4a43574d774c6a41304f4377774c6a41304f4377784e4334324f446773610bc08601527f4d5449754f5445794c4449324c6a59784e6977794e5334304f44686a4d793479610be08601527f4e43777a4c6a45354d6977344c6a41324e4377334c6a55324c4445784c6a5530610c008601527f4e4377784d4334794e7a4a6a4d5334794e7a49734d4334354d5449734d693478610c208601527f4e6977794c6a41344f4377304c6a41344c4445754e44453244516f4a43516b4a610c408601527f43516c6a4d4334344d5459744d4334794f4467734d5334344e4467744d433432610c608601527f4f5459734d7930784c6a4a6a4d5334334e7a59744d4334334e6a67734d793431610c808601527f4d4451744d5334344e4467734e4334344f5459744d7934774f545a6a4d533478610ca08601527f4d6a67744d5334774d4467734d5334354f5449744d6934784d5449734d69347a610cc08601527f4d4451744d7934784e6a674e43676b4a43516b4a43574d774c6a49304c544175610ce08601527f4f4451734d4334774e7a49744d5334344e4467744d4334334e4451744d324d74610d008601527f4f5334314e7a59744d544d754d7a49744d7a55754f5441304c544d324c6a5131610d208601527f4e69307a4e5334354e7a59744d7a59754e544934624463754e5459744f433431610d408601527f4e6a674e43676b4a43516b4a43554d794f5449754d6a49734d6a59324c6a5934610d608601527f4f43777a4d446b754d4451304c4449344d5334304f5459734d7a49784c6a4d77610d808601527f4f4377794f5451754f445930656949765067304b43516b4a435477765a7a344e610da08601527f43676b4a43516b385a7a344e43676b4a43516b4a504842686447676763335235610dc08601527f62475539496d5a7062477774636e56735a54706c646d56756232526b4f324e73610de08601527f61584174636e56735a54706c646d56756232526b4f325a7062477736497a4978610e008601527f4d6a45794d54736949475139496b30304d6a6b754d4449734d6a55304c6a5179610e208601527f4e45777a4f544d754e6a6b794c4445794f5334334d6d77744d5334314d7a5974610e408601527f4e5334304e4468734c5455754e4451344c4445754e44673444516f4a43516b4a610e608601527f43516c734c5451314c6a49784e6977784d6934304d4468734c5455754e545934610e808601527f4c4445754e544d32624445754e5459734e5334314d6d77794c6a457a4e697733610ea08601527f4c6a557a4e6d4d744d6a45754e6a6b324c4445754f5459344c5451794c6a6730610ec08601527f4c5449754e6a59304c5459794c6a55324f4330324c6a6b3244516f4a43516b4a610ee08601527f43516c6a4c544d354c6a49324e4330344c6a55324f4330334d7934794f545974610f008601527f4d5455754f5467304c546b354c6a55334e6977794e5334344f545a734d437777610f208601527f597930334c6a45774e4377784d53347a4e5449744d5451754f4455324c444930610f408601527f4c6a67304c5445324c6a59314e69777a4e5334784e67304b43516b4a43516b4a610f608601527f597930794c6a51334d6977784e4334774e43777a4c6a41794e4377794d793477610f808601527f4e4377794e5334794e4467734d5467754f545a6a4d544d754e6a55324c544975610fa08601527f4e446b324c4449794c6a41344c546b754d7a59734d6a6b754f5449344c544531610fc08601527f4c6a63324f474d344c6a67344c5463754d6a51344c4445324c6a67334d693078610fe08601527f4d7934334e5449734d7a49754d7a63324c546b754d54513044516f4a43516b4a6110008601527f43516c6a4f4334784d7a59734d79347a4e6977344c6a67344c444d754e6a63796110208601527f4c4445314c6a49304c446b754d444930597a49784c6a45304e4377784e7934336110408601527f4d7a59734e7a45754e4377324d5334314d7a59734e7a49734e6a49754d4452736110608601527f4d437777624445774c6a51784e6977354c6a45324f4777794c6a6b774e4377796110808601527f4c6a55304e47777a4c6a517a4d6930784c6a63314d67304b43516b4a43516b4a6110a08601527f624449774c6a67344c5445774c6a59774f4777784c6a49334d6977304c6a51346110c08601527f4f4777314c6a51334d6930784c6a5532624451314c6a41354e6930784d6934336110e08601527f4e6a68734e5334304f5459744d5334314e6b77304d6a6b754d4449734d6a55306111008601527f4c6a51794e4577304d6a6b754d4449734d6a55304c6a51794e486f6754544d316111208601527f4d4334324d7a59734d6a59354c6a6b334e6d77744e7934314d5449744e6934326111408601527f44516f4a43516b4a43516c494d7a517a4c6a466a4c5441754d5451304c5441756111608601527f4d5449744e5445754e6a49304c5451314c5463794c6a45354d6930324d6934796111808601527f4d7a4a6a4c5463754e7a41304c5459754e4455324c5467754e5459344c5459756111a08601527f4f4445324c5445344c6a4d324c5445774c6a67334d6d77744d4334794e4330776111c08601527f4c6a41354e6d77744d4334314d6a67744d4334784f54494e43676b4a43516b4a6111e08601527f43574d744d6a45754d7a59744e6934304e5459744d7a45754e6a41344c4445756112008601527f4f5449744e4449754f5467304c4445784c6a49774f474d744e6934334e6a67736112208601527f4e5334314d6930784d7934354f5449734d5445754e4449304c5449304c6a63326112408601527f4f4377784d79347a4f544a6a4c5445774c6a41344c4445754f4451344c5445796112608601527f4c6a63324f4330784c6a417a4d6930784d5334354d6a67744e5334334f44514e6112808601527f43676b4a43516b4a43574d784c6a51344f4330344c6a51334d6977344c6a55306112a08601527f4e4330794d4334324e6a51734d5455754d4451344c544d784c6a41314e6e59746112c08601527f4d4334774d6a526a4d6a45754f5459744d7a55754d4459304c4455794c6a4d356112e08601527f4d6930794f4334304e4377344e7934304f4330794d4334334f44514e43676b4a6113008601527f43516b4a43574d794d5334784f5449734e4334324d4467734e444d754f5451306113208601527f4c446b754e5463324c4459344c6a45324c4459754f544d32624449334c6a49326113408601527f4e4377354e6934794e45777a4e5441754e6a4d324c4449324f5334354e7a5a4d6113608601527f4d7a55774c6a597a4e6977794e6a6b754f5463326569424e4d7a67794c6a4d326113808601527f4e4377794e6a45754e6a6b3254444d314d4334774e6977784e4463754e6a49316113a08601527f44516f4a43516b4a43516c734d7a51754d6930354c6a4d344e47777a4d6934796113c08601527f4d7a49734d54457a4c6a63344e45777a4f4449754d7a59304c4449324d5334326113e08601527f4f545a364969382b44516f4a43516b4a5043396e5067304b43516b4a4354786e6114008601527f5067304b43516b4a43516b38634746306143427a64486c735a5430695a6d6c736114208601527f624331796457786c4f6d56325a5735765a47513759327870634331796457786c6114408601527f4f6d56325a5735765a4751375a6d6c7362446f6a4d6a45794d5449784f7949676114608601527f5a443069545445314e5334774d544d734d5451314c6a4a734c5449754d6a67736114808601527f4f4334774d54594e43676b4a43516b4a43574d784d4334794d6a51734d4334796114a08601527f4d5459734d6a6b754e546b794c4441754d4451344c4451314c6a63794c544d756114c08601527f4e6d77794c6a51354e6977784d5334784d7a5a6a4c5445344c6a6b324c4451756114e08601527f4d6a6b324c5451784c6a67774f4377304c6a45774e4330314d5334304d4467736115008601527f4d7934334f544a734c5449314c6a51344f4377344f5334354e7a594e43676b4a6115208601527f43516b4a43574d354c6a59334d69777a4c6a41304f4377794e7934344f4467736115408601527f4d5441754f5459344c4449354c6a4d314d6977794e7934334d6d77744d5445756115608601527f4e4377774c6a6b344e474d744d4334344f4467744d5441754d5455794c54457a6115808601527f4c6a63794f4330784e5334314d4451744d6a45754d4463794c5445334c6a63326115a08601527f624330784c6a4d324f4377304c6a67794e4777744d5334314e6977314c6a51356115c08601527f4e67304b43516b4a43516b4a624330314c6a51334d6930784c6a5532624330306115e08601527f4e5334774f5459744d5449754e7a5934624330314c6a51354e6930784c6a55326116008601527f624445754e5459744e5334304e7a4a734d7a55754d7a49344c5445794e4334336116208601527f4d4452734d5334314d7a59744e5334304e4468734e5334304e4467734d5334306116408601527f4f4468734e4455754d6a45324c4445794c6a51774f4777314c6a55324f4377786116608601527f4c6a557a4e67304b43516b4a43516b4a544445314e5334774d544d734d5451316116808601527f4c6a4a4d4d5455314c6a41784d7977784e4455754d6b77784e5455754d44457a6116a08601527f4c4445304e5334796569424e4d5445774c6a45314e7977794e6a45754e6a6b326116c08601527f62444d794c6a4d774e4330784d5451754d4463796243307a4e4334794c546b756116e08601527f4d7a6730544463324c6a41794f5377794e5449754d444930544445784d4334786117008601527f4e5463734d6a59784c6a59354e6e6f694c7a344e43676b4a43516b384c32632b6117208601527f44516f4a43516b4a5047632b44516f4a43516b4a435478775958526f49484e306117408601527f6557786c50534a6d615778734c584a31624755365a585a6c626d396b5a44746a6117608601527f62476c774c584a31624755365a585a6c626d396b5a44746d615778734f694d796117808601527f4d5449784d6a45374969426b50534a4e4d6a51774c6a63324e43777a4d7a59756117a08601527f4e6a6379544449304d4334334e6a51734d7a4d324c6a59334d67304b43516b4a6117c08601527f43516b4a597930784c6a45774e4330774c6a67784e6930794c6a51304f4330786117e08601527f4c6a41344c544d754e7a51304c5441754f446734637930794c6a51354e6977776118008601527f4c6a67324e43307a4c6a4d784d6977784c6a6b304e4777744f4334344d7a49736118208601527f4d5445754f546332614441754d444930597930774c6a67784e6977784c6a45776118408601527f4e4330784c6a45774e4377794c6a51334d6930774c6a6b784d69777a4c6a63306118608601527f4e41304b43516b4a43516b4a597a41754d546b794c4445754d6a63794c4441756118808601527f4f4459304c4449754e4463794c4445754f5451304c444d754d6a6734624441756118a08601527f4d5459344c4441754d545130597a45754d4455324c4441754e7a49734d69347a6118c08601527f4e5449734d4334354e69777a4c6a55334e6977774c6a63324f474d784c6a49356118e08601527f4e6930774c6a45354d6977794c6a51354e6930774c6a67324e43777a4c6a4d786119008601527f4d6930784c6a6b304e41304b43516b4a43516b4a624467754f4455324c5445796119208601527f597a41754f4445324c5445754d5441304c4445754d4467744d6934304e4467736119408601527f4d4334344f4467744d7934334e4452444d6a51794c6a55784e69777a4d7a67756119608601527f4e6a67344c4449304d5334344e4451734d7a4d334c6a51344f4377794e4441756119808601527f4e7a59304c444d7a4e6934324e7a4a4d4d6a51774c6a63324e43777a4d7a59756119a08601527f4e6a637944516f4a43516b4a43516c4d4d6a51774c6a63324e43777a4d7a59756119c08601527f4e6a63796569424e4d5463324c6a51794d5377794e6a59754d6a686a4e4334796119e08601527f4d6a51734d7934784d6977324c6a67784e6977334c6a59344c4463754e544d32611a008601527f4c4445794c6a55774e474d774c6a4d784d6977794c6a41324e4377774c6a4934611a208601527f4f4377304c6a45334e6930774c6a41354e6977324c6a493044516f4a43516b4a611a408601527f43516c6a4d5334344f5459744d4334354e69777a4c6a6b7a4e6930784c6a5977611a608601527f4f4377324c6a41794e4330784c6a6b79597a55754d4445324c5441754e7a5130611a808601527f4c4445774c6a49354e6977774c6a4d344e4377784e4334324f4467734d793432611aa08601527f4d6a52324d4334774d6a526a4e4334304d5459734d7934794e4377334c6a4134611ac08601527f4c4463754f5459344c4463754f4449304c4445794c6a6b344e41304b43516b4a611ae08601527f43516b4a597a41754d7a45794c4445754f546b794c4441754d6a67344c445175611b008601527f4d444d794c5441754d4449304c4459754d445134597a41754e6930774c6a4530611b208601527f4e4377784c6a45334e6930774c6a49324e4377784c6a63334e6930774c6a4d32611b408601527f597a51754e544d324c5441754e6a63794c446b754d7a4d324c4441754d7a5973611b608601527f4d544d754d6a6b324c444d754d6a6734624441754d6a67344c4441754d6a514e611b808601527f43676b4a43516b4a43574d7a4c6a67784e6977794c6a6b794f4377324c6a4530611ba08601527f4e4377334c6a45794f4377324c6a67784e6977784d5334314d6d4d774c6a4978611bc08601527f4e6977784c6a4d324f4377774c6a49324e4377794c6a63324c4441754d545130611be08601527f4c4451754d545579597a41754d6a45324c5441754d4451344c4441754e444134611c008601527f4c5441754d4463794c4441754e6a49304c5441754d446b3244516f4a43516b4a611c208601527f43516c6a4e4334784d6a67744d4334324d6a51734f4334314e4451734d43347a611c408601527f4d7a59734d5449754d546b794c444d754d444930624441734d474d7a4c6a5933611c608601527f4d6977794c6a63784d6977314c6a67344c4459754e6a49304c4459754e544130611c808601527f4c4445774c6a63334e6d4d774c6a59794e4377304c6a45794f4330774c6a4d7a611ca08601527f4e6977344c6a55304e43307a4c6a41304f4377784d6934784f54494e43676b4a611cc08601527f43516b4a435777744f4334344e5459734d544a6a4c5449754e7a45794c444d75611ce08601527f4e6a63794c5459754e6a49304c4455754f4467744d5441754e7a63324c445975611d008601527f4e544130597930304c6a45794f4377774c6a59794e4330344c6a55794c544175611d208601527f4d7a4d324c5445794c6a45354d69307a4c6a41794e4859774c6a41794e41304b611d408601527f43516b4a43516b4a5979307a4c6a59304f4330794c6a59344f4330314c6a6734611d608601527f4c5459754e6a49304c5459754e5441304c5445774c6a686a4c5441754d446379611d808601527f4c5441754e4467744d4334784d6930774c6a6b324c5441754d5451304c544575611da08601527f4e44526a4c5445754d4441344c4441754d7a4d324c5449754d4451734d433432611dc08601527f4c544d754d4463794c4441754e7a513044516f4a43516b4a43516c6a4c545175611de08601527f4e5445794c4441754e6a63794c546b754d7a45794c5441754d7a59744d544d75611e008601527f4d6a6b324c544d754d7a4579624441734d474d744d7934354f4451744d693435611e208601527f4e5449744e6934304d4467744e7934794d6a51744e7934774f4330784d533433611e408601527f4d7a5a6a4c5441754d5451304c5441754f5445794c5441754d6a45324c544575611e608601527f4f4449304c5441754d546b794c5449754e7a594e43676b4a43516b4a43574d74611e808601527f4d5334314d5449734d4334324d6a51744d7934774e7a49734d5334774f433030611ea08601527f4c6a59344c4445754d7a4a6a4c5455754d4445324c4441754e7a51304c544577611ec08601527f4c6a49354e6930774c6a4d344e4330784e4334324f4467744d7934324d6a5273611ee08601527f4d437777597930304c6a4d354d69307a4c6a49304c5463754d4467744e793435611f008601527f4f5449744e7934344d6a51744d544d754d44413444516f4a43516b4a43516c6a611f208601527f4c5441754d7a67304c5449754e4463794c5441754d6a67344c5455754d444532611f408601527f4c4441754d7a45794c5463754e446734597930784c6a55344e4377774c6a6379611f608601527f4c544d754d6a59304c4445754d6930304c6a6b324f4377784c6a51324e474d74611f808601527f4e4334344d6a51734d4334334d6930354c6a6b784d6930774c6a4d344e433078611fa08601527f4e4334784d7a59744d7934304f41304b43516b4a43516b4a597930304c6a4979611fc08601527f4e43307a4c6a45794c5459754f4445324c5463754e6a67744e7934314d7a5974611fe08601527f4d5449754e544130637a41754d7a67304c546b754f5445794c444d754e4467746120008601527f4d5451754d544d32614441754d444930624445774c6a6b354d6930784e4334356120208601527f4d44526a4d7934784d6930304c6a49304f4377334c6a59344c5459754f4445326120408601527f4c4445794c6a51344c5463754e544d3244516f4a43516b4a43516c444d5459336120608601527f4c6a41344e5377794e6a49754d4455324c4445334d6934784e7a4d734d6a597a6120808601527f4c6a45324c4445334e6934304d6a45734d6a59324c6a4934544445334e6934306120a08601527f4d6a45734d6a59324c6a4934544445334e6934304d6a45734d6a59324c6a49346120c08601527f544445334e6934304d6a45734d6a59324c6a49346569424e4d5463794c6a59316120e08601527f4d7977794f4441754e44593044516f4a43516b4a43516c6a4c5441754d6a67346121008601527f4c5445754f5451304c5445754d7a49744d7934334e6a67744d6934354e7a59746121208601527f4e4334354f544a324c5441754d444930597930784c6a59344c5445754d6a49306121408601527f4c544d754e7a49744d5334324e5459744e5334324f4467744d53347a4e6a686a6121608601527f4c5445754f5459344c4441754d6a67344c544d754e7a6b794c4445754d7a49746121808601527f4e5334774d5459734d6934354e7a594e43676b4a43516b4a435777744d5441756121a08601527f4f546b794c4445304c6a6734614441754d444930597930784c6a49304f4377786121c08601527f4c6a59344c5445754e6a67734d7934334e4451744d53347a4f5449734e5334326121e08601527f4f44686a4d4334794f4467734d5334354e4451734d53347a4d69777a4c6a63326122008601527f4f4377794c6a6b334e6977304c6a6b354d67304b43516b4a43516b4a597a45756122208601527f4e6a67734d5334794e4467734d7934334e4451734d5334324f4377314c6a59346122408601527f4f4377784c6a4d354d6e4d7a4c6a63324f4330784c6a4d794c4451754f546b796122608601527f4c5449754f546332624441754d4449304c4442734d5441754f546b794c5445306122808601527f4c6a6734614330774c6a41794e41304b43516b4a43516b4a517a45334d6934306122a08601527f4f4455734d6a67304c6a51334d6977784e7a49754f5451784c4449344d6934306122c08601527f4d4467734d5463794c6a59314d7977794f4441754e445930544445334d6934326122e08601527f4e544d734d6a67774c6a51324e4577784e7a49754e6a557a4c4449344d4334306123008601527f4e6a5236494530794d4445754d446b794c444d774d5334304d54594e43676b4a6123208601527f43516b4a43574d744d43347a4d5449744d6934784d7a59744d5334304e4330306123408601527f4c6a45314d69307a4c6a49324e4330314c6a51354e6e59774c6a41794e474d746123608601527f4d5334344e4467744d53347a4e6a67744e4334784d4451744d5334344e4467746123808601527f4e6934794e4330784c6a557a4e6d4d744d6934784e6977774c6a4d7a4e6930306123a08601527f4c6a45314d6977784c6a51304c5455754e5449734d7934794e6a514e43676b4a6123c08601527f43516b4a435777744d5445754e6a45324c4445314c6a63304e474d744d53347a6123e08601527f4e4451734d5334344e4467744d5334344d6a51734e4334784d4451744d5334316124008601527f4d5449734e6934794e474d774c6a4d784d6977794c6a457a4e6977784c6a51306124208601527f4c4451754d5449344c444d754d6a59304c4455754e446b32624441734d41304b6124408601527f43516b4a43516b4a597a45754f4451344c4445754d7a59344c4451754d5441306124608601527f4c4445754f4451344c4459754d6a51734d5334314d7a5a6a4d6934784e6930776124808601527f4c6a4d784d6977304c6a45314d6930784c6a51304c4455754e5449744d7934796124a08601527f4e6a52734d437777624445784c6a59784e6930784e5334334e44514e43676b4a6124c08601527f43516b4a43554d794d4441754f5451344c444d774e5334344d7a49734d6a41786124e08601527f4c6a51794f43777a4d444d754e5463324c4449774d5334774f5449734d7a41786125008601527f4c6a51784e6b77794d4445754d446b794c444d774d5334304d545a4d4d6a41786125208601527f4c6a41354d69777a4d4445754e4445326569424e4d6a497a4c6a49304e43777a6125408601527f4d6a49754d54557944516f4a43516b4a43516c6a4c5441754d6a51744d5334326125608601527f4f4330784c6a45774e43307a4c6a49304c5449754e5449744e4334794e7a4a326125808601527f4d4334774d6a526a4c5445754e4451744d5334774e5459744d7934784f5449746125a08601527f4d5334304e4330304c6a67304f4330784c6a45334e6d4d744d5334324e5459736125c08601527f4d4334794e43307a4c6a49784e6977784c6a45774e4330304c6a49304f4377796125e08601527f4c6a55304e4777744d4334784f5449734d4334794e41304b43516b4a43516b4a6126008601527f624330354c6a67344f4377784d7934304d545a324d4334774d6a526a4c5445756126208601527f4d4455324c4445754e4445324c5445754e4445324c444d754d5459344c5445756126408601527f4d5455794c4451754f444930597a41754d6a59304c4445754e6a67734d5334786126608601527f4d6a67734d7934794e4377794c6a55304e4377304c6a49334d6d77774c44414e6126808601527f43676b4a43516b4a43574d784c6a51784e6977784c6a41314e69777a4c6a45326126a08601527f4f4377784c6a51784e6977304c6a67304f4377784c6a45314d6d4d784c6a59346126c08601527f4c5441754d6a59304c444d754d6a51744d5334784d6a67734e4334794e7a49746126e08601527f4d6934314e44524d4d6a49794c6a45304d53777a4d6a634e43676b4a43516b4a6127008601527f43554d794d6a4d754d5449304c444d794e5334314f4451734d6a497a4c6a55776127208601527f4f43777a4d6a4d754f444d794c4449794d7934794e4451734d7a49794c6a45316127408601527f4d6e6f694c7a344e43676b4a43516b384c32632b44516f4a43516b384c32632b6127608601527f44516f4a435477765a7a344e43676b384c32632b44516f384c32632b44516f386127808601526d130cd38c969e8d1390d9cf4f488b60921b6127a086015251975197988998929592918291908a015e87019060208201905f8252519283915e01602001905f8252518092825e01905f8252518092825e015f815203601f19810182526136469082613793565b604051613654819282613769565b0390f35b634e487b7160e01b5f52602160045260245ffd5b61367861011c916138a1565b9261010d565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b3461367e57602036600319011261367e5761365460206136f860256136c56004356001600160a01b0316613834565b60405164f09fa49d2d60d81b858201528151909485928291018484015e81015f838201520301601f198101835282613793565b60405191829182613769565b3461367e57602036600319011261367e5761365460206136f860286137336004356001600160a01b03166137b5565b60405193849167021b7b6b830b1ba160c51b828401528051918291018484015e81015f838201520301601f198101835282613793565b602060409281835280519182918282860152018484015e5f828201840152601f01601f1916010190565b90601f8019910116810190811067ffffffffffffffff82111761368257604052565b6001600160a01b03811615613810576137d9906306fdde0360045260045f52613d42565b908151156137e357565b90506040516137f3604082613793565b600d81526c3ab735b737bbb7103a37b5b2b760991b602082015290565b5060405161381f604082613793565b600581526422ba3432b960d91b602082015290565b8060601b1561387f57613852906395d89b4160045260045f52613d42565b9081511561385c57565b905060405161386c604082613793565b60038152623f3f3f60e81b602082015290565b5060405161388e604082613793565b600381526208aa8960eb1b602082015290565b9060405191608083016040526f30313233343536373839616263646566600f526002830190602882525f604a85015260601b60015f5b8080018601602284831a600f811651602384015360041c5191015301906014821461390557906001906138d7565b50506130786002825101915282528160228101907f8888888888888888888888888888888888888888888888888888888888888880602883201660015f5b601160f31b83821a02818001520190601482146139635790600190613943565b505060429180517f2020202020202020202020202020202020202020202020202020202020202020815f511660011c161890520180517f2020202020202020202020202020202020202020202020202020202020202020816020511660011c16189052565b600881101561365857806139ff57506040516139e5604082613793565b600a81526913db99481cd958dbdb9960b21b602082015290565b60018103613a355750604051613a16604082613793565b600f81526e4669667465656e207365636f6e647360881b602082015290565b60028103613a665750604051613a4c604082613793565b600a8152694f6e65206d696e75746560b01b602082015290565b60038103613a985750604051613a7d604082613793565b600b81526a54656e206d696e7574657360a81b602082015290565b60048103613adc5750604051613aaf604082613793565b601981527f4f6e6520686f757220616e642066697665206d696e7574657300000000000000602082015290565b60058103613b0a5750604051613af3604082613793565b60078152664f6e652064617960c81b602082015290565b60068103613b4e5750604051613b21604082613793565b601781527f536576656e206461797320616e64206f6e6520686f7572000000000000000000602082015290565b600703613b7e57604051613b63604082613793565b600b81526a546869727479206461797360a81b602082015290565b60405162461bcd60e51b8152602060048201526014602482015273155b9adb9bdddb881c995cd95d081c195c9a5bd960621b6044820152606490fd5b60028110156136585780613bf15750604051613bd7604082613793565b600a81526926bab63a34b1b430b4b760b11b602082015290565b600103613c2457604051613c06604082613793565b600e81526d436861696e2d737065636966696360901b602082015290565b60405162461bcd60e51b815260206004820152600d60248201526c556e6b6e6f776e2073636f706560981b6044820152606490fd5b90604051600a608082019360a083016040525f8552935b5f190193603082820601855304928315613c8c57600a90613c70565b809350608091030191601f1901918252565b6002613d3f91600d602094604051613cb7604082613793565b6001815260308780830193600b60fa1b8552604051998a976f3d913a3930b4ba2fba3cb832911d101160811b828a0152805191829101858a015e8701906c111610113b30b63ab2911d101160991b84830152805192839101603d83015e01019061227d60f01b84830152518092600f83015e01015f838201520301601f198101835282613793565b90565b60205f60609282825191620186a0fa15613d3f57506040518060200160403d1015613da7575b5f60203d806103e8106103e8821802188083853e840101535b80515f1a15613d9257600101613d81565b818103601f190182525f815260200160405290565b5f513d601f1901811115613dbc575b50613d68565b602081843e82513d829003601f1901811115613dd85750613db6565b90604092826020936103e8106103e88218021892839283875201903e82015f6020820152016040529056fea164736f6c634300081c000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01\xA0`@R4a\0qWa\0\x12a\0\x94V[`@Qa2\x9B\x90\x81a\x024\x829`\x80Q\x81a\x10A\x01R`\xA0Q\x81a\x10\x11\x01R`\xC0Q\x81a-\x8F\x01R`\xE0Q\x81a-\x1A\x01Ra\x01\0Q\x81a.\\\x01Ra\x01 Q\x81a\x1AW\x01Ra\x01@Q\x81a\x1A6\x01Ra\x01`Q\x81PPa\x01\x80Q\x81PP\xF3[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q=_\x82>=\x90\xFD[i`\x02`\x1Ea=\\=R\xF3_R`\n`\x16_\xF0`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x02$W_\x80\x80\x80\x84`\nZ\x04\xFA=\x15a\x02\x1FW=`\x01`\x01`@\x1B\x03\x81\x11a\x02\x05W`@Q\x90`\x1F\x81\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x02\x05W`@R\x81R_` =\x92\x01>[\x80\x15a\x02\nW`\x01`\xC0R`\x03`\xE0R`\x05a\x01\0R[`\xA0R`\x80RFa\x01 Ra\x01\xB3F`\xA0\x90`@Q\x90\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x82R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x83\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x83\x01R``\x82\x01R0`\x80\x82\x01R \x90V[a\x01@R`@Qa>*\x80\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x02\x05W\x82\x91a4\xCF\x839\x03\x90_\xF0\x80\x15a\x02\0Wa\x01`Rn\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3;\x15\x15a\x01\x80RV[a\0\x89V[a\0uV[`\x02`\xC0R`\x04`\xE0R`\x06a\x01\0Ra\x01\x1FV[a\x01\x08V[c*\xEAX\x87`\xE0\x1B_R`\x04_\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80c\x03A}r\x14a\x16.W\x80c\x06e\x9B\x7F\x14a\x16\x19W\x80c\x06\xE8\xCC\x18\x14a\x16\x04W\x80c\x08\xE6\0\xEE\x14a\x15\xEFW\x80c\n\x13<\xF2\x14a\x15\xDAW\x80c\rW\xFE\xC9\x14a\x15\xC5W\x80c\x0F^\xEA\xDF\x14a\x15\xB0W\x80c\x10}N\xE4\x14a\x15iW\x80c\x12\xA1\xE6\xEA\x14a\x15TW\x80c\x12\xF9\xD2\x1E\x14a\x15?W\x80c\x13X\x9B\xFE\x14a\x15*W\x80c\x13\x8C\xD8\x19\x14a\x15\x04W\x80c\x14\x86Y\x07\x14a\x14\xEFW\x80c\x17o@Z\x14a\x14\x8EW\x80c\x1B\x98\xB6?\x14a\x14yW\x80c\x1B\xB8\x1A\x81\x14a\x14dW\x80c\x1DGK\x14\x14a\x14OW\x80c f \xA1\x14a\x13\xFCW\x80c%\xD7wk\x14a\x13\xD2W\x80c'7\xED\xB9\x14a\x13\xBBW\x80c*\xCD]\xC3\x14a\x13\xA6W\x80c,K\xBD\x17\x14a\x13\x8FW\x80c.MU\xCC\x14a\x13zW\x80c2\xE2\xA8\x03\x14a\x13eW\x80c4\x10V\xC5\x14a\x13PW\x80c?E\x8A\x19\x14a\x139W\x80c@\x9B:~\x14a\x13$W\x80cAO\xD9\x14\x14a\x13\x0FW\x80cA\x8A#\xF5\x14a\x12\xFAW\x80cD\xB9}x\x14a\x12\xC7W\x80cJ\xD5 ^\x14a\x12\xB0W\x80cL\x10$\x16\x14a\x12\x99W\x80cMX_\xBF\x14a\x12\x82W\x80cNU\xA5H\x14a\x12kW\x80cT\x849\xE1\x14a\x12TW\x80cW|\xDCd\x14a\x12=W\x80cY !(\x14a\x12&W\x80cZ\xC2\xCC\xF1\x14a\x12\x0FW\x80c]v\xA3\x82\x14a\x11\xFAW\x80c^l\x91\xFF\x14a\x11\xE5W\x80cb\xA4 \xBB\x14a\x11\xAEW\x80cc\xF5\xB1\xAD\x14a\x11qW\x80cd\x87\x05V\x14a\x113W\x80cj\xF2y\x1B\x14a\x11\x1EW\x80cq\xF5\x01'\x14a\x11\x07W\x80cr\x1Fb\x92\x14a\x10\xCCW\x80ct#\xEB<\x14a\x0F\xF8W\x80cv\xD51\xD4\x14a\x0F\xE3W\x80c\x847\x19\xF0\x14a\x0F\x93W\x80c\x86xUY\x14a\x0F~W\x80c\x88\xD2G\xC4\x14a\x0FgW\x80c\x88\xDA\x84\xD4\x14a\x0FPW\x80c\x89\xCE\x06a\x14a\x0E\xFBW\x80c\x93^\xD2\xBA\x14a\x0E\xB7W\x80c\x970\xF4\xFD\x14a\x0E\xA0W\x80c\x99m:\xAC\x14a\x0EuW\x80c\x9B\xE5\xF57\x14a\x0E^W\x80c\xA4\xC7\xBD\x93\x14a\x0E$W\x80c\xAAA\xC8~\x14a\r\xD7W\x80c\xB2\n\xBCH\x14a\r\xC2W\x80c\xB2HI\xB7\x14a\r\x98W\x80c\xB3$C\x89\x14a\rbW\x80c\xB4\x03\x9F\xC2\x14a\r5W\x80c\xB5K\xAE\xFD\x14a\r\0W\x80c\xB6\x02\xAE\x02\x14a\x0C\xC2W\x80c\xB7\xAC\xE0G\x14a\x0C\x91W\x80c\xB8\xA5\xBB\xAD\x14a\x0CSW\x80c\xBC\x95\xBDz\x14a\x0B\xFFW\x80c\xC4\xD1\x95\xE8\x14a\x0B\xB8W\x80c\xCAl\xC3\x9F\x14a\x0BkW\x80c\xD2\x04\xF1\x1E\x14a\x0B\x1AW\x80c\xD2\xA1\x80_\x14a\n\xF9W\x80c\xD3M\xDC\x82\x14a\n\xE2W\x80c\xD3P\x18\x8C\x14a\n\xCDW\x80c\xD3\x91\x7F<\x14a\n\x7FW\x80c\xD9!\xF3j\x14a\n8W\x80c\xDB\x04\xBCr\x14a\n#W\x80c\xE0V\\I\x14a\t\xD5W\x80c\xE0\\n}\x14a\t\x88W\x80c\xE6\xC5\xB6T\x14a\tIW\x80c\xE8g/\x93\x14a\t4W\x80c\xEA\x14S.\x14a\x08\xCDW\x80c\xEA\xA6t\x83\x14a\x08\x96W\x80c\xEB\x19`\x08\x14a\x08\\W\x80c\xEBC\x18!\x14a\x08 W\x80c\xEB\xCB\xD7\xB5\x14a\x07\xC9W\x80c\xEE\xA7zx\x14a\x07TW\x80c\xEE\xD64\xAD\x14a\x07?W\x80c\xEE\xD95r\x14a\x06\xF4W\x80c\xF2=\x92=\x14a\x06\x86W\x80c\xF2\xF0\xDE\xF1\x14a\x06AW\x80c\xF4J4R\x14a\x05\xE3W\x80c\xF7E8\x1C\x14a\x05\xADW\x80c\xF9]=\x16\x14a\x05sW\x80c\xFA\x1CU\0\x14a\x05\x11W\x80c\xFBu\xFBi\x14a\x04\xABWc\xFC\xFEC\x1A\x14a\x04DW_\x80\xFD[4a\x04\xA7W` a\x04\x9D`\x17`4a\x04[6a\x17yV[a\x01\x80a\x04|a\x04va\x04p\x83\x85\x01\x85a\x19\0V[\x90a\x1B\xFEV[\x83a,*V[\x92\x90\x91\x93a\x04\x8Ea\x01`\x82\x015a\x195V[\x92a\x04\x97a\x1A4V[\x95a\x1D\xC6V[`@Q\x90\x15\x15\x81R\xF3[_\x80\xFD[4a\x04\xA7W` a\x04\x9D`3a\x04\xC06a\x16uV[a\x04\xE2a\x04\xDAa\x04\xD4a\x01\0\x84\x01\x84a\x1B\x04V[\x90a\x1E\xFDV[\x82`/a'#V[\x90a\x01\0a\x04\xF26\x15\x84\x84a\"\x87V[\x91a\x05\0`\x016\x15\x17a\x19\xBAV[\x92a\x05\ta\x1A4V[\x94`!a1oV[4a\x04\xA7W` a\x04\x9D`3a\x05&6a\x16\xA9V[a\x057a\x04pa\x01\0\x83\x01\x83a\x19\0V[\x90a\x05E6\x15\x92\x83\x83a\x1F\xF3V[\x91a\x01\0a\x05b`\x02a\x05[`\xE0\x86\x015a\x195V[\x93\x17a\x19\xBAV[\x92a\x05ka\x1A4V[\x94`&a1oV[4a\x04\xA7W` a\x04\x9D`4a\x05\x886a\x16AV[a\x01 a\x05\x99`@6\x15\x17\x83a+\xE9V[\x92\x91\x93\x90a\x05\xA5a\x1A4V[\x94`$a1oV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x05\xC46a\x17\x11V[a\x05\xCD\x81a&\x01V[\x90a\x01\0a\x05\xD9a\x1A4V[\x936\x15\x92\x80a!\xE3V[4a\x04\xA7W` a\x04\x9D`4a\x05\xF86a\x16uV[a\x06\x13a\x06\x0Ba\x04p`\xE0\x84\x01\x84a\x19\0V[\x82`*a'#V[\x90`\xE0a\x06\"6\x15\x84\x84a\"\x87V[\x91a\x060`\x016\x15\x17a\x19\xBAV[\x92a\x069a\x1A4V[\x94`\x1Fa1oV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x06X6a\x17EV[a\x06qa\x06ka\x04\xD4`\xE0\x84\x01\x84a\x1B\x04V[\x82a)\x1AV[\x90`\xE0a\x06|a\x1A4V[\x936\x15\x92\x80a \xE9V[4a\x04\xA7W` a\x04\x9D`4a\x06\x9B6a\x16AV[6\x15a\x01\0a\x06\xCBa\x06\xC3`@\x84\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84`/a'#V[\x92a\x06\xE3`\x02a\x06\xDC\x85\x87\x85a\"\x87V[\x94\x17a\x19\xBAV[\x92a\x06\xECa\x1A4V[\x94`#a1oV[4a\x04\xA7W` a\x04\x9D`4a\x07\t6a\x16AV[a\x07#a\x07\x1Da\x04pa\x01@\x84\x01\x84a\x19\0V[\x82a+\xAAV[\x90\x91a\x01@a\x076a\x01 \x83\x015a\x195V[\x91a\x05ka\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x07\t6a\x16AV[4a\x04\xA7W` a\x04\x9D`4a\x07i6a\x17yV[6\x15\x90a\x07\x97a\x07\x8F`\x80\x84\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x82`1a'#V[\x91a\x01@a\x07\xA6\x82\x85\x85a\"\x87V[\x92a\x07\xBA`\x02a\x06\xDCa\x01 \x84\x015a\x195V[\x93a\x07\xC3a\x1A4V[\x95a\x1B9V[4a\x04\xA7W` a\x04\x9D`3a\x07\xDE6a\x17\xADV[a\x01\x80a\x08\x05a\x04v`\xC06\x15\x17\x84\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x92\x90\x91\x93a\x08\x17a\x01`\x82\x015a\x195V[\x92a\x07\xC3a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x0856a\x16\xA9V[a\x01 a\x08Pa\x08Ja\x04\xD4\x83\x85\x01\x85a\x1B\x04V[\x83a+\xCAV[\x92\x91\x93\x90a\x05\ta\x1A4V[4a\x04\xA7W` a\x04\x9D`4a\x08q6a\x17\x11V[a\x01\0a\x08}\x82a&\\V[\x91\x90\x92a\x08\x8D`\x026\x15\x17a\x19\xBAV[\x92a\x05\xA5a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x08\xAB6a\x17EV[a\x08\xBEa\x06\x0Ba\x04\xD4`\xE0\x84\x01\x84a\x1B\x04V[\x90`\xE0a\x04\xF26\x15\x84\x84a\"\x87V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x08\xE46a\x17\x11V[a\x08\xF8a\x07\x8Fa\x04\xD4a\x01@\x84\x01\x84a\x1B\x04V[\x90a\t\x056\x15\x83\x83a\"\x87V[\x90a\x01@a\t\x17a\x01 \x83\x015a\x195V[\x91a\t%`\x026\x15\x17a\x19\xBAV[\x93a\t.a\x1A4V[\x95a \xE9V[4a\x04\xA7W` a\x04\x9D`3a\x05\x886a\x16AV[4a\x04\xA7W` a\x04\x9D`3a\t^6a\x16\xA9V[a\tg\x81a\x1F\xD3V[\x906\x15`\xC0a\tx`\x02\x83\x17a\x19\xBAV[\x92a\t\x81a\x1A4V[\x94\x80a\x1B9V[4a\x04\xA7W` a\x04\x9D`4a\t\x9D6a\x17\x11V[a\t\xA6\x81a!\x97V[\x90a\t\xB4`\xE0\x82\x015a\x195V[a\x01\0a\t\xC4`\x026\x15\x17a\x19\xBAV[\x92a\t\xCDa\x1A4V[\x94`%a1oV[4a\x04\xA7W` a\x04\x9D`3a\t\xEA6a\x16AV[a\x01\x006\x15a\n\x18a\n\x12`@\x83\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84a+\x86V[\x92\x90\x93a\t\x81a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x05\xF86a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`4a\nO6a\x16\xDDV[a\x01\x80a\nda\x04va\x04\xD4\x83\x85\x01\x85a\x1B\x04V[\x92\x90\x91\x93a\nva\x01`\x82\x015a\x195V[\x92a\t.a\x1A4V[4a\x04\xA7W` a\x04\x9D`4a\n\x946a\x17yV[a\x01@a\n\xC1a\n\xBB`\x806\x15\x17\x84\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x83a+\xF9V[\x92\x91\x93\x90a\x06\xECa\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x08q6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x06X6a\x17EV[4a\x04\xA7W` a\x04\x9D`4a\x0B\x0E6a\x16\xDDV[a\x01@a\x05\x99\x82a&\x84V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0B16a\x18\x15V[a\x0BJa\x0BDa\x04\xD4`\xA0\x84\x01\x84a\x1B\x04V[\x82a&\xE1V[\x906\x15`\xA0a\x0B[`\x01\x83\x17a\x19\xBAV[\x92a\x0Bda\x1A4V[\x94\x80a \xE9V[4a\x04\xA7W` a\x04\x9D`4a\x0B\x806a\x16AV[a\x0B\x89\x81a!\x97V[\x90a\x0B\x97`\xE0\x82\x015a\x195V[a\x01\0a\x0B\xA7`\x026\x15\x17a\x19\xBAV[\x92a\x0B\xB0a\x1A4V[\x94`\"a1oV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0B\xCF6a\x16\xA9V[a\x0B\xE9a\x0B\xE3a\x04pa\x01\0\x84\x01\x84a\x19\0V[\x82a+\x86V[\x90a\x01\0a\x0B\xF5a\x1A4V[\x936\x15\x92\x80a\x1D\xC6V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0C\x166a\x17EV[a\x0C&a\x04p`\xC0\x83\x01\x83a\x19\0V[\x90a\x0C46\x15\x92\x83\x83a\x1FYV[\x91`\xC0a\x0CC`\x02\x83\x17a\x19\xBAV[\x92a\x0CLa\x1A4V[\x94\x80a\x1D\xC6V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0Cj6a\x17EV[a\x0Cs\x81a\"1V[\x906\x15`\xA0a\x0C\x81\x82a\x19\xBAV[\x92a\x0C\x8Aa\x1A4V[\x94\x80a!\xE3V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0C\xA86a\x16uV[a\x0C\xB1\x81a\x1F\xD3V[\x906\x15`\xC0a\x0C\x81`\x02\x83\x17a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`4a\x0C\xD76a\x16uV[a\x0C\xE0\x81a\"1V[6\x15a\x0C\xEB\x81a\x19\xBAV[\x91a\x0C\xF4a\x1A4V[\x93`\xA0\x83\x17\x91\x80a\x1B9V[4a\x04\xA7W` a\x04\x9D`\x17`3a\r\x176a\x16uV[a\r*a\x06ka\x04p`\xE0\x84\x01\x84a\x19\0V[\x90`\xE0a\x0B\xF5a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\rJ6a\x16\xA9V[`\xE0a\rU\x82a%\xB4V[\x91\x90\x92a\x08\x8D6\x15a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`3a\rw6a\x16AV[a\x01@a\r\x8Ca\n\xBBa\x04p\x83\x85\x01\x85a\x19\0V[\x92\x91\x93\x90a\x069a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\r\xAD6a\x17\x11V[a\x01 a\r\x8Ca\x08Ja\x04p\x83\x85\x01\x85a\x19\0V[4a\x04\xA7W` a\x04\x9D`4a\r\xAD6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`3a\r\xEC6a\x17\x11V[a\x0E\0a\x07\x1Da\x04\xD4a\x01@\x84\x01\x84a\x1B\x04V[\x90\x91a\x01@a\x0E\x13a\x01 \x83\x015a\x195V[\x91a\x0E\x1Ca\x1A4V[\x94`'a1oV[4a\x04\xA7W` a\x04\x9D`3a\x0E96a\x16\xDDV[a\x0EB\x81a%\xD2V[\x90\x91a\x01@a\x0EUa\x01 \x83\x015a\x195V[\x91a\t\xCDa\x1A4V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0C\x166a\x17EV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0E\x8C6a\x16\xA9V[a\x0E\x95\x81a(ZV[\x90`\xE0a\x05\xD9a\x1A4V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0B\xCF6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0E\xCE6a\x18HV[a\x0E\xDEa\x04\xD4`\xC0\x83\x01\x83a\x1B\x04V[\x90a\x0E\xEC6\x15\x92\x83\x83a\x1FYV[\x91`\xC0a\x0B[`\x02\x83\x17a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`4a\x0F\x106a\x17yV[a\x0F4a\x07\x1D`\x806\x15\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90\x91a\x01@a\x0FGa\x01 \x83\x015a\x195V[\x91a\x0B\xB0a\x1A4V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x08\xE46a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0E\xCE6a\x18HV[4a\x04\xA7W` a\x04\x9D`3a\x0C\xD76a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0F\xAA6a\x16\xDDV[a\x0F\xB3\x81a&,V[\x90\x91a\x01@a\x0F\xC6a\x01 \x83\x015a\x195V[\x91a\x0F\xD4`\x026\x15\x17a\x19\xBAV[\x93a\x0F\xDDa\x1A4V[\x95a!\xE3V[4a\x04\xA7W` a\x04\x9D`4a\t^6a\x16\xA9V[4a\x04\xA7W_6`\x03\x19\x01\x12a\x04\xA7W23\x03a\x10\xBDW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x15a\x10\xB2W[a\x10\xA3W_\x80\x80\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\nZ\x04\xFA=\x15a\x10\x9EWa\x10t=a\x18\xAAV[_` =\x92\x01>[\x15a\x10\x8FW_\x80T`\xFF\x19\x16`\x01\x17\x90U\0[cp\xA4\x07\x8F`\xE0\x1B_R`\x04_\xFD[a\x10|V[c\x0FE\xB9\x8B`\xE4\x1B_R`\x04_\xFD[P`\xFF_T\x16a\x107V[c\tfP\xC5`\xE2\x1B_R`\x04_\xFD[4a\x04\xA7W` a\x04\x9D`\x17`4a\x10\xE36a\x18HV[a\x10\xF6a\x0BDa\x04p`\xA0\x84\x01\x84a\x19\0V[\x906\x15`\xA0a\x0CC`\x01\x83\x17a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0Cj6a\x17EV[4a\x04\xA7W` a\x04\x9D`3a\x07i6a\x17yV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x11J6a\x17\xE1V[a\x01\x80a\x11V\x82a&\xB6V[\x92\x90\x91\x93a\x11ha\x01`\x82\x015a\x195V[\x92a\x0F\xDDa\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x11\x866a\x17\x11V[6\x15`\xE0a\x11\x99`@\x83\x17\x84`(a'#V[\x92a\x06\xE3a\x11\xA8\x84\x86\x84a\"\x87V[\x93a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x11\xC56a\x16uV[a\x11\xD9a\x0B\xE3a\x04\xD4a\x01\0\x84\x01\x84a\x1B\x04V[\x90a\x01\0a\x06|a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x0F\x106a\x17yV[4a\x04\xA7W` a\x04\x9D`4a\r\xEC6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x04[6a\x17yV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x10\xE36a\x18HV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x11\xC56a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0B16a\x18\x15V[4a\x04\xA7W` a\x04\x9D`\x17`4a\r\x176a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x11J6a\x17\xE1V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0F\xAA6a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0E\x8C6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`3a\x12\xDC6a\x17\x11V[a\x12\xE5\x81a(ZV[\x90`\xE0a\x12\xF0a\x1A4V[\x936\x15\x92\x80a\x1B9V[4a\x04\xA7W` a\x04\x9D`4a\x07\xDE6a\x17\xADV[4a\x04\xA7W` a\x04\x9D`3a\x0B\x0E6a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`3a\t\x9D6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x05\xC46a\x17\x11V[4a\x04\xA7W` a\x04\x9D`4a\x0E96a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`3a\x0B\x806a\x16AV[4a\x04\xA7W` a\x04\x9D`4a\x12\xDC6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`3a\nO6a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`4a\x05&6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0C\xA86a\x16uV[4a\x04\xA7W` a\x04\x9D`4a\x13\xE76a\x17\x11V[a\x01@a\x08Pa\n\xBBa\x04\xD4\x83\x85\x01\x85a\x1B\x04V[4a\x04\xA7W` a\x04\x9D`4a\x14\x116a\x16uV[a\x14\"a\x04\xD4a\x01\0\x83\x01\x83a\x1B\x04V[\x90a\x1406\x15\x92\x83\x83a\x1F\xF3V[\x91a\x01\0a\x14F`\x02a\x05[`\xE0\x86\x015a\x195V[\x92a\x0E\x1Ca\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\n\x946a\x17yV[4a\x04\xA7W` a\x04\x9D`4a\x11\x866a\x17\x11V[4a\x04\xA7W` a\x04\x9D`4a\t\xEA6a\x16AV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x14\xA56a\x16AV[a\x14\xB9a\x07\x8Fa\x04pa\x01@\x84\x01\x84a\x19\0V[\x90a\x14\xC66\x15\x83\x83a\"\x87V[\x90a\x01@a\x14\xD8a\x01 \x83\x015a\x195V[\x91a\x14\xE6`\x026\x15\x17a\x19\xBAV[\x93a\x04\x97a\x1A4V[4a\x04\xA7W` a\x04\x9D`4a\rw6a\x16AV[4a\x04\xA7W` a\x04\x9D`4a\x15\x196a\x16\xDDV[a\x01 a\n\xC1`@6\x15\x17\x83a+\xE9V[4a\x04\xA7W` a\x04\x9D`4a\x08\xAB6a\x17EV[4a\x04\xA7W` a\x04\x9D`3a\x06\x9B6a\x16AV[4a\x04\xA7W` a\x04\x9D`3a\x13\xE76a\x17\x11V[4a\x04\xA7W` a\x04\x9D`3a\x15~6a\x16\xA9V[a\x15\x92a\x04\xDAa\x04pa\x01\0\x84\x01\x84a\x19\0V[\x90a\x01\0a\x15\xA26\x15\x84\x84a\"\x87V[\x91a\x060`\x026\x15\x17a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`4a\x15~6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`3a\x15\x196a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`4a\x04\xC06a\x16uV[4a\x04\xA7W` a\x04\x9D`4a\x0856a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`4a\rJ6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`3a\x14\x116a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x14\xA56[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\x80\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01 \x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01@\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\xA0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01`\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\xC0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x02\0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\xE0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W`\xC0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W`\xE0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[`\x01`\x01`@\x1B\x03\x81\x11a\x18\x96W`\x1F\x01`\x1F\x19\x16` \x01\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x18\xB4\x82a\x18{V[`@Q\x92\x90`\x1F\x01`\x1F\x19\x16\x83\x01`\x01`\x01`@\x1B\x03\x81\x11\x84\x82\x10\x17a\x18\x96W`@R\x82RV[`$`\x10` \x93\x92\x84\x93`\x14Rcp\xA0\x821``\x1B_RZ\xFA`\x1F=\x11\x16` Q\x02\x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W` \x01\x91``\x82\x026\x03\x83\x13a\x04\xA7WV[`\xA0\x90`@Q\x90\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x82R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x83\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x83\x01R``\x82\x01R0`\x80\x82\x01R \x90V[\x90`@Q\x91\x7F\xCD\xCA\x95\x0B\x17\xB5\xEF\xC0\x16\xB7K\x91-\x85'\xDF\xBA^@Jh\x8C\xBC=\xAB\x16\xCB\x942\x87\xFE\xC2_R\x7FZ\x7F\xEE\x80\0\xA27\x92\x9E\xF9\xBE\x08\xF2\x93<KO2\x0B\0\xB3\x88\t\xF3\xC7\xAA\x10MT!\x04\x9F` R\x7F\\\xA9\xA6k\x8B\xBF\r#\x16\xE9\r\xFA=\xF4e\xF0y\x0B'{%9:>\xF4\xD6~\x1FP\x86PW`@R`\x05\x1BQ\x91`@RV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\x18a\x1A\x7FW\x90V[P`\xA0`@Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x82\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x82\x01RF``\x82\x01R0`\x80\x82\x01R \x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W` \x01\x91\x81`\x05\x1B6\x03\x83\x13a\x04\xA7WV[\x93\x91\x95\x90\x94\x97\x96\x92\x86\x01\x95\x865\x95` \x88\x015\x97``\x81\x015\x98a\x1B]\x89\x87a!\xC3V[\x89\x81\x10a\x1B\x9CWP\x91a\x1B\x99\x99\x9A\x93\x91a\x1B\x93\x95\x93`@`\x01\x80`\xA0\x1B\x03\x91\x015\x16\x97`\x01`\x01`\\\x1B\x03\x8A`\xA0\x1C\x16\x90a\x1CnV[\x90a,QV[\x90V[\x89\x90c0x\xB2\xF6_R` R`@R`D`\x1C\xFD[\x90a\x1B\xBB\x82a\x18\xAAV[\x91a\x1B\xC8`\x1F\x19\x91a\x18{V[\x016` \x84\x017V[\x90\x15a\x1B\xDAW\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x91\x90\x81\x10\x15a\x1B\xDAW``\x02\x01\x90V[\x81`\x06\x1B\x82\x81\x04`@\x14\x83\x15\x17\x15a\x1CZWa\x1C\x19\x90a\x1B\xB1V[\x91_[\x81\x81\x10a\x1C0WPPP` \x81Q\x91\x01 \x90V[\x80a\x1C>`\x01\x92\x84\x86a\x1B\xEEV[`@` \x83`\x06\x1B\x88\x01\x92\x805\x82\x85\x01R\x015\x91\x01R\x01a\x1C\x1CV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x93\x91\x96\x95\x96\x94\x90\x94\x835\x84\x01\x91` \x85\x015\x85\x01\x90\x815`\x01\x80`\xA0\x1B\x03`@\x88\x015\x16\x9A`\x80``\x89\x015\x98\x015B\x81\x11\x15a\x1D\xB6WPgD\x03o\xC7}\xEA\xED#`\\\x1B\x8A\x17T\x99\x8A\x15a\x1D\xA6WP`@Q\x92\x8A` Rc\x03\xF3{\x1A`\x0CR\x88`@R`7`( `\x01\x81T\x9A`\xFF\x16\x1B\x8A\x81\x16a\x1D\x95Wa\x1D\x1E\x9A\x17\x90U\x83`@R\x87\x81\x15\x02\x01\x92\x82\x15\x15\x88\x85\x14\x15\x17\x91\x82\x15a\x1DhW[PPa\x1DRW[PPP\x85\x825\x92` \x01\x91a\"\xB6V[_R3\x90`\x01\x80`\xA0\x1B\x03\x16\x83\x7Fw\x0C2\xA21Kp\rb9\xEE5\xBA#\xA9i\x0F/\xCE\xB9:U\xD8\xC7S\xE9S\x05\x9B;\x18\xD4` _\xA4V[a\x1D`\x92` \x01\x8B\x89a\"\xB6V[_\x80\x80a\x1D\x0EV[\x90\x91P\x8C`\x14\x83\x01Rch\xA3\r\xD0\x82R\x89`4\x83\x01R`T\x82\x01R`X`\x1CB\x92\x01 T\x11\x15_\x80a\x1D\x07V[c\xDB\xC2\x05\xB1``\x1B`\x0CR`D`\x1C\xFD[c\xCF\x90\xC3\xA8_R` R`$`\x1C\xFD[c\xF8\r\xBA\xEA_R` R`$`\x1C\xFD[\x98\x97\x93\x80\x95\x91\x96a\x1E\x0B\x93\x98\x94\x89\x01\x98\x895\x81\x01\x98` \x8A\x81\x01\x9A5\x9B\x015\x97a\x1E\x03a\x1D\xF3\x8D\x8Da\x1B\xD1V[5`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x90V[\x9D\x8E\x91a1oV[\x90a\x1E\x16\x86\x86a\x1B\xD1V[\x95a\x1E?` a\x1E3\x87\x8A5\x80\x9B`@\x81\x015\x94\x85\x91\x015a$\x06V[\x83\x15\x17\x98\x86\x86\x86a,QV[Pk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01\x99\x16\x98[\x81\x81\x10a\x1EqWPPPPPPPa\x1El\x91\x92Pa$\x17V[`\x01\x90V[a\x1E|\x81\x83\x89a\x1B\xEEV[\x805\x98\x89\x91\x88`@\x82\x015\x9B\x8C\x92` \x015\x92a\x1E\x98\x93a$\x06V[\x8C\x83`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x14\x15\x17\x17\x98a\x1E\xB7\x91\x87\x87\x87a,QV[P`\x01\x01a\x1ESV[\x90\x15a\x1B\xDAW\x805\x90`^\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x90V[\x91\x90\x81\x10\x15a\x1B\xDAW`\x05\x1B\x81\x015\x90`^\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x90V[\x81`\x06\x1B\x82\x81\x04`@\x14\x83\x15\x17\x15a\x1CZWa\x1F\x18\x90a\x1B\xB1V[\x91_[\x81\x81\x10a\x1F/WPPP` \x81Q\x91\x01 \x90V[\x80a\x1F=`\x01\x92\x84\x86a\x1E\xDBV[`@` \x83`\x06\x1B\x88\x01\x92\x805\x82\x85\x01R\x015\x91\x01R\x01a\x1F\x1BV[`\xA0\x92\x91`@``\x92\x81Q\x94\x84\x86\x01R_Q` a2o_9_Q\x90_R\x85R\x85` \x86\x01\x933\x85RF\x84\x88\x01R`\x80\x87 \x87R\x82\x01\x015\x81\x01\x805`\x05\x1B\x80\x91` \x01\x857` \x01\x85 `\x80\x86\x01R\x7F\\\xA9\xA6k\x8B\xBF\r#\x16\xE9\r\xFA=\xF4e\xF0y\x0B'{%9:>\xF4\xD6~\x1FP\x86PW\x85R\x01\x907 \x90V[a\x1B\x99\x90`\xC0\x81\x015_R`\xE0\x81\x015` R`@_ \x906\x15\x90a\x1FYV[`@Q\x92``\x84\x01R_Q` a2o_9_Q\x90_R\x83R` \x83\x01\x913\x83RF`@\x85\x01R`\x80\x84 \x90\x82\x01\x90`\xA0\x82\x015\x83\x01\x90`\xC0\x825`\x05\x1B\x93\x015`\x05\x1B_\x90_[\x85\x81\x10a \x85WPPPPP\x91`@``\x92`\xA0\x95\x94` \x01\x85 `\x80\x86\x01R\x7F\\\xA9\xA6k\x8B\xBF\r#\x16\xE9\r\xFA=\xF4e\xF0y\x0B'{%9:>\xF4\xD6~\x1FP\x86PW\x85R\x01\x907 \x90V[\x80\x89\x01` \x84\x83\x01\x87\x01\x015\x81R\x82\x82\x14a \xA4W[P` \x01a ;V[` \x90\x81\x01\x85\x90R\x92P\x82a \x9BV[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W` \x01\x91\x81`\x06\x1B6\x03\x83\x13a\x04\xA7WV[\x94\x91\x95\x84\x91\x97\x96a!\x16\x94\x81\x015\x81\x01\x98\x89` \x01\x995\x9Aa!\x0Ea\x1D\xF3\x8D\x8Da\x1E\xC0V[\x98\x89\x91a1oV[\x85\x15\x95k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_\x94\x16\x93[\x81\x81\x10a!BWPPPPPPPa\x1El\x90a$\x17V[\x80a!\x90\x87a!T`\x01\x94\x86\x8Ca\x1E\xDBV[\x805\x9B\x8C\x8A`\x01`\x01`\\\x1B\x03a!k\x8C\x84a$*V[\x92`\xA0\x1C\x16\x14\x15\x17\x17\x9B\x87` a!\x85`@\x85\x01\x85a \xB4V[\x91\x90\x94\x015\x93a$TV[P\x01a!+V[a\x1B\x99\x906\x15a!\xBD`@\x82\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x91a\x1F\xF3V[\x81`\xFF\x1C\x15\x90\x15\x17\x15a!\xD3WPV[c\xA0cV\xF5_R` R`$`\x1C\xFD[\x95\x84\x90a\"\x12\x93\x99\x94\x96\x92\x96\x8A\x01\x99\x8A5\x97\x88\x96`@\x8D\x015\x83\x01\x9A`\x01`\x01`\\\x1B\x03\x89`\xA0\x1C\x16\x91a1oV[\x95a\"#` \x92a\x1B\x99\x98\x94a!\xC3V[\x015\x92\x805\x90` \x01a$TV[`\xE0\x90`\xC0`@Q\x91```@6\x15\x83\x01\x92\x7F\xCD\xCA\x95\x0B\x17\xB5\xEF\xC0\x16\xB7K\x91-\x85'\xDF\xBA^@Jh\x8C\xBC=\xAB\x16\xCB\x942\x87\xFE\xC2\x86R3` \x87\x01R\x01`@\x85\x017`\xA0\x81\x015`\xA0\x84\x01R\x015`\xC0\x82\x01R \x90V[`\xA0\x91`@Q\x93\x82\x01\x91`\xC0\x83\x015\x01\x90\x815\x93\x84\x93\x015\x85R` \x85\x01R` \x01`@\x84\x017`@\x01\x90 \x90V[`@\x80Qa\x19\x01_\x90\x81R` \x97\x90\x97R\x91\x81R`B`\x1E \x91\x81R\x91\x93\x90\x92\x90\x91`d\x83\x01\x90\x83\x14`\x01`\x01`\xA0\x1B\x03\x86\x16`A\x85\x14\x81a#\x11W[PPPPPPP3\x14\x17\x15a#\x04WV[c\x8B\xAAW\x9F_R`\x04`\x1C\xFD[\x90\x91\x92\x93\x94\x95\x97P`@Q\x92\x88_Ra#\xB6W[a#wW[` \x94\x95\x96_``R\x82`@Rc\x0B\x13]?`\xE1\x1B\x83R`\x04\x83\x01R`$\x82\x01\x95\x86\x94`@\x86R\x81`D\x85\x01R`d\x84\x017Z\xFA\x90Qc\x0B\x13]?`\xE1\x1B\x14\x16\x90_\x80\x80\x80\x80\x80\x80a\"\xF3V[`@\x84\x015_\x1A` R`@\x84\x817` `\x01`\x80_\x82Z\xFAQ\x81\x18=\x15\x17a#*WP\x94PPPP`\x01\x91_``R`@R_\x80\x80\x80\x80\x80\x80a\"\xF3V[` \x85\x81\x015`\xFF\x81\x90\x1C`\x1B\x01\x82R\x865`@R`\x01`\x01`\xFF\x1B\x03\x16``R`\x01`\x80_\x82Z\xFAQ\x82\x18=\x15\x17a#%WPP\x94PPPP`\x01\x91_``R`@R_\x80\x80\x80\x80\x80\x80a\"\xF3V[\x92a$\x11\x91\x92a$*V[\x91\x10\x17\x90V[a$\x1DWV[c:\x03\xD3\xBB_R`\x04`\x1C\xFD[`\xFF\x1C`\x02\x81\x10\x15a$@W`\x01\x14\x90\x15\x15\x16\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x91\x95\x90\x94\x93_\x93\x92\x84\x92\x90\x91\x87\x15[\x88\x85\x10\x15a$\xADW` `\x06\x86\x90\x1B\x85\x01\x90\x81\x015\x88\x81\x01\x98\x89\x10\x90\x92\x17\x97\x95\x905`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x04\xA7W`\x01\x92\x88a$\xA4\x92\x8E\x8Da,QV[P\x01\x93\x95a$cV[\x95\x97P\x95P\x96PPPP\x82\x82\x10\x17a$\xC6WPP`\x01\x90V[c0x\xB2\xF6_R` R`@R`D`\x1C\xFD[\x90`@Q\x91`\xC0\x81\x015\x01\x91\x825\x80\x93\x7FMultichainCompact(address sponso\x83R\x7Fr,uint256 nonce,uint256 expires,` \x84\x01R\x7FSegment[] segments)Segment(addre`@\x84\x01Ru56[2][] idsAndAmounts,`v\x84\x01R\x7Fss arbiter,uint256 chainId,uint2``\x84\x01R` \x01`\x96\x83\x017\x82`C\x01`S\x82\x01 \x92`\x96\x01\x90 \x90V[\x90a\x1B\x99a%\xC8`@6\x15\x17\x84`(a'#V[\x92\x836\x15\x91a\"\x87V[a%\xFD\x90a%\xF7`\x806\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a+\xAAV[\x90\x91V[a%\xFD\x90a&&`@6\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a+\x86V[\x90a\x1B\x99a%\xC8a&T`\x806\x15\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84`1a'#V[\x90a\x1B\x99a%\xC8a\x06\xC3`@6\x15\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[a&\xAF\x90a&\xA9`\x806\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a+\xF9V[\x91\x92\x90\x91\x90V[a&\xAF\x90a&\xDB`\xC06\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a,*V[`\xC0\x91```@\x80Q\x93\x7FZ\x7F\xEE\x80\0\xA27\x92\x9E\xF9\xBE\x08\xF2\x93<KO2\x0B\0\xB3\x88\t\xF3\xC7\xAA\x10MT!\x04\x9F\x85R3` \x86\x01R\x01`@\x84\x017`\xA0\x82\x01R \x90V[\x91\x90\x91\x80`1\x14a(JW\x80`0\x14a(=W\x80`/\x14a(-W\x80`*\x14a'\xE9W\x80`.\x14a'\xDCW\x80`(\x14a'\x88W`2\x14a'qWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[P`\xC0`\xE0\x92```@\x80Q\x94\x83\x01\x92\x7F\xCD\xCA\x95\x0B\x17\xB5\xEF\xC0\x16\xB7K\x91-\x85'\xDF\xBA^@Jh\x8C\xBC=\xAB\x16\xCB\x942\x87\xFE\xC2\x86R3` \x87\x01R\x01`@\x85\x017`\xA0\x81\x015`\xA0\x84\x01R\x015`\xC0\x82\x01R \x90V[Pa\x1B\x99\x916\x15\x90a\x1FYV[P\x90`\xC0\x91```@\x80Q\x93\x7FZ\x7F\xEE\x80\0\xA27\x92\x9E\xF9\xBE\x08\xF2\x93<KO2\x0B\0\xB3\x88\t\xF3\xC7\xAA\x10MT!\x04\x9F\x85R3` \x86\x01R\x01`@\x84\x017`\xA0\x82\x01R \x90V[Pa\x1B\x99\x91`@6\x15\x17\x90a\x1FYV[Pa\x1B\x99\x916\x15\x90a\x1F\xF3V[Pa\x1B\x99\x91`@6\x15\x17\x90a\x1F\xF3V[\x90a\x01\0`@Q`\xA0`\xC0\x85\x015\x85\x01\x94``\x865\x96\x7FCompact(address arbiter,address \x85R` \x85\x01\x97\x7Fsponsor,uint256 nonce,uint256 ex\x89R\x80`@\x87\x01\x92\x7Fpires,uint256 id,uint256 amount,\x84R` \x01\x84\x88\x017\x82\x01\x85 \x97\x88\x86R3\x90R`@\x83\x01\x907`\xE0\x81\x015\x82\x84\x01R\x83\x81\x015`\xC0\x84\x01R\x015`\xE0\x82\x01R \x91\x90V[`\xE0\x90\x92\x91\x92`\xA0`@Q\x91`\xC0\x81\x015\x81\x01\x95``\x875\x97\x7FBatchCompact(address arbiter,add\x86R` \x86\x01\x98\x7Fress sponsor,uint256 nonce,uint2\x8AReounts,`F\x88\x01R\x80`@\x88\x01\x92\x7F56 expires,uint256[2][] idsAndAm\x84R` \x01`f\x89\x017`f\x01\x86 \x98\x89\x87R3\x90R`@\x84\x01\x907\x82\x84\x01R\x015`\xC0\x82\x01R \x91\x90V[\x92\x91\x92\x80`+\x14a*\xC5W`)\x14a*\x03WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a\x01\0\x90`\xA0`@Q\x91\x83`\xC0\x82\x015\x82\x01\x96``\x885\x98\x7FCompact(address arbiter,address \x87R` \x87\x01\x99\x7Fsponsor,uint256 nonce,uint256 ex\x8BR\x80`@\x89\x01\x92\x7Fpires,uint256 id,uint256 amount,\x84R` \x01\x84\x8A\x017\x82\x01\x87 \x99\x8A\x88R3\x90R`@\x85\x01\x907\x82\x01`\xE0\x81\x015\x84\x86\x01R\x015`\xC0\x84\x01R\x015`\xE0\x82\x01R \x91\x90V[P`\xE0\x90`\xA0`@Q\x91`\xC0\x81\x015\x81\x01\x95``\x875\x97\x7FBatchCompact(address arbiter,add\x86R` \x86\x01\x98\x7Fress sponsor,uint256 nonce,uint2\x8AReounts,`F\x88\x01R\x80`@\x88\x01\x92\x7F56 expires,uint256[2][] idsAndAm\x84R` \x01`f\x89\x017`f\x01\x86 \x98\x89\x87R3\x90R`@\x84\x01\x907\x82\x84\x01R\x015`\xC0\x82\x01R \x91\x90V[\x91\x90a+\xA6\x90a+\x95\x84a$\xD9V[\x94\x90\x85\x91`@6\x15\x17\x90`,a0\x11V[\x91\x90V[\x91\x90a+\xA6\x90a+\xB9\x84a$\xD9V[\x94\x90\x85\x91`@6\x15\x17\x90`-a0\x11V[\x91a+\xDAa+\xA6\x92\x84`+a)\xDDV[\x92\x90\x93\x84`@6\x15\x17\x91a\"\x87V[\x91a+\xDAa+\xA6\x92\x84`)a)\xDDV[\x91a+\xA6`@\x93a, \x93a,\r\x82a$\xD9V[\x95\x90\x91\x866\x15\x93`\x80\x85\x17\x86`,a0\x11V[\x95\x86\x91\x17\x91a\"\x87V[\x91a+\xA6`@\x93a, \x93a,>\x82a$\xD9V[\x95\x90\x91\x866\x15\x93`\x80\x85\x17\x86`-a0\x11V[\x93\x90\x92\x93\x80`4\x14a-\x14W`3\x14a,xWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[g\xED\xCA\xA8\x9A\x82)9@` R\x82`\x14R\x83_R`@_ \x80T\x80\x83\x11\x83\x15\x17a-\x07W\x82\x90\x03\x90U\x81`\x14R\x83_R`@_ \x80T\x90\x82\x82\x01\x91\x82\x10a,\xFAWU3_R` R`\x01\x80`\xA0\x1B\x03\x16\x90`\x01\x80`\xA0\x1B\x03\x16\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y`@_\xA4`\x01\x90V[c\x89V\x0C\xA1_R`\x04`\x1C\xFD[c\xF4\xD6x\xB8_R`\x04`\x1C\xFD[P\x91\x90\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x04\x14a/\xE5W\x80`\x03\x14a/\xD3W\x80`\t\x14a/\xC0W\x80`\n\x14a/\x83W`\x08\x14a-tWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a-\x86h\x92\x9E\xEE\x14\x9BK\xD2\x12ha\"1V[\x80[a/sWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x02\x14a/FW`\x01\x14a-\xD1WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[3h\x92\x9E\xEE\x14\x9BK\xD2\x12h][`\x01`\x01`\xA0\x1B\x03\x85\x16\x90\x81a.\xE9WPP_\x90\x81\x80\x858\x93Z\xF1\x15a.\xDCW[g\xED\xCA\xA8\x9A\x82)9@` R\x80`\x14R\x82_R`@_ \x91\x82T\x92\x83\x82\x11a-\x07W\x81_\x94\x03\x90U3\x83R` R`\x01\x80`\xA0\x1B\x03\x16\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y`@\x83\xA4\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x06\x14a.\xAFW`\x05\x14a.\x9EWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[_h\x92\x9E\xEE\x14\x9BK\xD2\x12h]`\x01\x90V[P_T`\xFF\x16\x15a.\xCBW_h\x92\x9E\xEE\x14\x9BK\xD2\x12h]`\x01\x90V[_h\x92\x9E\xEE\x14\x9BK\xD2\x12hU`\x01\x90V[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x90\x91\x92\x93Pa.\xF80\x83a\x18\xDBV[\x92`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10\x82\x85Z\xF1=\x15`\x01_Q\x14\x17\x16\x15a/9Wa/1\x90_`4R0\x90a\x18\xDBV[\x90\x03\x90a-\xFFV[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[P_T`\xFF\x16\x15a/bW3h\x92\x9E\xEE\x14\x9BK\xD2\x12h]a-\xDEV[3h\x92\x9E\xEE\x14\x9BK\xD2\x12hUa-\xDEV[c\xF5|D\x8B_R` R`$`\x1C\xFD[Pa/\xBA6\x15`\xE0`@\x82\x17h\x92\x9E\xEE\x14\x9BK\xD2\x12h\x01`\xC0\x81\x015_R\x015` R`@_ \x90h\x92\x9E\xEE\x14\x9BK\xD2\x12ha\x1F\xF3V[\x80a-\x88V[Pa/\xBAh\x92\x9E\xEE\x14\x9BK\xD2\x12ha\x1F\xD3V[Ph\x92\x9E\xEE\x14\x9BK\xD2\x12h\\\x80a-\x88V[P_T`\xFF\x16\x15a0\x01Wh\x92\x9E\xEE\x14\x9BK\xD2\x12h\\\x80a-\x88V[h\x92\x9E\xEE\x14\x9BK\xD2\x12hTa/\xBAV[\x95\x94\x93\x91\x90\x92\x95\x80`,\x14a0\xF8W`-\x14a0;WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[`@Q\x93``\x85\x01R\x85\x84R_Q` a2o_9_Q\x90_R` \x85\x01\x963\x88RF`@\x87\x01R\x14\x15\x80a0\xE9W[`\x05\x1B`\x80\x01\x84 \x90\x83\x01\x90`\xA0\x82\x015\x84\x01\x90`\xC0\x825`\x05\x1B\x93\x015`\x05\x1B_\x90_[\x85\x81\x10a0\xBAWPPPPP``\x92`\xA0\x95\x96\x92`@\x92` \x01\x86 `\x80\x87\x01R\x85R\x01\x907 \x90V[\x80\x89\x01` \x84\x83\x01\x87\x01\x015\x81R\x82\x82\x14a0\xD9W[P` \x01a0\x90V[` \x90\x81\x01\x85\x90R\x92P\x82a0\xD0V[`\xA0\x84\x015`\x80\x86\x01Ra0kV[P``\x92`\xA0\x95\x96\x92\x86`@\x93\x84Q\x97\x87\x89\x01R\x85\x88R_Q` a2o_9_Q\x90_R` \x89\x01\x963\x88RF\x87\x8B\x01R\x14\x15\x80a1aW[`\x05\x1B`\x80\x01\x88 \x88R\x83\x01\x015\x82\x01\x805`\x05\x1B\x80\x91` \x01\x867` \x01\x86 `\x80\x87\x01R\x85R\x01\x907 \x90V[\x82\x85\x015`\x80\x8A\x01Ra12V[\x96\x95\x94\x93\x92\x91\x90\x96\x80`'\x14a2[W\x80`$\x14a2FW\x80`!\x14a21W\x80`#\x14a2!W\x80`\x1F\x14a2\x0CW\x80`&\x14a1\xF9W\x80`\"\x14a1\xEEW\x80`%\x14a1\xDBW`\x17\x14a1\xD2WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a\x1B\x99\x96a\x1CnV[P\x90`\x17\x95\x94\x93\x92\x91\x87a\x1B\x99\x98a!\xE3V[P\x86a\x1B\x99\x97a\x1B9V[P\x90`\x17\x95\x94\x93\x92\x91\x87a\x1B\x99\x98a\x1D\xC6V[P\x91a\x1B\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93a\x1D\xC6V[P\x90a\x1B\x99\x96\x92\x916\x15\x93a\x1B9V[P\x91a\x1B\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93a \xE9V[P\x91a\x1B\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93a!\xE3V[P\x90`\x17\x95\x94\x93\x92\x91\x87a\x1B\x99\x98a \xE9V\xFE)_\xEB\tWg\xCCg\xD7\xE7F\x95\xDA\n\xDA\xDD\xED\xE5M{q\x94\xA8\xA5Bo\xE8\xF05\x1E\x037\xA1dsolcC\0\x08\x1C\0\n`\x80\x80`@R4`\x15Wa>\x10\x90\x81a\0\x1A\x829\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80b\xAD\x80\x0C\x14a7\x04W\x80cNA\xA1\xFB\x14a6\x96Wc\xD67\xCA\x8D\x14a\09W_\x80\xFD[4a6~W6`\x03\x19\x01`\xA0\x81\x12a6~W`\x80\x13a6~W`@Q`\x80\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a6\x82W`@R`\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x81\x83\x03a6~W\x82\x81R`$5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a6~W` \x81\x01\x91\x82R`D5\x92`\x08\x84\x10\x15a6~W`@\x82\x01\x93\x84R`d5\x94`\x02\x86\x10\x15a6~W``\x83\x81\x01\x96\x87R\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16a6lWPa\x01\x1C`@Qa\0\xF2`@\x82a7\x93V[`\x0C\x81Rk'0\xBA4\xBB2\x90*7\xB5\xB2\xB7`\xA1\x1B` \x82\x01R\x92[Q`\x01`\x01`\xA0\x1B\x03\x16a8\xA1V[\x92Q`\x08\x81\x10\x15a6XWa\x010\x90a9\xC8V[\x93Q`\x02\x81\x10\x15a6XWa\x01D\x90a;\xBAV[\x81Qa\x01X\x90`\x01`\x01`\xA0\x1B\x03\x16a7\xB5V[\x82Q\x90\x91\x90a\x01o\x90`\x01`\x01`\xA0\x1B\x03\x16a84V[\x92Qc1<\xE5g`\x04\x90\x81R_\x81\x90R` \x91\x82\x91\x90\x82\x90`\x01`\x01`\xA0\x1B\x03\x16b\x01\x86\xA0\xFA=`\x1F\x10\x16` Q\x02`\xFF\x16a\x01\xAA\x90a<YV[\x91`@Q\x95` \x87\x01\x97q\x03\xD9\x13s\x0Bk)\x11\xD1\x01\x12\x1B{k\x83\x0B\x1B\xA1`u\x1B\x89R\x87\x86Q\x80` \x89\x01`2\x84\x01^\x81\x01a\x08\x8B`\xF2\x1B`2\x82\x01R\x03`2\x01`\x1D\x19\x81\x01\x89R`\x02\x01a\x01\xFE\x90\x89a7\x93V[`@Q\x94` \x86\x01\x94\x7F\"description\": \"Compact \0\0\0\0\0\0\0\0\x86R\x84Q\x80` \x87\x01`8\x8A\x01^\x87\x01`8\x81\x01a\x04\x05`\xF3\x1B\x90R\x89Q\x90\x81` \x8C\x01`:\x83\x01^\x01`8\x01`\x02\x81\x01\x7F) resource lock with allocator \0\x90R\x84Q\x90\x81` \x87\x01`!\x83\x01^\x01`\x02\x01\x93`\x1F\x85\x01t\x01\x03\x0Bs!\x03\x93+\x9B+\xA1\x03\x83+\x93K{!\x03{1`]\x1B\x90R\x87\x84Q` \x86\x01\x96\x81\x88`4\x83\x01^\x01`\x1F\x01a\x08\x8B`\xF2\x1B`\x15\x82\x01R\x03`\x15\x01`\x1D\x19\x81\x01\x89R`\x02\x01a\x02\xE3\x90\x89a7\x93V[a\x02\xEE`\x845a<YV[`@Q\x90a\x02\xFD`@\x83a7\x93V[`\x02\x82Ra\x12Q`\xF2\x1B` \x83\x01Ra\x03\x15\x91a<\x9EV[\x99`@Q\x90a\x03%`@\x83a7\x93V[`\r\x82RlToken Address`\x98\x1B` \x83\x01Ra\x03H\x91a<\x9EV[\x95`@Q\x90a\x03X`@\x83a7\x93V[`\n\x82RiToken Name`\xB0\x1B` \x83\x01Ra\x03x\x91a<\x9EV[\x98`@Q\x90a\x03\x88`@\x83a7\x93V[`\x0C\x82Rk\x15\x1B\xDA\xD9[\x88\x14\xDE[X\x9B\xDB`\xA2\x1B` \x83\x01Ra\x03\xAA\x91a<\x9EV[\x92`@Q\x90a\x03\xBA`@\x83a7\x93V[`\x0E\x82RmToken Decimals`\x90\x1B` \x83\x01Ra\x03\xDE\x91a<\x9EV[\x90`@Q\x90a\x03\xEE`@\x83a7\x93V[`\t\x82Rh \xB667\xB1\xB0\xBA7\xB9`\xB9\x1B` \x83\x01Ra\x04\r\x91a<\x9EV[\x91`@Q\x90a\x04\x1D`@\x83a7\x93V[`\x05\x82RdScope`\xD8\x1B` \x83\x01Ra\x048\x91a<\x9EV[\x92`@Q\x95a\x04H`@\x88a7\x93V[`\x0C\x87R` \x87\x01\x90k\x14\x99\\\xD9]\x08\x14\x19\\\x9A[\xD9`\xA2\x1B\x82R`@Q\x90a\x04r` \x83a7\x93V[_\x82R`@Q\x97\x88\x93` \x85\x01\x9Ao=\x91:90\xB4\xBA/\xBA<\xB82\x91\x1D\x10\x11`\x81\x1B\x8CRQ\x80\x91`0\x87\x01^\x84\x01\x90l\x11\x16\x10\x11;0\xB6:\xB2\x91\x1D\x10\x11`\x99\x1B`0\x83\x01RQ\x80\x92`=\x83\x01^\x01`0\x01a\"}`\xF0\x1B`\r\x82\x01R\x81Q` \x81\x93\x01`\x0F\x83\x01^\x01`\r\x01`\x02\x81\x01_\x90R\x03`\x02\x01`\x1F\x19\x81\x01\x86Ra\x04\xFA\x90\x86a7\x93V[`@Q\x99\x8A\x97` \x89\x01\x9C\x8Dn\"attributes\": [`\x88\x1B\x90R\x80Q` \x81\x92\x01`/\x8C\x01^\x89\x01`/\x81\x01\x91_\x83R\x80Q\x92` \x84\x92\x01\x90^\x01`/\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01\x90_\x82RQ\x80\x92\x82^\x01a]}`\xF0\x1B\x81R\x03`\x1D\x19\x81\x01\x84R`\x02\x01a\x05\xA7\x90\x84a7\x93V[`@Q\x90a\x05\xB7a'\xC0\x83a7\x93V[a'\x8E\x82R\x7F\"image\": \"data:image/svg+xml;bas` \x80\x84\x01\x91\x82R\x7Fe64,PD94bWwgdmVyc2lvbj0iMS4wIiBl`@\x80\x86\x01\x91\x90\x91R\x7FbmNvZGluZz0iaXNvLTg4NTktMSI/Pg0K``\x86\x01R\x7FPCEtLSBHZW5lcmF0b3I6IEFkb2JlIEls`\x80\x86\x01R\x7FbHVzdHJhdG9yIDIzLjAuNSwgU1ZHIEV4`\xA0\x86\x01R\x7FcG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNp`\xC0\x86\x01R\x7Fb246IDYuMDAgQnVpbGQgMCkgIC0tPg0K`\xE0\x86\x01R\x7FPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5za\x01\0\x86\x01R\x7FPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwa\x01 \x86\x01R\x7FL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6a\x01@\x86\x01R\x7FLy93d3cudzMub3JnLzE5OTkveGxpbmsia\x01`\x86\x01R\x7FIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3a\x01\x80\x86\x01R\x7FQm94PSIwIDAgNDkyIDQ5MiIgc3R5bGU9a\x01\xA0\x86\x01R\x7FImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwa\x01\xC0\x86\x01R\x7FIDAgNDkyIDQ5MjsiIHhtbDpzcGFjZT0ia\x01\xE0\x86\x01R\x7FcHJlc2VydmUiPg0KPGcgaWQ9Ik1hc3Rla\x02\0\x86\x01R\x7Fcl9MYXllcl8yIj4NCjwvZz4NCjxnIGlka\x02 \x86\x01R\x7FPSJMYXllcl8xIj4NCgk8Zz4NCgkJPGc+a\x02@\x86\x01R\x7FDQoJCQk8Zz4NCgkJCQk8Zz4NCgkJCQkJa\x02`\x86\x01R\x7FPHBhdGggc3R5bGU9ImZpbGwtcnVsZTpla\x02\x80\x86\x01R\x7FdmVub2RkO2NsaXAtcnVsZTpldmVub2Rka\x02\xA0\x86\x01R\x7FO2ZpbGw6IzIxMjEyMTsiIGQ9Ik0zMjEua\x02\xC0\x86\x01R\x7FMzA4LDI5NC44NjRjNS4zNTIsNS4zMjgsa\x02\xE0\x86\x01R\x7FOS40NTYsMTIuMTQ0LDE1Ljc5Miw4Ljgza\x03\0\x86\x01R\x7FMg0KCQkJCQkJYzIuNDQ4LTEuMjcyLDUua\x03 \x86\x01R\x7FMDY0LTMuMDk2LDcuMzItNS4yNTZjMy43a\x03@\x86\x01R\x7FNDQtMy41NzYsOC4yNTYtOS41MjgsNC42a\x03`\x86\x01R\x7FNTYtMTQuMjhjLTEyLjQ1Ni0xMS45NzYta\x03\x80\x86\x01R\x7FMzYuMzg0LTMyLjExMi0zNi40NTYtMzIua\x03\xA0\x86\x01R\x7FMTYNCgkJCQkJCWw3LjU2LTguNTY4YzAua\x03\xC0\x86\x01R\x7FMDI0LDAuMDI0LDUuMTYsNC41MzYsMTEua\x03\xE0\x86\x01R\x7FODMyLDEwLjgyNGM4LjY4OCw4LjIwOCwya\x04\0\x86\x01R\x7FMC44NTYsMTYuMiwyNi43MzYsMjQuNDA4a\x04 \x86\x01R\x7FDQoJCQkJCQljMy4zMTIsNC42MDgsMi42a\x04@\x86\x01R\x7FMTYsMTIuNzQ0LDAuODY0LDE3LjUyYy0xa\x04`\x86\x01R\x7FLjM5MiwzLjg0LTQuMTA0LDcuNDY0LTcua\x04\x80\x86\x01R\x7FMzIsMTAuNTM2Yy0zLjAyNCwyLjkwNC02a\x04\xA0\x86\x01R\x7FLjYsNS40LTkuOTYsNy4xMjgNCgkJCQkJa\x04\xC0\x86\x01R\x7FCWMtMy4zODQsMS43NTItNi43OTIsMi43a\x04\xE0\x86\x01R\x7FNi05LjY5NiwyLjc4NGMtMC4wOTYsMC40a\x05\0\x86\x01R\x7FNTYtMC4yMTYsMC45MzYtMC4zMzYsMS4za\x05 \x86\x01R\x7FOTJjLTAuOTYsMy4yNC0zLjAyNCw2LjA3a\x05@\x86\x01R\x7FMi01LjYxNiw4LjQNCgkJCQkJCWMtMi4za\x05`\x86\x01R\x7FMjgsMi4wODgtNS4xMzYsMy44MTYtNy45a\x05\x80\x86\x01R\x7FNDQsNS4wNjRjLTMuMDcyLDEuMzQ0LTYua\x05\xA0\x86\x01R\x7FMjg4LDIuMTEyLTkuMTY4LDIuMTZjLTAua\x05\xC0\x86\x01R\x7FMDk2LDAuOTM2LTAuMjg4LDEuODQ4LTAua\x05\xE0\x86\x01R\x7FNTUyLDIuNzYNCgkJCQkJCWMtMC45Niwza\x06\0\x86\x01R\x7FLjI0LTMuMDI0LDYuMDcyLTUuNjE2LDgua\x06 \x86\x01R\x7FNGMtMi4zMjgsMi4wODgtNS4xMzYsMy44a\x06@\x86\x01R\x7FMTYtNy45NDQsNS4wNjRjLTQuMTI4LDEua\x06`\x86\x01R\x7FODI0LTguNTQ0LDIuNTY4LTEyLDEuOTY4a\x06\x80\x86\x01R\x7FDQoJCQkJCQljLTAuMTIsMS4yMjQtMC4za\x06\xA0\x86\x01R\x7FNiwyLjQtMC42OTYsMy41MDR2MC4wMjRja\x06\xC0\x86\x01R\x7FLTEuMDMyLDMuMzg0LTMsNi4yNC01LjUya\x06\xE0\x86\x01R\x7FLDguMzUyYy0yLjUyLDIuMTEyLTUuNTkya\x07\0\x86\x01R\x7FLDMuNDgtOC44NTYsMy45MzYNCgkJCQkJa\x07 \x86\x01R\x7FCWMtMy45NiwwLjU1Mi04LjE2LTAuMjQta\x07@\x86\x01R\x7FMTEuOTA0LTIuNjg4Yy0xLjAzMi0wLjY3a\x07`\x86\x01R\x7FMi0yLjE2LTEuNTM2LTMuNDgtMi41OTJsa\x07\x80\x86\x01R\x7FLTAuNzQ0LTAuNTc2bC0xMS4xNi04LjYxa\x07\xA0\x86\x01R\x7FNmw2Ljk2LTkuMDI0bDExLjE2LDguNjE2a\x07\xC0\x86\x01R\x7FDQoJCQkJCQlsMC43NDQsMC41NzZjMS4wa\x07\xE0\x86\x01R\x7FMzIsMC43OTIsMS44OTYsMS40ODgsMi43a\x08\0\x86\x01R\x7FODQsMi4wNGMxLjI5NiwwLjg2NCwyLjcza\x08 \x86\x01R\x7FNiwxLjEyOCw0LjA4LDAuOTZjMS4xMjgta\x08@\x86\x01R\x7FMC4xNjgsMi4xODQtMC42NDgsMy4wNzIta\x08`\x86\x01R\x7FMS4zOTINCgkJCQkJCWMwLjg2NC0wLjcya\x08\x80\x86\x01R\x7FLDEuNTYtMS43MjgsMS45Mi0yLjkwNGwwa\x08\xA0\x86\x01R\x7FLDBjMC40NTYtMS41NiwwLjM4NC0zLjUwa\x08\xC0\x86\x01R\x7FNC0wLjQ1Ni01Ljc2Yy05LjUyOC0xMy4ya\x08\xE0\x86\x01R\x7FOTYtMjkuNDQ4LTI5LjQyNC0yOS40OTYta\t\0\x86\x01R\x7FMjkuNDcyDQoJCQkJCQlsNy4yLTguODU2a\t \x86\x01R\x7FYzAuMDQ4LDAuMDI0LDguMTEyLDYuNTc2a\t@\x86\x01R\x7FLDE2Ljc1MiwxNS4wMjRjMi4zMDQsMi4ya\t`\x86\x01R\x7FNTYsNC44NDgsNC43NTIsNy41MTIsNy4xa\t\x80\x86\x01R\x7FMjhjMC40OCwwLjQzMiwwLjk4NCwwLjg2a\t\xA0\x86\x01R\x7FNCwxLjQ2NCwxLjI5Ng0KCQkJCQkJbDAsa\t\xC0\x86\x01R\x7FMGwwLDBjMC4wOTYsMC4wOTYsMC4yMTYsa\t\xE0\x86\x01R\x7FMC4xOTIsMC4zMTIsMC4yODhjMC42MjQsa\n\0\x86\x01R\x7FMC41NTIsMS4yNDgsMS4xMjgsMS44NzIsa\n \x86\x01R\x7FMS43MDRjMi4xMTIsMS44OTYsNC4yLDMua\n@\x86\x01R\x7FODE2LDYuMzg0LDUuNDk2DQoJCQkJCQlja\n`\x86\x01R\x7FMi41OTIsMS44NDgsMi41NDQsMi4yMzIsa\n\x80\x86\x01R\x7FNS40OTYsMS4zNDRjMC42MjQtMC4xOTIsa\n\xA0\x86\x01R\x7FMS4yOTYtMC41MjgsMi4wMTYtMC44NGMxa\n\xC0\x86\x01R\x7FLjc3Ni0wLjc2OCwzLjUwNC0xLjg0OCw0a\n\xE0\x86\x01R\x7FLjg5Ni0zLjA5Ng0KCQkJCQkJYzEuMTI4a\x0B\0\x86\x01R\x7FLTEuMDMyLDEuOTkyLTIuMTEyLDIuMzA0a\x0B \x86\x01R\x7FLTMuMTY4YzAuMjQtMC44NCwwLjA3Mi0xa\x0B@\x86\x01R\x7FLjg0OC0wLjc0NC0yLjk3NmMtOS41NzYta\x0B`\x86\x01R\x7FMTMuMzItMzUuOTA0LTM2LjQ1Ni0zNS45a\x0B\x80\x86\x01R\x7FNzYtMzYuNTI4bDcuNTYtOC41NjgNCgkJa\x0B\xA0\x86\x01R\x7FCQkJCWMwLjA0OCwwLjA0OCwxNC42ODgsa\x0B\xC0\x86\x01R\x7FMTIuOTEyLDI2LjYxNiwyNS40ODhjMy4ya\x0B\xE0\x86\x01R\x7FNCwzLjE5Miw4LjA2NCw3LjU2LDExLjU0a\x0C\0\x86\x01R\x7FNCwxMC4yNzJjMS4yNzIsMC45MTIsMi4xa\x0C \x86\x01R\x7FNiwyLjA4OCw0LjA4LDEuNDE2DQoJCQkJa\x0C@\x86\x01R\x7FCQljMC44MTYtMC4yODgsMS44NDgtMC42a\x0C`\x86\x01R\x7FOTYsMy0xLjJjMS43NzYtMC43NjgsMy41a\x0C\x80\x86\x01R\x7FMDQtMS44NDgsNC44OTYtMy4wOTZjMS4xa\x0C\xA0\x86\x01R\x7FMjgtMS4wMDgsMS45OTItMi4xMTIsMi4za\x0C\xC0\x86\x01R\x7FMDQtMy4xNjgNCgkJCQkJCWMwLjI0LTAua\x0C\xE0\x86\x01R\x7FODQsMC4wNzItMS44NDgtMC43NDQtM2Mta\r\0\x86\x01R\x7FOS41NzYtMTMuMzItMzUuOTA0LTM2LjQ1a\r \x86\x01R\x7FNi0zNS45NzYtMzYuNTI4bDcuNTYtOC41a\r@\x86\x01R\x7FNjgNCgkJCQkJCUMyOTIuMjIsMjY2LjY4a\r`\x86\x01R\x7FOCwzMDkuMDQ0LDI4MS40OTYsMzIxLjMwa\r\x80\x86\x01R\x7FOCwyOTQuODY0eiIvPg0KCQkJCTwvZz4Na\r\xA0\x86\x01R\x7FCgkJCQk8Zz4NCgkJCQkJPHBhdGggc3R5a\r\xC0\x86\x01R\x7FbGU9ImZpbGwtcnVsZTpldmVub2RkO2Nsa\r\xE0\x86\x01R\x7FaXAtcnVsZTpldmVub2RkO2ZpbGw6IzIxa\x0E\0\x86\x01R\x7FMjEyMTsiIGQ9Ik00MjkuMDIsMjU0LjQya\x0E \x86\x01R\x7FNEwzOTMuNjkyLDEyOS43MmwtMS41MzYta\x0E@\x86\x01R\x7FNS40NDhsLTUuNDQ4LDEuNDg4DQoJCQkJa\x0E`\x86\x01R\x7FCQlsLTQ1LjIxNiwxMi40MDhsLTUuNTY4a\x0E\x80\x86\x01R\x7FLDEuNTM2bDEuNTYsNS41MmwyLjEzNiw3a\x0E\xA0\x86\x01R\x7FLjUzNmMtMjEuNjk2LDEuOTY4LTQyLjg0a\x0E\xC0\x86\x01R\x7FLTIuNjY0LTYyLjU2OC02Ljk2DQoJCQkJa\x0E\xE0\x86\x01R\x7FCQljLTM5LjI2NC04LjU2OC03My4yOTYta\x0F\0\x86\x01R\x7FMTUuOTg0LTk5LjU3NiwyNS44OTZsMCwwa\x0F \x86\x01R\x7FYy03LjEwNCwxMS4zNTItMTQuODU2LDI0a\x0F@\x86\x01R\x7FLjg0LTE2LjY1NiwzNS4xNg0KCQkJCQkJa\x0F`\x86\x01R\x7FYy0yLjQ3MiwxNC4wNCwzLjAyNCwyMy4wa\x0F\x80\x86\x01R\x7FNCwyNS4yNDgsMTguOTZjMTMuNjU2LTIua\x0F\xA0\x86\x01R\x7FNDk2LDIyLjA4LTkuMzYsMjkuOTI4LTE1a\x0F\xC0\x86\x01R\x7FLjc2OGM4Ljg4LTcuMjQ4LDE2Ljg3Mi0xa\x0F\xE0\x86\x01R\x7FMy43NTIsMzIuMzc2LTkuMTQ0DQoJCQkJa\x10\0\x86\x01R\x7FCQljOC4xMzYsMy4zNiw4Ljg4LDMuNjcya\x10 \x86\x01R\x7FLDE1LjI0LDkuMDI0YzIxLjE0NCwxNy43a\x10@\x86\x01R\x7FMzYsNzEuNCw2MS41MzYsNzIsNjIuMDRsa\x10`\x86\x01R\x7FMCwwbDEwLjQxNiw5LjE2OGwyLjkwNCwya\x10\x80\x86\x01R\x7FLjU0NGwzLjQzMi0xLjc1Mg0KCQkJCQkJa\x10\xA0\x86\x01R\x7FbDIwLjg4LTEwLjYwOGwxLjI3Miw0LjQ4a\x10\xC0\x86\x01R\x7FOGw1LjQ3Mi0xLjU2bDQ1LjA5Ni0xMi43a\x10\xE0\x86\x01R\x7FNjhsNS40OTYtMS41Nkw0MjkuMDIsMjU0a\x11\0\x86\x01R\x7FLjQyNEw0MjkuMDIsMjU0LjQyNHogTTM1a\x11 \x86\x01R\x7FMC42MzYsMjY5Ljk3NmwtNy41MTItNi42a\x11@\x86\x01R\x7FDQoJCQkJCQlIMzQzLjFjLTAuMTQ0LTAua\x11`\x86\x01R\x7FMTItNTEuNjI0LTQ1LTcyLjE5Mi02Mi4ya\x11\x80\x86\x01R\x7FMzJjLTcuNzA0LTYuNDU2LTguNTY4LTYua\x11\xA0\x86\x01R\x7FODE2LTE4LjM2LTEwLjg3MmwtMC4yNC0wa\x11\xC0\x86\x01R\x7FLjA5NmwtMC41MjgtMC4xOTINCgkJCQkJa\x11\xE0\x86\x01R\x7FCWMtMjEuMzYtNi40NTYtMzEuNjA4LDEua\x12\0\x86\x01R\x7FOTItNDIuOTg0LDExLjIwOGMtNi43Njgsa\x12 \x86\x01R\x7FNS41Mi0xMy45OTIsMTEuNDI0LTI0Ljc2a\x12@\x86\x01R\x7FOCwxMy4zOTJjLTEwLjA4LDEuODQ4LTEya\x12`\x86\x01R\x7FLjc2OC0xLjAzMi0xMS45MjgtNS43ODQNa\x12\x80\x86\x01R\x7FCgkJCQkJCWMxLjQ4OC04LjQ3Miw4LjU0a\x12\xA0\x86\x01R\x7FNC0yMC42NjQsMTUuMDQ4LTMxLjA1NnYta\x12\xC0\x86\x01R\x7FMC4wMjRjMjEuOTYtMzUuMDY0LDUyLjM5a\x12\xE0\x86\x01R\x7FMi0yOC40NCw4Ny40OC0yMC43ODQNCgkJa\x13\0\x86\x01R\x7FCQkJCWMyMS4xOTIsNC42MDgsNDMuOTQ0a\x13 \x86\x01R\x7FLDkuNTc2LDY4LjE2LDYuOTM2bDI3LjI2a\x13@\x86\x01R\x7FNCw5Ni4yNEwzNTAuNjM2LDI2OS45NzZMa\x13`\x86\x01R\x7FMzUwLjYzNiwyNjkuOTc2eiBNMzgyLjM2a\x13\x80\x86\x01R\x7FNCwyNjEuNjk2TDM1MC4wNiwxNDcuNjI1a\x13\xA0\x86\x01R\x7FDQoJCQkJCQlsMzQuMi05LjM4NGwzMi4ya\x13\xC0\x86\x01R\x7FMzIsMTEzLjc4NEwzODIuMzY0LDI2MS42a\x13\xE0\x86\x01R\x7FOTZ6Ii8+DQoJCQkJPC9nPg0KCQkJCTxna\x14\0\x86\x01R\x7FPg0KCQkJCQk8cGF0aCBzdHlsZT0iZmlsa\x14 \x86\x01R\x7FbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxla\x14@\x86\x01R\x7FOmV2ZW5vZGQ7ZmlsbDojMjEyMTIxOyIga\x14`\x86\x01R\x7FZD0iTTE1NS4wMTMsMTQ1LjJsLTIuMjgsa\x14\x80\x86\x01R\x7FOC4wMTYNCgkJCQkJCWMxMC4yMjQsMC4ya\x14\xA0\x86\x01R\x7FMTYsMjkuNTkyLDAuMDQ4LDQ1LjcyLTMua\x14\xC0\x86\x01R\x7FNmwyLjQ5NiwxMS4xMzZjLTE4Ljk2LDQua\x14\xE0\x86\x01R\x7FMjk2LTQxLjgwOCw0LjEwNC01MS40MDgsa\x15\0\x86\x01R\x7FMy43OTJsLTI1LjQ4OCw4OS45NzYNCgkJa\x15 \x86\x01R\x7FCQkJCWM5LjY3MiwzLjA0OCwyNy44ODgsa\x15@\x86\x01R\x7FMTAuOTY4LDI5LjM1MiwyNy43MmwtMTEua\x15`\x86\x01R\x7FNCwwLjk4NGMtMC44ODgtMTAuMTUyLTEza\x15\x80\x86\x01R\x7FLjcyOC0xNS41MDQtMjEuMDcyLTE3Ljc2a\x15\xA0\x86\x01R\x7FbC0xLjM2OCw0LjgyNGwtMS41Niw1LjQ5a\x15\xC0\x86\x01R\x7FNg0KCQkJCQkJbC01LjQ3Mi0xLjU2bC00a\x15\xE0\x86\x01R\x7FNS4wOTYtMTIuNzY4bC01LjQ5Ni0xLjU2a\x16\0\x86\x01R\x7FbDEuNTYtNS40NzJsMzUuMzI4LTEyNC43a\x16 \x86\x01R\x7FMDRsMS41MzYtNS40NDhsNS40NDgsMS40a\x16@\x86\x01R\x7FODhsNDUuMjE2LDEyLjQwOGw1LjU2OCwxa\x16`\x86\x01R\x7FLjUzNg0KCQkJCQkJTDE1NS4wMTMsMTQ1a\x16\x80\x86\x01R\x7FLjJMMTU1LjAxMywxNDUuMkwxNTUuMDEza\x16\xA0\x86\x01R\x7FLDE0NS4yeiBNMTEwLjE1NywyNjEuNjk2a\x16\xC0\x86\x01R\x7FbDMyLjMwNC0xMTQuMDcybC0zNC4yLTkua\x16\xE0\x86\x01R\x7FMzg0TDc2LjAyOSwyNTIuMDI0TDExMC4xa\x17\0\x86\x01R\x7FNTcsMjYxLjY5NnoiLz4NCgkJCQk8L2c+a\x17 \x86\x01R\x7FDQoJCQkJPGc+DQoJCQkJCTxwYXRoIHN0a\x17@\x86\x01R\x7FeWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtja\x17`\x86\x01R\x7FbGlwLXJ1bGU6ZXZlbm9kZDtmaWxsOiMya\x17\x80\x86\x01R\x7FMTIxMjE7IiBkPSJNMjQwLjc2NCwzMzYua\x17\xA0\x86\x01R\x7FNjcyTDI0MC43NjQsMzM2LjY3Mg0KCQkJa\x17\xC0\x86\x01R\x7FCQkJYy0xLjEwNC0wLjgxNi0yLjQ0OC0xa\x17\xE0\x86\x01R\x7FLjA4LTMuNzQ0LTAuODg4cy0yLjQ5Niwwa\x18\0\x86\x01R\x7FLjg2NC0zLjMxMiwxLjk0NGwtOC44MzIsa\x18 \x86\x01R\x7FMTEuOTc2aDAuMDI0Yy0wLjgxNiwxLjEwa\x18@\x86\x01R\x7FNC0xLjEwNCwyLjQ3Mi0wLjkxMiwzLjc0a\x18`\x86\x01R\x7FNA0KCQkJCQkJYzAuMTkyLDEuMjcyLDAua\x18\x80\x86\x01R\x7FODY0LDIuNDcyLDEuOTQ0LDMuMjg4bDAua\x18\xA0\x86\x01R\x7FMTY4LDAuMTQ0YzEuMDU2LDAuNzIsMi4za\x18\xC0\x86\x01R\x7FNTIsMC45NiwzLjU3NiwwLjc2OGMxLjI5a\x18\xE0\x86\x01R\x7FNi0wLjE5MiwyLjQ5Ni0wLjg2NCwzLjMxa\x19\0\x86\x01R\x7FMi0xLjk0NA0KCQkJCQkJbDguODU2LTEya\x19 \x86\x01R\x7FYzAuODE2LTEuMTA0LDEuMDgtMi40NDgsa\x19@\x86\x01R\x7FMC44ODgtMy43NDRDMjQyLjUxNiwzMzgua\x19`\x86\x01R\x7FNjg4LDI0MS44NDQsMzM3LjQ4OCwyNDAua\x19\x80\x86\x01R\x7FNzY0LDMzNi42NzJMMjQwLjc2NCwzMzYua\x19\xA0\x86\x01R\x7FNjcyDQoJCQkJCQlMMjQwLjc2NCwzMzYua\x19\xC0\x86\x01R\x7FNjcyeiBNMTc2LjQyMSwyNjYuMjhjNC4ya\x19\xE0\x86\x01R\x7FMjQsMy4xMiw2LjgxNiw3LjY4LDcuNTM2a\x1A\0\x86\x01R\x7FLDEyLjUwNGMwLjMxMiwyLjA2NCwwLjI4a\x1A \x86\x01R\x7FOCw0LjE3Ni0wLjA5Niw2LjI0DQoJCQkJa\x1A@\x86\x01R\x7FCQljMS44OTYtMC45NiwzLjkzNi0xLjYwa\x1A`\x86\x01R\x7FOCw2LjAyNC0xLjkyYzUuMDE2LTAuNzQ0a\x1A\x80\x86\x01R\x7FLDEwLjI5NiwwLjM4NCwxNC42ODgsMy42a\x1A\xA0\x86\x01R\x7FMjR2MC4wMjRjNC40MTYsMy4yNCw3LjA4a\x1A\xC0\x86\x01R\x7FLDcuOTY4LDcuODI0LDEyLjk4NA0KCQkJa\x1A\xE0\x86\x01R\x7FCQkJYzAuMzEyLDEuOTkyLDAuMjg4LDQua\x1B\0\x86\x01R\x7FMDMyLTAuMDI0LDYuMDQ4YzAuNi0wLjE0a\x1B \x86\x01R\x7FNCwxLjE3Ni0wLjI2NCwxLjc3Ni0wLjM2a\x1B@\x86\x01R\x7FYzQuNTM2LTAuNjcyLDkuMzM2LDAuMzYsa\x1B`\x86\x01R\x7FMTMuMjk2LDMuMjg4bDAuMjg4LDAuMjQNa\x1B\x80\x86\x01R\x7FCgkJCQkJCWMzLjgxNiwyLjkyOCw2LjE0a\x1B\xA0\x86\x01R\x7FNCw3LjEyOCw2LjgxNiwxMS41MmMwLjIxa\x1B\xC0\x86\x01R\x7FNiwxLjM2OCwwLjI2NCwyLjc2LDAuMTQ0a\x1B\xE0\x86\x01R\x7FLDQuMTUyYzAuMjE2LTAuMDQ4LDAuNDA4a\x1C\0\x86\x01R\x7FLTAuMDcyLDAuNjI0LTAuMDk2DQoJCQkJa\x1C \x86\x01R\x7FCQljNC4xMjgtMC42MjQsOC41NDQsMC4za\x1C@\x86\x01R\x7FMzYsMTIuMTkyLDMuMDI0bDAsMGMzLjY3a\x1C`\x86\x01R\x7FMiwyLjcxMiw1Ljg4LDYuNjI0LDYuNTA0a\x1C\x80\x86\x01R\x7FLDEwLjc3NmMwLjYyNCw0LjEyOC0wLjMza\x1C\xA0\x86\x01R\x7FNiw4LjU0NC0zLjA0OCwxMi4xOTINCgkJa\x1C\xC0\x86\x01R\x7FCQkJCWwtOC44NTYsMTJjLTIuNzEyLDMua\x1C\xE0\x86\x01R\x7FNjcyLTYuNjI0LDUuODgtMTAuNzc2LDYua\x1D\0\x86\x01R\x7FNTA0Yy00LjEyOCwwLjYyNC04LjUyLTAua\x1D \x86\x01R\x7FMzM2LTEyLjE5Mi0zLjAyNHYwLjAyNA0Ka\x1D@\x86\x01R\x7FCQkJCQkJYy0zLjY0OC0yLjY4OC01Ljg4a\x1D`\x86\x01R\x7FLTYuNjI0LTYuNTA0LTEwLjhjLTAuMDcya\x1D\x80\x86\x01R\x7FLTAuNDgtMC4xMi0wLjk2LTAuMTQ0LTEua\x1D\xA0\x86\x01R\x7FNDRjLTEuMDA4LDAuMzM2LTIuMDQsMC42a\x1D\xC0\x86\x01R\x7FLTMuMDcyLDAuNzQ0DQoJCQkJCQljLTQua\x1D\xE0\x86\x01R\x7FNTEyLDAuNjcyLTkuMzEyLTAuMzYtMTMua\x1E\0\x86\x01R\x7FMjk2LTMuMzEybDAsMGMtMy45ODQtMi45a\x1E \x86\x01R\x7FNTItNi40MDgtNy4yMjQtNy4wOC0xMS43a\x1E@\x86\x01R\x7FMzZjLTAuMTQ0LTAuOTEyLTAuMjE2LTEua\x1E`\x86\x01R\x7FODI0LTAuMTkyLTIuNzYNCgkJCQkJCWMta\x1E\x80\x86\x01R\x7FMS41MTIsMC42MjQtMy4wNzIsMS4wOC00a\x1E\xA0\x86\x01R\x7FLjY4LDEuMzJjLTUuMDE2LDAuNzQ0LTEwa\x1E\xC0\x86\x01R\x7FLjI5Ni0wLjM4NC0xNC42ODgtMy42MjRsa\x1E\xE0\x86\x01R\x7FMCwwYy00LjM5Mi0zLjI0LTcuMDgtNy45a\x1F\0\x86\x01R\x7FOTItNy44MjQtMTMuMDA4DQoJCQkJCQlja\x1F \x86\x01R\x7FLTAuMzg0LTIuNDcyLTAuMjg4LTUuMDE2a\x1F@\x86\x01R\x7FLDAuMzEyLTcuNDg4Yy0xLjU4NCwwLjcya\x1F`\x86\x01R\x7FLTMuMjY0LDEuMi00Ljk2OCwxLjQ2NGMta\x1F\x80\x86\x01R\x7FNC44MjQsMC43Mi05LjkxMi0wLjM4NC0xa\x1F\xA0\x86\x01R\x7FNC4xMzYtMy40OA0KCQkJCQkJYy00LjIya\x1F\xC0\x86\x01R\x7FNC0zLjEyLTYuODE2LTcuNjgtNy41MzYta\x1F\xE0\x86\x01R\x7FMTIuNTA0czAuMzg0LTkuOTEyLDMuNDgta \0\x86\x01R\x7FMTQuMTM2aDAuMDI0bDEwLjk5Mi0xNC45a  \x86\x01R\x7FMDRjMy4xMi00LjI0OCw3LjY4LTYuODE2a @\x86\x01R\x7FLDEyLjQ4LTcuNTM2DQoJCQkJCQlDMTY3a `\x86\x01R\x7FLjA4NSwyNjIuMDU2LDE3Mi4xNzMsMjYza \x80\x86\x01R\x7FLjE2LDE3Ni40MjEsMjY2LjI4TDE3Ni40a \xA0\x86\x01R\x7FMjEsMjY2LjI4TDE3Ni40MjEsMjY2LjI4a \xC0\x86\x01R\x7FTDE3Ni40MjEsMjY2LjI4eiBNMTcyLjY1a \xE0\x86\x01R\x7FMywyODAuNDY0DQoJCQkJCQljLTAuMjg4a!\0\x86\x01R\x7FLTEuOTQ0LTEuMzItMy43NjgtMi45NzYta! \x86\x01R\x7FNC45OTJ2LTAuMDI0Yy0xLjY4LTEuMjI0a!@\x86\x01R\x7FLTMuNzItMS42NTYtNS42ODgtMS4zNjhja!`\x86\x01R\x7FLTEuOTY4LDAuMjg4LTMuNzkyLDEuMzIta!\x80\x86\x01R\x7FNS4wMTYsMi45NzYNCgkJCQkJCWwtMTAua!\xA0\x86\x01R\x7FOTkyLDE0Ljg4aDAuMDI0Yy0xLjI0OCwxa!\xC0\x86\x01R\x7FLjY4LTEuNjgsMy43NDQtMS4zOTIsNS42a!\xE0\x86\x01R\x7FODhjMC4yODgsMS45NDQsMS4zMiwzLjc2a\"\0\x86\x01R\x7FOCwyLjk3Niw0Ljk5Mg0KCQkJCQkJYzEua\" \x86\x01R\x7FNjgsMS4yNDgsMy43NDQsMS42OCw1LjY4a\"@\x86\x01R\x7FOCwxLjM5MnMzLjc2OC0xLjMyLDQuOTkya\"`\x86\x01R\x7FLTIuOTc2bDAuMDI0LDBsMTAuOTkyLTE0a\"\x80\x86\x01R\x7FLjg4aC0wLjAyNA0KCQkJCQkJQzE3Mi40a\"\xA0\x86\x01R\x7FODUsMjg0LjQ3MiwxNzIuOTQxLDI4Mi40a\"\xC0\x86\x01R\x7FMDgsMTcyLjY1MywyODAuNDY0TDE3Mi42a\"\xE0\x86\x01R\x7FNTMsMjgwLjQ2NEwxNzIuNjUzLDI4MC40a#\0\x86\x01R\x7FNjR6IE0yMDEuMDkyLDMwMS40MTYNCgkJa# \x86\x01R\x7FCQkJCWMtMC4zMTItMi4xMzYtMS40NC00a#@\x86\x01R\x7FLjE1Mi0zLjI2NC01LjQ5NnYwLjAyNGMta#`\x86\x01R\x7FMS44NDgtMS4zNjgtNC4xMDQtMS44NDgta#\x80\x86\x01R\x7FNi4yNC0xLjUzNmMtMi4xNiwwLjMzNi00a#\xA0\x86\x01R\x7FLjE1MiwxLjQ0LTUuNTIsMy4yNjQNCgkJa#\xC0\x86\x01R\x7FCQkJCWwtMTEuNjE2LDE1Ljc0NGMtMS4za#\xE0\x86\x01R\x7FNDQsMS44NDgtMS44MjQsNC4xMDQtMS41a$\0\x86\x01R\x7FMTIsNi4yNGMwLjMxMiwyLjEzNiwxLjQ0a$ \x86\x01R\x7FLDQuMTI4LDMuMjY0LDUuNDk2bDAsMA0Ka$@\x86\x01R\x7FCQkJCQkJYzEuODQ4LDEuMzY4LDQuMTA0a$`\x86\x01R\x7FLDEuODQ4LDYuMjQsMS41MzZjMi4xNi0wa$\x80\x86\x01R\x7FLjMxMiw0LjE1Mi0xLjQ0LDUuNTItMy4ya$\xA0\x86\x01R\x7FNjRsMCwwbDExLjYxNi0xNS43NDQNCgkJa$\xC0\x86\x01R\x7FCQkJCUMyMDAuOTQ4LDMwNS44MzIsMjAxa$\xE0\x86\x01R\x7FLjQyOCwzMDMuNTc2LDIwMS4wOTIsMzAxa%\0\x86\x01R\x7FLjQxNkwyMDEuMDkyLDMwMS40MTZMMjAxa% \x86\x01R\x7FLjA5MiwzMDEuNDE2eiBNMjIzLjI0NCwza%@\x86\x01R\x7FMjIuMTUyDQoJCQkJCQljLTAuMjQtMS42a%`\x86\x01R\x7FOC0xLjEwNC0zLjI0LTIuNTItNC4yNzJ2a%\x80\x86\x01R\x7FMC4wMjRjLTEuNDQtMS4wNTYtMy4xOTIta%\xA0\x86\x01R\x7FMS40NC00Ljg0OC0xLjE3NmMtMS42NTYsa%\xC0\x86\x01R\x7FMC4yNC0zLjIxNiwxLjEwNC00LjI0OCwya%\xE0\x86\x01R\x7FLjU0NGwtMC4xOTIsMC4yNA0KCQkJCQkJa&\0\x86\x01R\x7FbC05Ljg4OCwxMy40MTZ2MC4wMjRjLTEua& \x86\x01R\x7FMDU2LDEuNDE2LTEuNDE2LDMuMTY4LTEua&@\x86\x01R\x7FMTUyLDQuODI0YzAuMjY0LDEuNjgsMS4xa&`\x86\x01R\x7FMjgsMy4yNCwyLjU0NCw0LjI3MmwwLDANa&\x80\x86\x01R\x7FCgkJCQkJCWMxLjQxNiwxLjA1NiwzLjE2a&\xA0\x86\x01R\x7FOCwxLjQxNiw0Ljg0OCwxLjE1MmMxLjY4a&\xC0\x86\x01R\x7FLTAuMjY0LDMuMjQtMS4xMjgsNC4yNzIta&\xE0\x86\x01R\x7FMi41NDRMMjIyLjE0MSwzMjcNCgkJCQkJa'\0\x86\x01R\x7FCUMyMjMuMTI0LDMyNS41ODQsMjIzLjUwa' \x86\x01R\x7FOCwzMjMuODMyLDIyMy4yNDQsMzIyLjE1a'@\x86\x01R\x7FMnoiLz4NCgkJCQk8L2c+DQoJCQk8L2c+a'`\x86\x01R\x7FDQoJCTwvZz4NCgk8L2c+DQo8L2c+DQo8a'\x80\x86\x01Rm\x13\x0C\xD3\x8C\x96\x9E\x8D\x13\x90\xD9\xCFOH\x8B`\x92\x1Ba'\xA0\x86\x01RQ\x97Q\x97\x98\x89\x98\x92\x95\x92\x91\x82\x91\x90\x8A\x01^\x87\x01\x90` \x82\x01\x90_\x82RQ\x92\x83\x91^\x01` \x01\x90_\x82RQ\x80\x92\x82^\x01\x90_\x82RQ\x80\x92\x82^\x01_\x81R\x03`\x1F\x19\x81\x01\x82Ra6F\x90\x82a7\x93V[`@Qa6T\x81\x92\x82a7iV[\x03\x90\xF3[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[a6xa\x01\x1C\x91a8\xA1V[\x92a\x01\rV[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[4a6~W` 6`\x03\x19\x01\x12a6~Wa6T` a6\xF8`%a6\xC5`\x045`\x01`\x01`\xA0\x1B\x03\x16a84V[`@Qd\xF0\x9F\xA4\x9D-`\xD8\x1B\x85\x82\x01R\x81Q\x90\x94\x85\x92\x82\x91\x01\x84\x84\x01^\x81\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a7\x93V[`@Q\x91\x82\x91\x82a7iV[4a6~W` 6`\x03\x19\x01\x12a6~Wa6T` a6\xF8`(a73`\x045`\x01`\x01`\xA0\x1B\x03\x16a7\xB5V[`@Q\x93\x84\x91g\x02\x1B{k\x83\x0B\x1B\xA1`\xC5\x1B\x82\x84\x01R\x80Q\x91\x82\x91\x01\x84\x84\x01^\x81\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a7\x93V[` `@\x92\x81\x83R\x80Q\x91\x82\x91\x82\x82\x86\x01R\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a6\x82W`@RV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a8\x10Wa7\xD9\x90c\x06\xFD\xDE\x03`\x04R`\x04_Ra=BV[\x90\x81Q\x15a7\xE3WV[\x90P`@Qa7\xF3`@\x82a7\x93V[`\r\x81Rl:\xB75\xB77\xBB\xB7\x10:7\xB5\xB2\xB7`\x99\x1B` \x82\x01R\x90V[P`@Qa8\x1F`@\x82a7\x93V[`\x05\x81Rd\"\xBA42\xB9`\xD9\x1B` \x82\x01R\x90V[\x80``\x1B\x15a8\x7FWa8R\x90c\x95\xD8\x9BA`\x04R`\x04_Ra=BV[\x90\x81Q\x15a8\\WV[\x90P`@Qa8l`@\x82a7\x93V[`\x03\x81Rb???`\xE8\x1B` \x82\x01R\x90V[P`@Qa8\x8E`@\x82a7\x93V[`\x03\x81Rb\x08\xAA\x89`\xEB\x1B` \x82\x01R\x90V[\x90`@Q\x91`\x80\x83\x01`@Ro0123456789abcdef`\x0FR`\x02\x83\x01\x90`(\x82R_`J\x85\x01R``\x1B`\x01_[\x80\x80\x01\x86\x01`\"\x84\x83\x1A`\x0F\x81\x16Q`#\x84\x01S`\x04\x1CQ\x91\x01S\x01\x90`\x14\x82\x14a9\x05W\x90`\x01\x90a8\xD7V[PPa0x`\x02\x82Q\x01\x91R\x82R\x81`\"\x81\x01\x90\x7F\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x80`(\x83 \x16`\x01_[`\x11`\xF3\x1B\x83\x82\x1A\x02\x81\x80\x01R\x01\x90`\x14\x82\x14a9cW\x90`\x01\x90a9CV[PP`B\x91\x80Q\x7F                                \x81_Q\x16`\x01\x1C\x16\x18\x90R\x01\x80Q\x7F                                \x81` Q\x16`\x01\x1C\x16\x18\x90RV[`\x08\x81\x10\x15a6XW\x80a9\xFFWP`@Qa9\xE5`@\x82a7\x93V[`\n\x81Ri\x13\xDB\x99H\x1C\xD9X\xDB\xDB\x99`\xB2\x1B` \x82\x01R\x90V[`\x01\x81\x03a:5WP`@Qa:\x16`@\x82a7\x93V[`\x0F\x81RnFifteen seconds`\x88\x1B` \x82\x01R\x90V[`\x02\x81\x03a:fWP`@Qa:L`@\x82a7\x93V[`\n\x81RiOne minute`\xB0\x1B` \x82\x01R\x90V[`\x03\x81\x03a:\x98WP`@Qa:}`@\x82a7\x93V[`\x0B\x81RjTen minutes`\xA8\x1B` \x82\x01R\x90V[`\x04\x81\x03a:\xDCWP`@Qa:\xAF`@\x82a7\x93V[`\x19\x81R\x7FOne hour and five minutes\0\0\0\0\0\0\0` \x82\x01R\x90V[`\x05\x81\x03a;\nWP`@Qa:\xF3`@\x82a7\x93V[`\x07\x81RfOne day`\xC8\x1B` \x82\x01R\x90V[`\x06\x81\x03a;NWP`@Qa;!`@\x82a7\x93V[`\x17\x81R\x7FSeven days and one hour\0\0\0\0\0\0\0\0\0` \x82\x01R\x90V[`\x07\x03a;~W`@Qa;c`@\x82a7\x93V[`\x0B\x81RjThirty days`\xA8\x1B` \x82\x01R\x90V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01Rs\x15[\x9A\xDB\x9B\xDD\xDB\x88\x1C\x99\\\xD9]\x08\x1C\x19\\\x9A[\xD9`b\x1B`D\x82\x01R`d\x90\xFD[`\x02\x81\x10\x15a6XW\x80a;\xF1WP`@Qa;\xD7`@\x82a7\x93V[`\n\x81Ri&\xBA\xB6:4\xB1\xB40\xB4\xB7`\xB1\x1B` \x82\x01R\x90V[`\x01\x03a<$W`@Qa<\x06`@\x82a7\x93V[`\x0E\x81RmChain-specific`\x90\x1B` \x82\x01R\x90V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01RlUnknown scope`\x98\x1B`D\x82\x01R`d\x90\xFD[\x90`@Q`\n`\x80\x82\x01\x93`\xA0\x83\x01`@R_\x85R\x93[_\x19\x01\x93`0\x82\x82\x06\x01\x85S\x04\x92\x83\x15a<\x8CW`\n\x90a<pV[\x80\x93P`\x80\x91\x03\x01\x91`\x1F\x19\x01\x91\x82RV[`\x02a=?\x91`\r` \x94`@Qa<\xB7`@\x82a7\x93V[`\x01\x81R`0\x87\x80\x83\x01\x93`\x0B`\xFA\x1B\x85R`@Q\x99\x8A\x97o=\x91:90\xB4\xBA/\xBA<\xB82\x91\x1D\x10\x11`\x81\x1B\x82\x8A\x01R\x80Q\x91\x82\x91\x01\x85\x8A\x01^\x87\x01\x90l\x11\x16\x10\x11;0\xB6:\xB2\x91\x1D\x10\x11`\x99\x1B\x84\x83\x01R\x80Q\x92\x83\x91\x01`=\x83\x01^\x01\x01\x90a\"}`\xF0\x1B\x84\x83\x01RQ\x80\x92`\x0F\x83\x01^\x01\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a7\x93V[\x90V[` _``\x92\x82\x82Q\x91b\x01\x86\xA0\xFA\x15a=?WP`@Q\x80` \x01`@=\x10\x15a=\xA7W[_` =\x80a\x03\xE8\x10a\x03\xE8\x82\x18\x02\x18\x80\x83\x85>\x84\x01\x01S[\x80Q_\x1A\x15a=\x92W`\x01\x01a=\x81V[\x81\x81\x03`\x1F\x19\x01\x82R_\x81R` \x01`@R\x90V[_Q=`\x1F\x19\x01\x81\x11\x15a=\xBCW[Pa=hV[` \x81\x84>\x82Q=\x82\x90\x03`\x1F\x19\x01\x81\x11\x15a=\xD8WPa=\xB6V[\x90`@\x92\x82` \x93a\x03\xE8\x10a\x03\xE8\x82\x18\x02\x18\x92\x83\x92\x83\x87R\x01\x90>\x82\x01_` \x82\x01R\x01`@R\x90V\xFE\xA1dsolcC\0\x08\x1C\0\n",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610011575f80fd5b5f3560e01c806303417d721461162e57806306659b7f1461161957806306e8cc181461160457806308e600ee146115ef5780630a133cf2146115da5780630d57fec9146115c55780630f5eeadf146115b0578063107d4ee41461156957806312a1e6ea1461155457806312f9d21e1461153f57806313589bfe1461152a578063138cd8191461150457806314865907146114ef578063176f405a1461148e5780631b98b63f146114795780631bb81a81146114645780631d474b141461144f578063206620a1146113fc57806325d7776b146113d25780632737edb9146113bb5780632acd5dc3146113a65780632c4bbd171461138f5780632e4d55cc1461137a57806332e2a80314611365578063341056c5146113505780633f458a1914611339578063409b3a7e14611324578063414fd9141461130f578063418a23f5146112fa57806344b97d78146112c75780634ad5205e146112b05780634c102416146112995780634d585fbf146112825780634e55a5481461126b578063548439e114611254578063577cdc641461123d57806359202128146112265780635ac2ccf11461120f5780635d76a382146111fa5780635e6c91ff146111e557806362a420bb146111ae57806363f5b1ad1461117157806364870556146111335780636af2791b1461111e57806371f5012714611107578063721f6292146110cc5780637423eb3c14610ff857806376d531d414610fe3578063843719f014610f935780638678555914610f7e57806388d247c414610f6757806388da84d414610f5057806389ce066114610efb578063935ed2ba14610eb75780639730f4fd14610ea0578063996d3aac14610e755780639be5f53714610e5e578063a4c7bd9314610e24578063aa41c87e14610dd7578063b20abc4814610dc2578063b24849b714610d98578063b324438914610d62578063b4039fc214610d35578063b54baefd14610d00578063b602ae0214610cc2578063b7ace04714610c91578063b8a5bbad14610c53578063bc95bd7a14610bff578063c4d195e814610bb8578063ca6cc39f14610b6b578063d204f11e14610b1a578063d2a1805f14610af9578063d34ddc8214610ae2578063d350188c14610acd578063d3917f3c14610a7f578063d921f36a14610a38578063db04bc7214610a23578063e0565c49146109d5578063e05c6e7d14610988578063e6c5b65414610949578063e8672f9314610934578063ea14532e146108cd578063eaa6748314610896578063eb1960081461085c578063eb43182114610820578063ebcbd7b5146107c9578063eea77a7814610754578063eed634ad1461073f578063eed93572146106f4578063f23d923d14610686578063f2f0def114610641578063f44a3452146105e3578063f745381c146105ad578063f95d3d1614610573578063fa1c550014610511578063fb75fb69146104ab5763fcfe431a14610444575f80fd5b346104a757602061049d6017603461045b36611779565b61018061047c61047661047083850185611900565b90611bfe565b83612c2a565b9290919361048e610160820135611935565b92610497611a34565b95611dc6565b6040519015158152f35b5f80fd5b346104a757602061049d60336104c036611675565b6104e26104da6104d4610100840184611b04565b90611efd565b82602f612723565b906101006104f236158484612287565b9161050060013615176119ba565b92610509611a34565b94602161316f565b346104a757602061049d6033610526366116a9565b610537610470610100830183611900565b906105453615928383611ff3565b91610100610562600261055b60e0860135611935565b93176119ba565b9261056b611a34565b94602661316f565b346104a757602061049d603461058836611641565b610120610599604036151783612be9565b929193906105a5611a34565b94602461316f565b346104a757602061049d601760336105c436611711565b6105cd81612601565b906101006105d9611a34565b93361592806121e3565b346104a757602061049d60346105f836611675565b61061361060b61047060e0840184611900565b82602a612723565b9060e061062236158484612287565b9161063060013615176119ba565b92610639611a34565b94601f61316f565b346104a757602061049d6017603461065836611745565b61067161066b6104d460e0840184611b04565b8261291a565b9060e061067c611a34565b93361592806120e9565b346104a757602061049d603461069b36611641565b36156101006106cb6106c360408417859060e0910160c08101355f52013560205260405f2090565b84602f612723565b926106e360026106dc858785612287565b94176119ba565b926106ec611a34565b94602361316f565b346104a757602061049d603461070936611641565b61072361071d610470610140840184611900565b82612baa565b9091610140610736610120830135611935565b9161056b611a34565b346104a757602061049d603361070936611641565b346104a757602061049d603461076936611779565b36159061079761078f60808417839060e0910160c08101355f52013560205260405f2090565b826031612723565b916101406107a6828585612287565b926107ba60026106dc610120840135611935565b936107c3611a34565b95611b39565b346104a757602061049d60336107de366117ad565b61018061080561047660c0361517849060e0910160c08101355f52013560205260405f2090565b92909193610817610160820135611935565b926107c3611a34565b346104a757602061049d6033610835366116a9565b61012061085061084a6104d483850185611b04565b83612bca565b92919390610509611a34565b346104a757602061049d603461087136611711565b61010061087d8261265c565b91909261088d60023615176119ba565b926105a5611a34565b346104a757602061049d60336108ab36611745565b6108be61060b6104d460e0840184611b04565b9060e06104f236158484612287565b346104a757602061049d601760336108e436611711565b6108f861078f6104d4610140840184611b04565b9061090536158383612287565b90610140610917610120830135611935565b9161092560023615176119ba565b9361092e611a34565b956120e9565b346104a757602061049d603361058836611641565b346104a757602061049d603361095e366116a9565b61096781611fd3565b90361560c0610978600283176119ba565b92610981611a34565b9480611b39565b346104a757602061049d603461099d36611711565b6109a681612197565b906109b460e0820135611935565b6101006109c460023615176119ba565b926109cd611a34565b94602561316f565b346104a757602061049d60336109ea36611641565b6101003615610a18610a1260408317859060e0910160c08101355f52013560205260405f2090565b84612b86565b929093610981611a34565b346104a757602061049d60336105f836611675565b346104a757602061049d60176034610a4f366116dd565b610180610a646104766104d483850185611b04565b92909193610a76610160820135611935565b9261092e611a34565b346104a757602061049d6034610a9436611779565b610140610ac1610abb6080361517849060e0910160c08101355f52013560205260405f2090565b83612bf9565b929193906106ec611a34565b346104a757602061049d603361087136611711565b346104a757602061049d6017603361065836611745565b346104a757602061049d6034610b0e366116dd565b61014061059982612684565b346104a757602061049d60176033610b3136611815565b610b4a610b446104d460a0840184611b04565b826126e1565b90361560a0610b5b600183176119ba565b92610b64611a34565b94806120e9565b346104a757602061049d6034610b8036611641565b610b8981612197565b90610b9760e0820135611935565b610100610ba760023615176119ba565b92610bb0611a34565b94602261316f565b346104a757602061049d60176034610bcf366116a9565b610be9610be3610470610100840184611900565b82612b86565b90610100610bf5611a34565b9336159280611dc6565b346104a757602061049d60176034610c1636611745565b610c2661047060c0830183611900565b90610c343615928383611f59565b9160c0610c43600283176119ba565b92610c4c611a34565b9480611dc6565b346104a757602061049d60176033610c6a36611745565b610c7381612231565b90361560a0610c81826119ba565b92610c8a611a34565b94806121e3565b346104a757602061049d60176033610ca836611675565b610cb181611fd3565b90361560c0610c81600283176119ba565b346104a757602061049d6034610cd736611675565b610ce081612231565b3615610ceb816119ba565b91610cf4611a34565b9360a083179180611b39565b346104a757602061049d60176033610d1736611675565b610d2a61066b61047060e0840184611900565b9060e0610bf5611a34565b346104a757602061049d6033610d4a366116a9565b60e0610d55826125b4565b91909261088d36156119ba565b346104a757602061049d6033610d7736611641565b610140610d8c610abb61047083850185611900565b92919390610639611a34565b346104a757602061049d6033610dad36611711565b610120610d8c61084a61047083850185611900565b346104a757602061049d6034610dad36611711565b346104a757602061049d6033610dec36611711565b610e0061071d6104d4610140840184611b04565b9091610140610e13610120830135611935565b91610e1c611a34565b94602761316f565b346104a757602061049d6033610e39366116dd565b610e42816125d2565b9091610140610e55610120830135611935565b916109cd611a34565b346104a757602061049d60176033610c1636611745565b346104a757602061049d60176033610e8c366116a9565b610e958161285a565b9060e06105d9611a34565b346104a757602061049d60176033610bcf366116a9565b346104a757602061049d60176033610ece36611848565b610ede6104d460c0830183611b04565b90610eec3615928383611f59565b9160c0610b5b600283176119ba565b346104a757602061049d6034610f1036611779565b610f3461071d6080361517839060e0910160c08101355f52013560205260405f2090565b9091610140610f47610120830135611935565b91610bb0611a34565b346104a757602061049d601760346108e436611711565b346104a757602061049d60176034610ece36611848565b346104a757602061049d6033610cd736611675565b346104a757602061049d60176034610faa366116dd565b610fb38161262c565b9091610140610fc6610120830135611935565b91610fd460023615176119ba565b93610fdd611a34565b956121e3565b346104a757602061049d603461095e366116a9565b346104a7575f3660031901126104a7573233036110bd577f000000000000000000000000000000000000000000000000000000000000000080156110b2575b6110a3575f8080807f0000000000000000000000000000000000000000000000000000000000000000600a5a04fa3d1561109e576110743d6118aa565b5f60203d92013e5b1561108f575f805460ff19166001179055005b6370a4078f60e01b5f5260045ffd5b61107c565b630f45b98b60e41b5f5260045ffd5b5060ff5f5416611037565b63096650c560e21b5f5260045ffd5b346104a757602061049d601760346110e336611848565b6110f6610b4461047060a0840184611900565b90361560a0610c43600183176119ba565b346104a757602061049d60176034610c6a36611745565b346104a757602061049d603361076936611779565b346104a757602061049d6017603461114a366117e1565b610180611156826126b6565b92909193611168610160820135611935565b92610fdd611a34565b346104a757602061049d603361118636611711565b361560e061119960408317846028612723565b926106e36111a8848684612287565b936119ba565b346104a757602061049d601760346111c536611675565b6111d9610be36104d4610100840184611b04565b9061010061067c611a34565b346104a757602061049d6033610f1036611779565b346104a757602061049d6034610dec36611711565b346104a757602061049d6017603361045b36611779565b346104a757602061049d601760336110e336611848565b346104a757602061049d601760336111c536611675565b346104a757602061049d60176034610b3136611815565b346104a757602061049d60176034610d1736611675565b346104a757602061049d6017603361114a366117e1565b346104a757602061049d60176033610faa366116dd565b346104a757602061049d60176034610e8c366116a9565b346104a757602061049d60336112dc36611711565b6112e58161285a565b9060e06112f0611a34565b9336159280611b39565b346104a757602061049d60346107de366117ad565b346104a757602061049d6033610b0e366116dd565b346104a757602061049d603361099d36611711565b346104a757602061049d601760346105c436611711565b346104a757602061049d6034610e39366116dd565b346104a757602061049d6033610b8036611641565b346104a757602061049d60346112dc36611711565b346104a757602061049d60176033610a4f366116dd565b346104a757602061049d6034610526366116a9565b346104a757602061049d60176034610ca836611675565b346104a757602061049d60346113e736611711565b610140610850610abb6104d483850185611b04565b346104a757602061049d603461141136611675565b6114226104d4610100830183611b04565b906114303615928383611ff3565b91610100611446600261055b60e0860135611935565b92610e1c611a34565b346104a757602061049d6033610a9436611779565b346104a757602061049d603461118636611711565b346104a757602061049d60346109ea36611641565b346104a757602061049d601760336114a536611641565b6114b961078f610470610140840184611900565b906114c636158383612287565b906101406114d8610120830135611935565b916114e660023615176119ba565b93610497611a34565b346104a757602061049d6034610d7736611641565b346104a757602061049d6034611519366116dd565b610120610ac1604036151783612be9565b346104a757602061049d60346108ab36611745565b346104a757602061049d603361069b36611641565b346104a757602061049d60336113e736611711565b346104a757602061049d603361157e366116a9565b6115926104da610470610100840184611900565b906101006115a236158484612287565b9161063060023615176119ba565b346104a757602061049d603461157e366116a9565b346104a757602061049d6033611519366116dd565b346104a757602061049d60346104c036611675565b346104a757602061049d6034610835366116a9565b346104a757602061049d6034610d4a366116a9565b346104a757602061049d603361141136611675565b346104a757602061049d601760346114a5365b60206003198201126104a757600435906001600160401b0382116104a7576101809082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101209082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101409082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101a09082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101609082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101009082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101c09082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576102009082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a7576101e09082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a75760c09082900360031901126104a75760040190565b60206003198201126104a757600435906001600160401b0382116104a75760e09082900360031901126104a75760040190565b6001600160401b03811161189657601f01601f191660200190565b634e487b7160e01b5f52604160045260245ffd5b906118b48261187b565b6040519290601f01601f191683016001600160401b03811184821017611896576040528252565b602460106020939284936014526370a0823160601b5f525afa601f3d11166020510290565b903590601e19813603018212156104a757018035906001600160401b0382116104a7576020019160608202360383136104a757565b60a090604051907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208301527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d604083015260608201523060808201522090565b90604051917fcdca950b17b5efc016b74b912d8527dfba5e404a688cbc3dab16cb943287fec25f527f5a7fee8000a237929ef9be08f2933c4b4f320b00b38809f3c7aa104d5421049f6020527f5ca9a66b8bbf0d2316e90dfa3df465f0790b277b25393a3ef4d67e1f5086505760405260051b5191604052565b7f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000004618611a7f5790565b5060a06040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208201527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d60408201524660608201523060808201522090565b903590601e19813603018212156104a757018035906001600160401b0382116104a757602001918160051b360383136104a757565b9391959094979692860195863595602088013597606081013598611b5d89876121c3565b898110611b9c575091611b99999a9391611b939593604060018060a01b03910135169760016001605c1b038a60a01c1690611c6e565b90612c51565b90565b8990633078b2f65f526020526040526044601cfd5b90611bbb826118aa565b91611bc8601f199161187b565b01366020840137565b9015611bda5790565b634e487b7160e01b5f52603260045260245ffd5b9190811015611bda576060020190565b8160061b82810460401483151715611c5a57611c1990611bb1565b915f5b818110611c30575050506020815191012090565b80611c3e6001928486611bee565b604060208360061b880192803582850152013591015201611c1c565b634e487b7160e01b5f52601160045260245ffd5b939196959694909483358401916020850135850190813560018060a01b036040880135169a6080606089013598013542811115611db657506744036fc77deaed23605c1b8a1754998a15611da65750604051928a6020526303f37b1a600c52886040526037602820600181549a60ff161b8a8116611d9557611d1e9a179055836040528781150201928215158885141517918215611d68575b5050611d52575b50505085823592602001916122b6565b5f52339060018060a01b0316837f770c32a2314b700d6239ee35ba23a9690f2fceb93a55d8c753e953059b3b18d460205fa4565b611d60926020018b896122b6565b5f8080611d0e565b9091508c60148301526368a30dd0825289603483015260548201526058601c429201205411155f80611d07565b63dbc205b160601b600c526044601cfd5b63cf90c3a85f526020526024601cfd5b63f80dbaea5f526020526024601cfd5b98979380959196611e0b939894890198893581019860208a81019a359b013597611e03611df38d8d611bd1565b3560a01c60016001605c1b031690565b9d8e9161316f565b90611e168686611bd1565b95611e3f6020611e33878a35809b60408101359485910135612406565b83151798868686612c51565b506bffffffffffffffffffffffff60019916985b818110611e715750505050505050611e6c919250612417565b600190565b611e7c818389611bee565b80359889918860408201359b8c926020013592611e9893612406565b8c8360a01c60016001605c1b03161415171798611eb791878787612c51565b50600101611e53565b9015611bda57803590605e19813603018212156104a7570190565b9190811015611bda5760051b81013590605e19813603018212156104a7570190565b8160061b82810460401483151715611c5a57611f1890611bb1565b915f5b818110611f2f575050506020815191012090565b80611f3d6001928486611edb565b604060208360061b880192803582850152013591015201611f1b565b60a092916040606092815194848601525f51602061326f5f395f51905f5285528560208601933385524684880152608087208752820101358101803560051b80916020018537602001852060808601527f5ca9a66b8bbf0d2316e90dfa3df465f0790b277b25393a3ef4d67e1f5086505785520190372090565b611b999060c08101355f5260e081013560205260405f2090361590611f59565b6040519260608401525f51602061326f5f395f51905f5283526020830191338352466040850152608084209082019060a082013583019060c0823560051b93013560051b5f905f5b85811061208557505050505091604060609260a09594602001852060808601527f5ca9a66b8bbf0d2316e90dfa3df465f0790b277b25393a3ef4d67e1f5086505785520190372090565b80890160208483018701013581528282146120a4575b5060200161203b565b602090810185905292508261209b565b903590601e19813603018212156104a757018035906001600160401b0382116104a757602001918160061b360383136104a757565b94919584919796612116948101358101988960200199359a61210e611df38d8d611ec0565b98899161316f565b8515956bffffffffffffffffffffffff5f9416935b8181106121425750505050505050611e6c90612417565b8061219087612154600194868c611edb565b80359b8c8a60016001605c1b0361216b8c8461242a565b9260a01c16141517179b87602061218560408501856120b4565b919094013593612454565b500161212b565b611b999036156121bd60408217839060e0910160c08101355f52013560205260405f2090565b91611ff3565b8160ff1c15901517156121d35750565b63a06356f55f526020526024601cfd5b9584906122129399949692968a01998a3597889660408d013583019a60016001605c1b038960a01c169161316f565b95612223602092611b9998946121c3565b013592803590602001612454565b60e09060c0604051916060604036158301927fcdca950b17b5efc016b74b912d8527dfba5e404a688cbc3dab16cb943287fec2865233602087015201604085013760a081013560a0840152013560c08201522090565b60a0916040519382019160c0830135019081359384930135855260208501526020016040840137604001902090565b604080516119015f9081526020979097529181526042601e20918152919390929091606483019083146001600160a01b0386166041851481612311575b505050505050503314171561230457565b638baa579f5f526004601cfd5b909192939495975060405192885f526123b6575b612377575b60209495965f60605282604052630b135d3f60e11b83526004830152602482019586946040865281604485015260648401375afa9051630b135d3f60e11b1416905f8080808080806122f3565b60408401355f1a60205260408481376020600160805f825afa5181183d151761232a575094505050506001915f6060526040525f8080808080806122f3565b60208581013560ff81901c601b01825286356040526001600160ff1b0316606052600160805f825afa5182183d151761232557505094505050506001915f6060526040525f8080808080806122f3565b92612411919261242a565b91101790565b61241d57565b633a03d3bb5f526004601cfd5b60ff1c6002811015612440576001149015151690565b634e487b7160e01b5f52602160045260245ffd5b91959094935f93928492909187155b888510156124ad576020600686901b850190810135888101988910909217979590356001600160a01b03811681036104a757600192886124a4928e8d612c51565b50019395612463565b95975095509650505050828210176124c6575050600190565b633078b2f65f526020526040526044601cfd5b906040519160c08101350191823580937f4d756c7469636861696e436f6d7061637428616464726573732073706f6e736f83527f722c75696e74323536206e6f6e63652c75696e7432353620657870697265732c60208401527f5365676d656e745b5d207365676d656e7473295365676d656e7428616464726560408401527535365b325d5b5d20696473416e64416d6f756e74732c60768401527f737320617262697465722c75696e7432353620636861696e49642c75696e74326060840152602001609683013782604301605382012092609601902090565b90611b996125c86040361517846028612723565b9283361591612287565b6125fd906125f76080361517829060e0910160c08101355f52013560205260405f2090565b90612baa565b9091565b6125fd906126266040361517829060e0910160c08101355f52013560205260405f2090565b90612b86565b90611b996125c86126546080361517859060e0910160c08101355f52013560205260405f2090565b846031612723565b90611b996125c86106c36040361517859060e0910160c08101355f52013560205260405f2090565b6126af906126a96080361517829060e0910160c08101355f52013560205260405f2090565b90612bf9565b9192909190565b6126af906126db60c0361517829060e0910160c08101355f52013560205260405f2090565b90612c2a565b60c091606060408051937f5a7fee8000a237929ef9be08f2933c4b4f320b00b38809f3c7aa104d5421049f855233602086015201604084013760a08201522090565b9190918060311461284a578060301461283d5780602f1461282d5780602a146127e95780602e146127dc57806028146127885760321461277157634e487b7160e01b5f52605160045260245ffd5b60e0910160c08101355f52013560205260405f2090565b5060c060e092606060408051948301927fcdca950b17b5efc016b74b912d8527dfba5e404a688cbc3dab16cb943287fec2865233602087015201604085013760a081013560a0840152013560c08201522090565b50611b9991361590611f59565b509060c091606060408051937f5a7fee8000a237929ef9be08f2933c4b4f320b00b38809f3c7aa104d5421049f855233602086015201604084013760a08201522090565b50611b9991604036151790611f59565b50611b9991361590611ff3565b50611b9991604036151790611ff3565b9061010060405160a060c085013585019460608635967f436f6d70616374286164647265737320617262697465722c6164647265737320855260208501977f73706f6e736f722c75696e74323536206e6f6e63652c75696e7432353620657889528060408701927f70697265732c75696e743235362069642c75696e7432353620616d6f756e742c845260200184880137820185209788865233905260408301903760e0810135828401528381013560c0840152013560e0820152209190565b60e09092919260a06040519160c081013581019560608735977f4261746368436f6d70616374286164647265737320617262697465722c616464865260208601987f726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e74328a52656f756e74732c60468801528060408801927f353620657870697265732c75696e743235365b325d5b5d20696473416e64416d8452602001606689013760660186209889875233905260408401903782840152013560c0820152209190565b92919280602b14612ac557602914612a0357634e487b7160e01b5f52605160045260245ffd5b6101009060a0604051918360c082013582019660608835987f436f6d70616374286164647265737320617262697465722c6164647265737320875260208701997f73706f6e736f722c75696e74323536206e6f6e63652c75696e743235362065788b528060408901927f70697265732c75696e743235362069642c75696e7432353620616d6f756e742c8452602001848a013782018720998a8852339052604085019037820160e081013584860152013560c0840152013560e0820152209190565b5060e09060a06040519160c081013581019560608735977f4261746368436f6d70616374286164647265737320617262697465722c616464865260208601987f726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e74328a52656f756e74732c60468801528060408801927f353620657870697265732c75696e743235365b325d5b5d20696473416e64416d8452602001606689013760660186209889875233905260408401903782840152013560c0820152209190565b9190612ba690612b95846124d9565b94908591604036151790602c613011565b9190565b9190612ba690612bb9846124d9565b94908591604036151790602d613011565b91612bda612ba69284602b6129dd565b92909384604036151791612287565b91612bda612ba6928460296129dd565b91612ba6604093612c2093612c0d826124d9565b959091863615936080851786602c613011565b9586911791612287565b91612ba6604093612c2093612c3e826124d9565b959091863615936080851786602d613011565b9390929380603414612d1457603314612c7857634e487b7160e01b5f52605160045260245ffd5b67edcaa89a8229394060205282601452835f5260405f208054808311831517612d0757829003905581601452835f5260405f20805490828201918210612cfa5755335f5260205260018060a01b03169060018060a01b03167f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac72885960405fa4600190565b6389560ca15f526004601cfd5b63f4d678b85f526004601cfd5b509190827f000000000000000000000000000000000000000000000000000000000000000080600414612fe55780600314612fd35780600914612fc05780600a14612f8357600814612d7457634e487b7160e01b5f52605160045260245ffd5b612d8668929eee149b4bd21268612231565b805b612f7357507f000000000000000000000000000000000000000000000000000000000000000080600214612f4657600114612dd157634e487b7160e01b5f52605160045260245ffd5b3368929eee149b4bd212685d5b6001600160a01b0385169081612ee95750505f9081808538935af115612edc575b67edcaa89a8229394060205280601452825f5260405f2091825492838211612d0757815f9403905533835260205260018060a01b03167f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859604083a47f000000000000000000000000000000000000000000000000000000000000000080600614612eaf57600514612e9e57634e487b7160e01b5f52605160045260245ffd5b5f68929eee149b4bd212685d600190565b505f5460ff1615612ecb575f68929eee149b4bd212685d600190565b5f68929eee149b4bd2126855600190565b63b12d13eb5f526004601cfd5b9091929350612ef830836118db565b9260145260345263a9059cbb60601b5f5260205f6044601082855af13d1560015f5114171615612f3957612f31905f60345230906118db565b900390612dff565b6390b8ec185f526004601cfd5b505f5460ff1615612f62573368929eee149b4bd212685d612dde565b3368929eee149b4bd2126855612dde565b63f57c448b5f526020526024601cfd5b50612fba361560e06040821768929eee149b4bd212680160c08101355f52013560205260405f209068929eee149b4bd21268611ff3565b80612d88565b50612fba68929eee149b4bd21268611fd3565b5068929eee149b4bd212685c80612d88565b505f5460ff16156130015768929eee149b4bd212685c80612d88565b68929eee149b4bd2126854612fba565b9594939190929580602c146130f857602d1461303b57634e487b7160e01b5f52605160045260245ffd5b6040519360608501528584525f51602061326f5f395f51905f5260208501963388524660408701521415806130e9575b60051b60800184209083019060a082013584019060c0823560051b93013560051b5f905f5b8581106130ba57505050505060609260a09596926040926020018620608087015285520190372090565b80890160208483018701013581528282146130d9575b50602001613090565b60209081018590529250826130d0565b60a0840135608086015261306b565b5060609260a095969286604093845197878901528588525f51602061326f5f395f51905f52602089019633885246878b0152141580613161575b60051b60800188208852830101358201803560051b809160200186376020018620608087015285520190372090565b8285013560808a0152613132565b96959493929190968060271461325b5780602414613246578060211461323157806023146132215780601f1461320c57806026146131f957806022146131ee57806025146131db576017146131d257634e487b7160e01b5f52605160045260245ffd5b611b9996611c6e565b50906017959493929187611b99986121e3565b5086611b9997611b39565b50906017959493929187611b9998611dc6565b5091611b999691601796959493361593611dc6565b5090611b99969291361593611b39565b5091611b9996916017969594933615936120e9565b5091611b9996916017969594933615936121e3565b50906017959493929187611b99986120e956fe295feb095767cc67d7e74695da0adaddede54d7b7194a8a5426fe8f0351e0337a164736f6c634300081c000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80c\x03A}r\x14a\x16.W\x80c\x06e\x9B\x7F\x14a\x16\x19W\x80c\x06\xE8\xCC\x18\x14a\x16\x04W\x80c\x08\xE6\0\xEE\x14a\x15\xEFW\x80c\n\x13<\xF2\x14a\x15\xDAW\x80c\rW\xFE\xC9\x14a\x15\xC5W\x80c\x0F^\xEA\xDF\x14a\x15\xB0W\x80c\x10}N\xE4\x14a\x15iW\x80c\x12\xA1\xE6\xEA\x14a\x15TW\x80c\x12\xF9\xD2\x1E\x14a\x15?W\x80c\x13X\x9B\xFE\x14a\x15*W\x80c\x13\x8C\xD8\x19\x14a\x15\x04W\x80c\x14\x86Y\x07\x14a\x14\xEFW\x80c\x17o@Z\x14a\x14\x8EW\x80c\x1B\x98\xB6?\x14a\x14yW\x80c\x1B\xB8\x1A\x81\x14a\x14dW\x80c\x1DGK\x14\x14a\x14OW\x80c f \xA1\x14a\x13\xFCW\x80c%\xD7wk\x14a\x13\xD2W\x80c'7\xED\xB9\x14a\x13\xBBW\x80c*\xCD]\xC3\x14a\x13\xA6W\x80c,K\xBD\x17\x14a\x13\x8FW\x80c.MU\xCC\x14a\x13zW\x80c2\xE2\xA8\x03\x14a\x13eW\x80c4\x10V\xC5\x14a\x13PW\x80c?E\x8A\x19\x14a\x139W\x80c@\x9B:~\x14a\x13$W\x80cAO\xD9\x14\x14a\x13\x0FW\x80cA\x8A#\xF5\x14a\x12\xFAW\x80cD\xB9}x\x14a\x12\xC7W\x80cJ\xD5 ^\x14a\x12\xB0W\x80cL\x10$\x16\x14a\x12\x99W\x80cMX_\xBF\x14a\x12\x82W\x80cNU\xA5H\x14a\x12kW\x80cT\x849\xE1\x14a\x12TW\x80cW|\xDCd\x14a\x12=W\x80cY !(\x14a\x12&W\x80cZ\xC2\xCC\xF1\x14a\x12\x0FW\x80c]v\xA3\x82\x14a\x11\xFAW\x80c^l\x91\xFF\x14a\x11\xE5W\x80cb\xA4 \xBB\x14a\x11\xAEW\x80cc\xF5\xB1\xAD\x14a\x11qW\x80cd\x87\x05V\x14a\x113W\x80cj\xF2y\x1B\x14a\x11\x1EW\x80cq\xF5\x01'\x14a\x11\x07W\x80cr\x1Fb\x92\x14a\x10\xCCW\x80ct#\xEB<\x14a\x0F\xF8W\x80cv\xD51\xD4\x14a\x0F\xE3W\x80c\x847\x19\xF0\x14a\x0F\x93W\x80c\x86xUY\x14a\x0F~W\x80c\x88\xD2G\xC4\x14a\x0FgW\x80c\x88\xDA\x84\xD4\x14a\x0FPW\x80c\x89\xCE\x06a\x14a\x0E\xFBW\x80c\x93^\xD2\xBA\x14a\x0E\xB7W\x80c\x970\xF4\xFD\x14a\x0E\xA0W\x80c\x99m:\xAC\x14a\x0EuW\x80c\x9B\xE5\xF57\x14a\x0E^W\x80c\xA4\xC7\xBD\x93\x14a\x0E$W\x80c\xAAA\xC8~\x14a\r\xD7W\x80c\xB2\n\xBCH\x14a\r\xC2W\x80c\xB2HI\xB7\x14a\r\x98W\x80c\xB3$C\x89\x14a\rbW\x80c\xB4\x03\x9F\xC2\x14a\r5W\x80c\xB5K\xAE\xFD\x14a\r\0W\x80c\xB6\x02\xAE\x02\x14a\x0C\xC2W\x80c\xB7\xAC\xE0G\x14a\x0C\x91W\x80c\xB8\xA5\xBB\xAD\x14a\x0CSW\x80c\xBC\x95\xBDz\x14a\x0B\xFFW\x80c\xC4\xD1\x95\xE8\x14a\x0B\xB8W\x80c\xCAl\xC3\x9F\x14a\x0BkW\x80c\xD2\x04\xF1\x1E\x14a\x0B\x1AW\x80c\xD2\xA1\x80_\x14a\n\xF9W\x80c\xD3M\xDC\x82\x14a\n\xE2W\x80c\xD3P\x18\x8C\x14a\n\xCDW\x80c\xD3\x91\x7F<\x14a\n\x7FW\x80c\xD9!\xF3j\x14a\n8W\x80c\xDB\x04\xBCr\x14a\n#W\x80c\xE0V\\I\x14a\t\xD5W\x80c\xE0\\n}\x14a\t\x88W\x80c\xE6\xC5\xB6T\x14a\tIW\x80c\xE8g/\x93\x14a\t4W\x80c\xEA\x14S.\x14a\x08\xCDW\x80c\xEA\xA6t\x83\x14a\x08\x96W\x80c\xEB\x19`\x08\x14a\x08\\W\x80c\xEBC\x18!\x14a\x08 W\x80c\xEB\xCB\xD7\xB5\x14a\x07\xC9W\x80c\xEE\xA7zx\x14a\x07TW\x80c\xEE\xD64\xAD\x14a\x07?W\x80c\xEE\xD95r\x14a\x06\xF4W\x80c\xF2=\x92=\x14a\x06\x86W\x80c\xF2\xF0\xDE\xF1\x14a\x06AW\x80c\xF4J4R\x14a\x05\xE3W\x80c\xF7E8\x1C\x14a\x05\xADW\x80c\xF9]=\x16\x14a\x05sW\x80c\xFA\x1CU\0\x14a\x05\x11W\x80c\xFBu\xFBi\x14a\x04\xABWc\xFC\xFEC\x1A\x14a\x04DW_\x80\xFD[4a\x04\xA7W` a\x04\x9D`\x17`4a\x04[6a\x17yV[a\x01\x80a\x04|a\x04va\x04p\x83\x85\x01\x85a\x19\0V[\x90a\x1B\xFEV[\x83a,*V[\x92\x90\x91\x93a\x04\x8Ea\x01`\x82\x015a\x195V[\x92a\x04\x97a\x1A4V[\x95a\x1D\xC6V[`@Q\x90\x15\x15\x81R\xF3[_\x80\xFD[4a\x04\xA7W` a\x04\x9D`3a\x04\xC06a\x16uV[a\x04\xE2a\x04\xDAa\x04\xD4a\x01\0\x84\x01\x84a\x1B\x04V[\x90a\x1E\xFDV[\x82`/a'#V[\x90a\x01\0a\x04\xF26\x15\x84\x84a\"\x87V[\x91a\x05\0`\x016\x15\x17a\x19\xBAV[\x92a\x05\ta\x1A4V[\x94`!a1oV[4a\x04\xA7W` a\x04\x9D`3a\x05&6a\x16\xA9V[a\x057a\x04pa\x01\0\x83\x01\x83a\x19\0V[\x90a\x05E6\x15\x92\x83\x83a\x1F\xF3V[\x91a\x01\0a\x05b`\x02a\x05[`\xE0\x86\x015a\x195V[\x93\x17a\x19\xBAV[\x92a\x05ka\x1A4V[\x94`&a1oV[4a\x04\xA7W` a\x04\x9D`4a\x05\x886a\x16AV[a\x01 a\x05\x99`@6\x15\x17\x83a+\xE9V[\x92\x91\x93\x90a\x05\xA5a\x1A4V[\x94`$a1oV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x05\xC46a\x17\x11V[a\x05\xCD\x81a&\x01V[\x90a\x01\0a\x05\xD9a\x1A4V[\x936\x15\x92\x80a!\xE3V[4a\x04\xA7W` a\x04\x9D`4a\x05\xF86a\x16uV[a\x06\x13a\x06\x0Ba\x04p`\xE0\x84\x01\x84a\x19\0V[\x82`*a'#V[\x90`\xE0a\x06\"6\x15\x84\x84a\"\x87V[\x91a\x060`\x016\x15\x17a\x19\xBAV[\x92a\x069a\x1A4V[\x94`\x1Fa1oV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x06X6a\x17EV[a\x06qa\x06ka\x04\xD4`\xE0\x84\x01\x84a\x1B\x04V[\x82a)\x1AV[\x90`\xE0a\x06|a\x1A4V[\x936\x15\x92\x80a \xE9V[4a\x04\xA7W` a\x04\x9D`4a\x06\x9B6a\x16AV[6\x15a\x01\0a\x06\xCBa\x06\xC3`@\x84\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84`/a'#V[\x92a\x06\xE3`\x02a\x06\xDC\x85\x87\x85a\"\x87V[\x94\x17a\x19\xBAV[\x92a\x06\xECa\x1A4V[\x94`#a1oV[4a\x04\xA7W` a\x04\x9D`4a\x07\t6a\x16AV[a\x07#a\x07\x1Da\x04pa\x01@\x84\x01\x84a\x19\0V[\x82a+\xAAV[\x90\x91a\x01@a\x076a\x01 \x83\x015a\x195V[\x91a\x05ka\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x07\t6a\x16AV[4a\x04\xA7W` a\x04\x9D`4a\x07i6a\x17yV[6\x15\x90a\x07\x97a\x07\x8F`\x80\x84\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x82`1a'#V[\x91a\x01@a\x07\xA6\x82\x85\x85a\"\x87V[\x92a\x07\xBA`\x02a\x06\xDCa\x01 \x84\x015a\x195V[\x93a\x07\xC3a\x1A4V[\x95a\x1B9V[4a\x04\xA7W` a\x04\x9D`3a\x07\xDE6a\x17\xADV[a\x01\x80a\x08\x05a\x04v`\xC06\x15\x17\x84\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x92\x90\x91\x93a\x08\x17a\x01`\x82\x015a\x195V[\x92a\x07\xC3a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x0856a\x16\xA9V[a\x01 a\x08Pa\x08Ja\x04\xD4\x83\x85\x01\x85a\x1B\x04V[\x83a+\xCAV[\x92\x91\x93\x90a\x05\ta\x1A4V[4a\x04\xA7W` a\x04\x9D`4a\x08q6a\x17\x11V[a\x01\0a\x08}\x82a&\\V[\x91\x90\x92a\x08\x8D`\x026\x15\x17a\x19\xBAV[\x92a\x05\xA5a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x08\xAB6a\x17EV[a\x08\xBEa\x06\x0Ba\x04\xD4`\xE0\x84\x01\x84a\x1B\x04V[\x90`\xE0a\x04\xF26\x15\x84\x84a\"\x87V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x08\xE46a\x17\x11V[a\x08\xF8a\x07\x8Fa\x04\xD4a\x01@\x84\x01\x84a\x1B\x04V[\x90a\t\x056\x15\x83\x83a\"\x87V[\x90a\x01@a\t\x17a\x01 \x83\x015a\x195V[\x91a\t%`\x026\x15\x17a\x19\xBAV[\x93a\t.a\x1A4V[\x95a \xE9V[4a\x04\xA7W` a\x04\x9D`3a\x05\x886a\x16AV[4a\x04\xA7W` a\x04\x9D`3a\t^6a\x16\xA9V[a\tg\x81a\x1F\xD3V[\x906\x15`\xC0a\tx`\x02\x83\x17a\x19\xBAV[\x92a\t\x81a\x1A4V[\x94\x80a\x1B9V[4a\x04\xA7W` a\x04\x9D`4a\t\x9D6a\x17\x11V[a\t\xA6\x81a!\x97V[\x90a\t\xB4`\xE0\x82\x015a\x195V[a\x01\0a\t\xC4`\x026\x15\x17a\x19\xBAV[\x92a\t\xCDa\x1A4V[\x94`%a1oV[4a\x04\xA7W` a\x04\x9D`3a\t\xEA6a\x16AV[a\x01\x006\x15a\n\x18a\n\x12`@\x83\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84a+\x86V[\x92\x90\x93a\t\x81a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x05\xF86a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`4a\nO6a\x16\xDDV[a\x01\x80a\nda\x04va\x04\xD4\x83\x85\x01\x85a\x1B\x04V[\x92\x90\x91\x93a\nva\x01`\x82\x015a\x195V[\x92a\t.a\x1A4V[4a\x04\xA7W` a\x04\x9D`4a\n\x946a\x17yV[a\x01@a\n\xC1a\n\xBB`\x806\x15\x17\x84\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x83a+\xF9V[\x92\x91\x93\x90a\x06\xECa\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x08q6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x06X6a\x17EV[4a\x04\xA7W` a\x04\x9D`4a\x0B\x0E6a\x16\xDDV[a\x01@a\x05\x99\x82a&\x84V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0B16a\x18\x15V[a\x0BJa\x0BDa\x04\xD4`\xA0\x84\x01\x84a\x1B\x04V[\x82a&\xE1V[\x906\x15`\xA0a\x0B[`\x01\x83\x17a\x19\xBAV[\x92a\x0Bda\x1A4V[\x94\x80a \xE9V[4a\x04\xA7W` a\x04\x9D`4a\x0B\x806a\x16AV[a\x0B\x89\x81a!\x97V[\x90a\x0B\x97`\xE0\x82\x015a\x195V[a\x01\0a\x0B\xA7`\x026\x15\x17a\x19\xBAV[\x92a\x0B\xB0a\x1A4V[\x94`\"a1oV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0B\xCF6a\x16\xA9V[a\x0B\xE9a\x0B\xE3a\x04pa\x01\0\x84\x01\x84a\x19\0V[\x82a+\x86V[\x90a\x01\0a\x0B\xF5a\x1A4V[\x936\x15\x92\x80a\x1D\xC6V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0C\x166a\x17EV[a\x0C&a\x04p`\xC0\x83\x01\x83a\x19\0V[\x90a\x0C46\x15\x92\x83\x83a\x1FYV[\x91`\xC0a\x0CC`\x02\x83\x17a\x19\xBAV[\x92a\x0CLa\x1A4V[\x94\x80a\x1D\xC6V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0Cj6a\x17EV[a\x0Cs\x81a\"1V[\x906\x15`\xA0a\x0C\x81\x82a\x19\xBAV[\x92a\x0C\x8Aa\x1A4V[\x94\x80a!\xE3V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0C\xA86a\x16uV[a\x0C\xB1\x81a\x1F\xD3V[\x906\x15`\xC0a\x0C\x81`\x02\x83\x17a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`4a\x0C\xD76a\x16uV[a\x0C\xE0\x81a\"1V[6\x15a\x0C\xEB\x81a\x19\xBAV[\x91a\x0C\xF4a\x1A4V[\x93`\xA0\x83\x17\x91\x80a\x1B9V[4a\x04\xA7W` a\x04\x9D`\x17`3a\r\x176a\x16uV[a\r*a\x06ka\x04p`\xE0\x84\x01\x84a\x19\0V[\x90`\xE0a\x0B\xF5a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\rJ6a\x16\xA9V[`\xE0a\rU\x82a%\xB4V[\x91\x90\x92a\x08\x8D6\x15a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`3a\rw6a\x16AV[a\x01@a\r\x8Ca\n\xBBa\x04p\x83\x85\x01\x85a\x19\0V[\x92\x91\x93\x90a\x069a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\r\xAD6a\x17\x11V[a\x01 a\r\x8Ca\x08Ja\x04p\x83\x85\x01\x85a\x19\0V[4a\x04\xA7W` a\x04\x9D`4a\r\xAD6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`3a\r\xEC6a\x17\x11V[a\x0E\0a\x07\x1Da\x04\xD4a\x01@\x84\x01\x84a\x1B\x04V[\x90\x91a\x01@a\x0E\x13a\x01 \x83\x015a\x195V[\x91a\x0E\x1Ca\x1A4V[\x94`'a1oV[4a\x04\xA7W` a\x04\x9D`3a\x0E96a\x16\xDDV[a\x0EB\x81a%\xD2V[\x90\x91a\x01@a\x0EUa\x01 \x83\x015a\x195V[\x91a\t\xCDa\x1A4V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0C\x166a\x17EV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0E\x8C6a\x16\xA9V[a\x0E\x95\x81a(ZV[\x90`\xE0a\x05\xD9a\x1A4V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0B\xCF6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0E\xCE6a\x18HV[a\x0E\xDEa\x04\xD4`\xC0\x83\x01\x83a\x1B\x04V[\x90a\x0E\xEC6\x15\x92\x83\x83a\x1FYV[\x91`\xC0a\x0B[`\x02\x83\x17a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`4a\x0F\x106a\x17yV[a\x0F4a\x07\x1D`\x806\x15\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90\x91a\x01@a\x0FGa\x01 \x83\x015a\x195V[\x91a\x0B\xB0a\x1A4V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x08\xE46a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0E\xCE6a\x18HV[4a\x04\xA7W` a\x04\x9D`3a\x0C\xD76a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0F\xAA6a\x16\xDDV[a\x0F\xB3\x81a&,V[\x90\x91a\x01@a\x0F\xC6a\x01 \x83\x015a\x195V[\x91a\x0F\xD4`\x026\x15\x17a\x19\xBAV[\x93a\x0F\xDDa\x1A4V[\x95a!\xE3V[4a\x04\xA7W` a\x04\x9D`4a\t^6a\x16\xA9V[4a\x04\xA7W_6`\x03\x19\x01\x12a\x04\xA7W23\x03a\x10\xBDW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x15a\x10\xB2W[a\x10\xA3W_\x80\x80\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\nZ\x04\xFA=\x15a\x10\x9EWa\x10t=a\x18\xAAV[_` =\x92\x01>[\x15a\x10\x8FW_\x80T`\xFF\x19\x16`\x01\x17\x90U\0[cp\xA4\x07\x8F`\xE0\x1B_R`\x04_\xFD[a\x10|V[c\x0FE\xB9\x8B`\xE4\x1B_R`\x04_\xFD[P`\xFF_T\x16a\x107V[c\tfP\xC5`\xE2\x1B_R`\x04_\xFD[4a\x04\xA7W` a\x04\x9D`\x17`4a\x10\xE36a\x18HV[a\x10\xF6a\x0BDa\x04p`\xA0\x84\x01\x84a\x19\0V[\x906\x15`\xA0a\x0CC`\x01\x83\x17a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0Cj6a\x17EV[4a\x04\xA7W` a\x04\x9D`3a\x07i6a\x17yV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x11J6a\x17\xE1V[a\x01\x80a\x11V\x82a&\xB6V[\x92\x90\x91\x93a\x11ha\x01`\x82\x015a\x195V[\x92a\x0F\xDDa\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x11\x866a\x17\x11V[6\x15`\xE0a\x11\x99`@\x83\x17\x84`(a'#V[\x92a\x06\xE3a\x11\xA8\x84\x86\x84a\"\x87V[\x93a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x11\xC56a\x16uV[a\x11\xD9a\x0B\xE3a\x04\xD4a\x01\0\x84\x01\x84a\x1B\x04V[\x90a\x01\0a\x06|a\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\x0F\x106a\x17yV[4a\x04\xA7W` a\x04\x9D`4a\r\xEC6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x04[6a\x17yV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x10\xE36a\x18HV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x11\xC56a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0B16a\x18\x15V[4a\x04\xA7W` a\x04\x9D`\x17`4a\r\x176a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x11J6a\x17\xE1V[4a\x04\xA7W` a\x04\x9D`\x17`3a\x0F\xAA6a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0E\x8C6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`3a\x12\xDC6a\x17\x11V[a\x12\xE5\x81a(ZV[\x90`\xE0a\x12\xF0a\x1A4V[\x936\x15\x92\x80a\x1B9V[4a\x04\xA7W` a\x04\x9D`4a\x07\xDE6a\x17\xADV[4a\x04\xA7W` a\x04\x9D`3a\x0B\x0E6a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`3a\t\x9D6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x05\xC46a\x17\x11V[4a\x04\xA7W` a\x04\x9D`4a\x0E96a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`3a\x0B\x806a\x16AV[4a\x04\xA7W` a\x04\x9D`4a\x12\xDC6a\x17\x11V[4a\x04\xA7W` a\x04\x9D`\x17`3a\nO6a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`4a\x05&6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`\x17`4a\x0C\xA86a\x16uV[4a\x04\xA7W` a\x04\x9D`4a\x13\xE76a\x17\x11V[a\x01@a\x08Pa\n\xBBa\x04\xD4\x83\x85\x01\x85a\x1B\x04V[4a\x04\xA7W` a\x04\x9D`4a\x14\x116a\x16uV[a\x14\"a\x04\xD4a\x01\0\x83\x01\x83a\x1B\x04V[\x90a\x1406\x15\x92\x83\x83a\x1F\xF3V[\x91a\x01\0a\x14F`\x02a\x05[`\xE0\x86\x015a\x195V[\x92a\x0E\x1Ca\x1A4V[4a\x04\xA7W` a\x04\x9D`3a\n\x946a\x17yV[4a\x04\xA7W` a\x04\x9D`4a\x11\x866a\x17\x11V[4a\x04\xA7W` a\x04\x9D`4a\t\xEA6a\x16AV[4a\x04\xA7W` a\x04\x9D`\x17`3a\x14\xA56a\x16AV[a\x14\xB9a\x07\x8Fa\x04pa\x01@\x84\x01\x84a\x19\0V[\x90a\x14\xC66\x15\x83\x83a\"\x87V[\x90a\x01@a\x14\xD8a\x01 \x83\x015a\x195V[\x91a\x14\xE6`\x026\x15\x17a\x19\xBAV[\x93a\x04\x97a\x1A4V[4a\x04\xA7W` a\x04\x9D`4a\rw6a\x16AV[4a\x04\xA7W` a\x04\x9D`4a\x15\x196a\x16\xDDV[a\x01 a\n\xC1`@6\x15\x17\x83a+\xE9V[4a\x04\xA7W` a\x04\x9D`4a\x08\xAB6a\x17EV[4a\x04\xA7W` a\x04\x9D`3a\x06\x9B6a\x16AV[4a\x04\xA7W` a\x04\x9D`3a\x13\xE76a\x17\x11V[4a\x04\xA7W` a\x04\x9D`3a\x15~6a\x16\xA9V[a\x15\x92a\x04\xDAa\x04pa\x01\0\x84\x01\x84a\x19\0V[\x90a\x01\0a\x15\xA26\x15\x84\x84a\"\x87V[\x91a\x060`\x026\x15\x17a\x19\xBAV[4a\x04\xA7W` a\x04\x9D`4a\x15~6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`3a\x15\x196a\x16\xDDV[4a\x04\xA7W` a\x04\x9D`4a\x04\xC06a\x16uV[4a\x04\xA7W` a\x04\x9D`4a\x0856a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`4a\rJ6a\x16\xA9V[4a\x04\xA7W` a\x04\x9D`3a\x14\x116a\x16uV[4a\x04\xA7W` a\x04\x9D`\x17`4a\x14\xA56[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\x80\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01 \x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01@\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\xA0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01`\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\xC0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x02\0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7Wa\x01\xE0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W`\xC0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x04\xA7W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W`\xE0\x90\x82\x90\x03`\x03\x19\x01\x12a\x04\xA7W`\x04\x01\x90V[`\x01`\x01`@\x1B\x03\x81\x11a\x18\x96W`\x1F\x01`\x1F\x19\x16` \x01\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x18\xB4\x82a\x18{V[`@Q\x92\x90`\x1F\x01`\x1F\x19\x16\x83\x01`\x01`\x01`@\x1B\x03\x81\x11\x84\x82\x10\x17a\x18\x96W`@R\x82RV[`$`\x10` \x93\x92\x84\x93`\x14Rcp\xA0\x821``\x1B_RZ\xFA`\x1F=\x11\x16` Q\x02\x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W` \x01\x91``\x82\x026\x03\x83\x13a\x04\xA7WV[`\xA0\x90`@Q\x90\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x82R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x83\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x83\x01R``\x82\x01R0`\x80\x82\x01R \x90V[\x90`@Q\x91\x7F\xCD\xCA\x95\x0B\x17\xB5\xEF\xC0\x16\xB7K\x91-\x85'\xDF\xBA^@Jh\x8C\xBC=\xAB\x16\xCB\x942\x87\xFE\xC2_R\x7FZ\x7F\xEE\x80\0\xA27\x92\x9E\xF9\xBE\x08\xF2\x93<KO2\x0B\0\xB3\x88\t\xF3\xC7\xAA\x10MT!\x04\x9F` R\x7F\\\xA9\xA6k\x8B\xBF\r#\x16\xE9\r\xFA=\xF4e\xF0y\x0B'{%9:>\xF4\xD6~\x1FP\x86PW`@R`\x05\x1BQ\x91`@RV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\x18a\x1A\x7FW\x90V[P`\xA0`@Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x82\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x82\x01RF``\x82\x01R0`\x80\x82\x01R \x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W` \x01\x91\x81`\x05\x1B6\x03\x83\x13a\x04\xA7WV[\x93\x91\x95\x90\x94\x97\x96\x92\x86\x01\x95\x865\x95` \x88\x015\x97``\x81\x015\x98a\x1B]\x89\x87a!\xC3V[\x89\x81\x10a\x1B\x9CWP\x91a\x1B\x99\x99\x9A\x93\x91a\x1B\x93\x95\x93`@`\x01\x80`\xA0\x1B\x03\x91\x015\x16\x97`\x01`\x01`\\\x1B\x03\x8A`\xA0\x1C\x16\x90a\x1CnV[\x90a,QV[\x90V[\x89\x90c0x\xB2\xF6_R` R`@R`D`\x1C\xFD[\x90a\x1B\xBB\x82a\x18\xAAV[\x91a\x1B\xC8`\x1F\x19\x91a\x18{V[\x016` \x84\x017V[\x90\x15a\x1B\xDAW\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x91\x90\x81\x10\x15a\x1B\xDAW``\x02\x01\x90V[\x81`\x06\x1B\x82\x81\x04`@\x14\x83\x15\x17\x15a\x1CZWa\x1C\x19\x90a\x1B\xB1V[\x91_[\x81\x81\x10a\x1C0WPPP` \x81Q\x91\x01 \x90V[\x80a\x1C>`\x01\x92\x84\x86a\x1B\xEEV[`@` \x83`\x06\x1B\x88\x01\x92\x805\x82\x85\x01R\x015\x91\x01R\x01a\x1C\x1CV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x93\x91\x96\x95\x96\x94\x90\x94\x835\x84\x01\x91` \x85\x015\x85\x01\x90\x815`\x01\x80`\xA0\x1B\x03`@\x88\x015\x16\x9A`\x80``\x89\x015\x98\x015B\x81\x11\x15a\x1D\xB6WPgD\x03o\xC7}\xEA\xED#`\\\x1B\x8A\x17T\x99\x8A\x15a\x1D\xA6WP`@Q\x92\x8A` Rc\x03\xF3{\x1A`\x0CR\x88`@R`7`( `\x01\x81T\x9A`\xFF\x16\x1B\x8A\x81\x16a\x1D\x95Wa\x1D\x1E\x9A\x17\x90U\x83`@R\x87\x81\x15\x02\x01\x92\x82\x15\x15\x88\x85\x14\x15\x17\x91\x82\x15a\x1DhW[PPa\x1DRW[PPP\x85\x825\x92` \x01\x91a\"\xB6V[_R3\x90`\x01\x80`\xA0\x1B\x03\x16\x83\x7Fw\x0C2\xA21Kp\rb9\xEE5\xBA#\xA9i\x0F/\xCE\xB9:U\xD8\xC7S\xE9S\x05\x9B;\x18\xD4` _\xA4V[a\x1D`\x92` \x01\x8B\x89a\"\xB6V[_\x80\x80a\x1D\x0EV[\x90\x91P\x8C`\x14\x83\x01Rch\xA3\r\xD0\x82R\x89`4\x83\x01R`T\x82\x01R`X`\x1CB\x92\x01 T\x11\x15_\x80a\x1D\x07V[c\xDB\xC2\x05\xB1``\x1B`\x0CR`D`\x1C\xFD[c\xCF\x90\xC3\xA8_R` R`$`\x1C\xFD[c\xF8\r\xBA\xEA_R` R`$`\x1C\xFD[\x98\x97\x93\x80\x95\x91\x96a\x1E\x0B\x93\x98\x94\x89\x01\x98\x895\x81\x01\x98` \x8A\x81\x01\x9A5\x9B\x015\x97a\x1E\x03a\x1D\xF3\x8D\x8Da\x1B\xD1V[5`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x90V[\x9D\x8E\x91a1oV[\x90a\x1E\x16\x86\x86a\x1B\xD1V[\x95a\x1E?` a\x1E3\x87\x8A5\x80\x9B`@\x81\x015\x94\x85\x91\x015a$\x06V[\x83\x15\x17\x98\x86\x86\x86a,QV[Pk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01\x99\x16\x98[\x81\x81\x10a\x1EqWPPPPPPPa\x1El\x91\x92Pa$\x17V[`\x01\x90V[a\x1E|\x81\x83\x89a\x1B\xEEV[\x805\x98\x89\x91\x88`@\x82\x015\x9B\x8C\x92` \x015\x92a\x1E\x98\x93a$\x06V[\x8C\x83`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x14\x15\x17\x17\x98a\x1E\xB7\x91\x87\x87\x87a,QV[P`\x01\x01a\x1ESV[\x90\x15a\x1B\xDAW\x805\x90`^\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x90V[\x91\x90\x81\x10\x15a\x1B\xDAW`\x05\x1B\x81\x015\x90`^\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x90V[\x81`\x06\x1B\x82\x81\x04`@\x14\x83\x15\x17\x15a\x1CZWa\x1F\x18\x90a\x1B\xB1V[\x91_[\x81\x81\x10a\x1F/WPPP` \x81Q\x91\x01 \x90V[\x80a\x1F=`\x01\x92\x84\x86a\x1E\xDBV[`@` \x83`\x06\x1B\x88\x01\x92\x805\x82\x85\x01R\x015\x91\x01R\x01a\x1F\x1BV[`\xA0\x92\x91`@``\x92\x81Q\x94\x84\x86\x01R_Q` a2o_9_Q\x90_R\x85R\x85` \x86\x01\x933\x85RF\x84\x88\x01R`\x80\x87 \x87R\x82\x01\x015\x81\x01\x805`\x05\x1B\x80\x91` \x01\x857` \x01\x85 `\x80\x86\x01R\x7F\\\xA9\xA6k\x8B\xBF\r#\x16\xE9\r\xFA=\xF4e\xF0y\x0B'{%9:>\xF4\xD6~\x1FP\x86PW\x85R\x01\x907 \x90V[a\x1B\x99\x90`\xC0\x81\x015_R`\xE0\x81\x015` R`@_ \x906\x15\x90a\x1FYV[`@Q\x92``\x84\x01R_Q` a2o_9_Q\x90_R\x83R` \x83\x01\x913\x83RF`@\x85\x01R`\x80\x84 \x90\x82\x01\x90`\xA0\x82\x015\x83\x01\x90`\xC0\x825`\x05\x1B\x93\x015`\x05\x1B_\x90_[\x85\x81\x10a \x85WPPPPP\x91`@``\x92`\xA0\x95\x94` \x01\x85 `\x80\x86\x01R\x7F\\\xA9\xA6k\x8B\xBF\r#\x16\xE9\r\xFA=\xF4e\xF0y\x0B'{%9:>\xF4\xD6~\x1FP\x86PW\x85R\x01\x907 \x90V[\x80\x89\x01` \x84\x83\x01\x87\x01\x015\x81R\x82\x82\x14a \xA4W[P` \x01a ;V[` \x90\x81\x01\x85\x90R\x92P\x82a \x9BV[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x04\xA7W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x04\xA7W` \x01\x91\x81`\x06\x1B6\x03\x83\x13a\x04\xA7WV[\x94\x91\x95\x84\x91\x97\x96a!\x16\x94\x81\x015\x81\x01\x98\x89` \x01\x995\x9Aa!\x0Ea\x1D\xF3\x8D\x8Da\x1E\xC0V[\x98\x89\x91a1oV[\x85\x15\x95k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_\x94\x16\x93[\x81\x81\x10a!BWPPPPPPPa\x1El\x90a$\x17V[\x80a!\x90\x87a!T`\x01\x94\x86\x8Ca\x1E\xDBV[\x805\x9B\x8C\x8A`\x01`\x01`\\\x1B\x03a!k\x8C\x84a$*V[\x92`\xA0\x1C\x16\x14\x15\x17\x17\x9B\x87` a!\x85`@\x85\x01\x85a \xB4V[\x91\x90\x94\x015\x93a$TV[P\x01a!+V[a\x1B\x99\x906\x15a!\xBD`@\x82\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x91a\x1F\xF3V[\x81`\xFF\x1C\x15\x90\x15\x17\x15a!\xD3WPV[c\xA0cV\xF5_R` R`$`\x1C\xFD[\x95\x84\x90a\"\x12\x93\x99\x94\x96\x92\x96\x8A\x01\x99\x8A5\x97\x88\x96`@\x8D\x015\x83\x01\x9A`\x01`\x01`\\\x1B\x03\x89`\xA0\x1C\x16\x91a1oV[\x95a\"#` \x92a\x1B\x99\x98\x94a!\xC3V[\x015\x92\x805\x90` \x01a$TV[`\xE0\x90`\xC0`@Q\x91```@6\x15\x83\x01\x92\x7F\xCD\xCA\x95\x0B\x17\xB5\xEF\xC0\x16\xB7K\x91-\x85'\xDF\xBA^@Jh\x8C\xBC=\xAB\x16\xCB\x942\x87\xFE\xC2\x86R3` \x87\x01R\x01`@\x85\x017`\xA0\x81\x015`\xA0\x84\x01R\x015`\xC0\x82\x01R \x90V[`\xA0\x91`@Q\x93\x82\x01\x91`\xC0\x83\x015\x01\x90\x815\x93\x84\x93\x015\x85R` \x85\x01R` \x01`@\x84\x017`@\x01\x90 \x90V[`@\x80Qa\x19\x01_\x90\x81R` \x97\x90\x97R\x91\x81R`B`\x1E \x91\x81R\x91\x93\x90\x92\x90\x91`d\x83\x01\x90\x83\x14`\x01`\x01`\xA0\x1B\x03\x86\x16`A\x85\x14\x81a#\x11W[PPPPPPP3\x14\x17\x15a#\x04WV[c\x8B\xAAW\x9F_R`\x04`\x1C\xFD[\x90\x91\x92\x93\x94\x95\x97P`@Q\x92\x88_Ra#\xB6W[a#wW[` \x94\x95\x96_``R\x82`@Rc\x0B\x13]?`\xE1\x1B\x83R`\x04\x83\x01R`$\x82\x01\x95\x86\x94`@\x86R\x81`D\x85\x01R`d\x84\x017Z\xFA\x90Qc\x0B\x13]?`\xE1\x1B\x14\x16\x90_\x80\x80\x80\x80\x80\x80a\"\xF3V[`@\x84\x015_\x1A` R`@\x84\x817` `\x01`\x80_\x82Z\xFAQ\x81\x18=\x15\x17a#*WP\x94PPPP`\x01\x91_``R`@R_\x80\x80\x80\x80\x80\x80a\"\xF3V[` \x85\x81\x015`\xFF\x81\x90\x1C`\x1B\x01\x82R\x865`@R`\x01`\x01`\xFF\x1B\x03\x16``R`\x01`\x80_\x82Z\xFAQ\x82\x18=\x15\x17a#%WPP\x94PPPP`\x01\x91_``R`@R_\x80\x80\x80\x80\x80\x80a\"\xF3V[\x92a$\x11\x91\x92a$*V[\x91\x10\x17\x90V[a$\x1DWV[c:\x03\xD3\xBB_R`\x04`\x1C\xFD[`\xFF\x1C`\x02\x81\x10\x15a$@W`\x01\x14\x90\x15\x15\x16\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x91\x95\x90\x94\x93_\x93\x92\x84\x92\x90\x91\x87\x15[\x88\x85\x10\x15a$\xADW` `\x06\x86\x90\x1B\x85\x01\x90\x81\x015\x88\x81\x01\x98\x89\x10\x90\x92\x17\x97\x95\x905`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x04\xA7W`\x01\x92\x88a$\xA4\x92\x8E\x8Da,QV[P\x01\x93\x95a$cV[\x95\x97P\x95P\x96PPPP\x82\x82\x10\x17a$\xC6WPP`\x01\x90V[c0x\xB2\xF6_R` R`@R`D`\x1C\xFD[\x90`@Q\x91`\xC0\x81\x015\x01\x91\x825\x80\x93\x7FMultichainCompact(address sponso\x83R\x7Fr,uint256 nonce,uint256 expires,` \x84\x01R\x7FSegment[] segments)Segment(addre`@\x84\x01Ru56[2][] idsAndAmounts,`v\x84\x01R\x7Fss arbiter,uint256 chainId,uint2``\x84\x01R` \x01`\x96\x83\x017\x82`C\x01`S\x82\x01 \x92`\x96\x01\x90 \x90V[\x90a\x1B\x99a%\xC8`@6\x15\x17\x84`(a'#V[\x92\x836\x15\x91a\"\x87V[a%\xFD\x90a%\xF7`\x806\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a+\xAAV[\x90\x91V[a%\xFD\x90a&&`@6\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a+\x86V[\x90a\x1B\x99a%\xC8a&T`\x806\x15\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84`1a'#V[\x90a\x1B\x99a%\xC8a\x06\xC3`@6\x15\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[a&\xAF\x90a&\xA9`\x806\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a+\xF9V[\x91\x92\x90\x91\x90V[a&\xAF\x90a&\xDB`\xC06\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a,*V[`\xC0\x91```@\x80Q\x93\x7FZ\x7F\xEE\x80\0\xA27\x92\x9E\xF9\xBE\x08\xF2\x93<KO2\x0B\0\xB3\x88\t\xF3\xC7\xAA\x10MT!\x04\x9F\x85R3` \x86\x01R\x01`@\x84\x017`\xA0\x82\x01R \x90V[\x91\x90\x91\x80`1\x14a(JW\x80`0\x14a(=W\x80`/\x14a(-W\x80`*\x14a'\xE9W\x80`.\x14a'\xDCW\x80`(\x14a'\x88W`2\x14a'qWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[P`\xC0`\xE0\x92```@\x80Q\x94\x83\x01\x92\x7F\xCD\xCA\x95\x0B\x17\xB5\xEF\xC0\x16\xB7K\x91-\x85'\xDF\xBA^@Jh\x8C\xBC=\xAB\x16\xCB\x942\x87\xFE\xC2\x86R3` \x87\x01R\x01`@\x85\x017`\xA0\x81\x015`\xA0\x84\x01R\x015`\xC0\x82\x01R \x90V[Pa\x1B\x99\x916\x15\x90a\x1FYV[P\x90`\xC0\x91```@\x80Q\x93\x7FZ\x7F\xEE\x80\0\xA27\x92\x9E\xF9\xBE\x08\xF2\x93<KO2\x0B\0\xB3\x88\t\xF3\xC7\xAA\x10MT!\x04\x9F\x85R3` \x86\x01R\x01`@\x84\x017`\xA0\x82\x01R \x90V[Pa\x1B\x99\x91`@6\x15\x17\x90a\x1FYV[Pa\x1B\x99\x916\x15\x90a\x1F\xF3V[Pa\x1B\x99\x91`@6\x15\x17\x90a\x1F\xF3V[\x90a\x01\0`@Q`\xA0`\xC0\x85\x015\x85\x01\x94``\x865\x96\x7FCompact(address arbiter,address \x85R` \x85\x01\x97\x7Fsponsor,uint256 nonce,uint256 ex\x89R\x80`@\x87\x01\x92\x7Fpires,uint256 id,uint256 amount,\x84R` \x01\x84\x88\x017\x82\x01\x85 \x97\x88\x86R3\x90R`@\x83\x01\x907`\xE0\x81\x015\x82\x84\x01R\x83\x81\x015`\xC0\x84\x01R\x015`\xE0\x82\x01R \x91\x90V[`\xE0\x90\x92\x91\x92`\xA0`@Q\x91`\xC0\x81\x015\x81\x01\x95``\x875\x97\x7FBatchCompact(address arbiter,add\x86R` \x86\x01\x98\x7Fress sponsor,uint256 nonce,uint2\x8AReounts,`F\x88\x01R\x80`@\x88\x01\x92\x7F56 expires,uint256[2][] idsAndAm\x84R` \x01`f\x89\x017`f\x01\x86 \x98\x89\x87R3\x90R`@\x84\x01\x907\x82\x84\x01R\x015`\xC0\x82\x01R \x91\x90V[\x92\x91\x92\x80`+\x14a*\xC5W`)\x14a*\x03WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a\x01\0\x90`\xA0`@Q\x91\x83`\xC0\x82\x015\x82\x01\x96``\x885\x98\x7FCompact(address arbiter,address \x87R` \x87\x01\x99\x7Fsponsor,uint256 nonce,uint256 ex\x8BR\x80`@\x89\x01\x92\x7Fpires,uint256 id,uint256 amount,\x84R` \x01\x84\x8A\x017\x82\x01\x87 \x99\x8A\x88R3\x90R`@\x85\x01\x907\x82\x01`\xE0\x81\x015\x84\x86\x01R\x015`\xC0\x84\x01R\x015`\xE0\x82\x01R \x91\x90V[P`\xE0\x90`\xA0`@Q\x91`\xC0\x81\x015\x81\x01\x95``\x875\x97\x7FBatchCompact(address arbiter,add\x86R` \x86\x01\x98\x7Fress sponsor,uint256 nonce,uint2\x8AReounts,`F\x88\x01R\x80`@\x88\x01\x92\x7F56 expires,uint256[2][] idsAndAm\x84R` \x01`f\x89\x017`f\x01\x86 \x98\x89\x87R3\x90R`@\x84\x01\x907\x82\x84\x01R\x015`\xC0\x82\x01R \x91\x90V[\x91\x90a+\xA6\x90a+\x95\x84a$\xD9V[\x94\x90\x85\x91`@6\x15\x17\x90`,a0\x11V[\x91\x90V[\x91\x90a+\xA6\x90a+\xB9\x84a$\xD9V[\x94\x90\x85\x91`@6\x15\x17\x90`-a0\x11V[\x91a+\xDAa+\xA6\x92\x84`+a)\xDDV[\x92\x90\x93\x84`@6\x15\x17\x91a\"\x87V[\x91a+\xDAa+\xA6\x92\x84`)a)\xDDV[\x91a+\xA6`@\x93a, \x93a,\r\x82a$\xD9V[\x95\x90\x91\x866\x15\x93`\x80\x85\x17\x86`,a0\x11V[\x95\x86\x91\x17\x91a\"\x87V[\x91a+\xA6`@\x93a, \x93a,>\x82a$\xD9V[\x95\x90\x91\x866\x15\x93`\x80\x85\x17\x86`-a0\x11V[\x93\x90\x92\x93\x80`4\x14a-\x14W`3\x14a,xWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[g\xED\xCA\xA8\x9A\x82)9@` R\x82`\x14R\x83_R`@_ \x80T\x80\x83\x11\x83\x15\x17a-\x07W\x82\x90\x03\x90U\x81`\x14R\x83_R`@_ \x80T\x90\x82\x82\x01\x91\x82\x10a,\xFAWU3_R` R`\x01\x80`\xA0\x1B\x03\x16\x90`\x01\x80`\xA0\x1B\x03\x16\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y`@_\xA4`\x01\x90V[c\x89V\x0C\xA1_R`\x04`\x1C\xFD[c\xF4\xD6x\xB8_R`\x04`\x1C\xFD[P\x91\x90\x82\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x04\x14a/\xE5W\x80`\x03\x14a/\xD3W\x80`\t\x14a/\xC0W\x80`\n\x14a/\x83W`\x08\x14a-tWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a-\x86h\x92\x9E\xEE\x14\x9BK\xD2\x12ha\"1V[\x80[a/sWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x02\x14a/FW`\x01\x14a-\xD1WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[3h\x92\x9E\xEE\x14\x9BK\xD2\x12h][`\x01`\x01`\xA0\x1B\x03\x85\x16\x90\x81a.\xE9WPP_\x90\x81\x80\x858\x93Z\xF1\x15a.\xDCW[g\xED\xCA\xA8\x9A\x82)9@` R\x80`\x14R\x82_R`@_ \x91\x82T\x92\x83\x82\x11a-\x07W\x81_\x94\x03\x90U3\x83R` R`\x01\x80`\xA0\x1B\x03\x16\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y`@\x83\xA4\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x06\x14a.\xAFW`\x05\x14a.\x9EWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[_h\x92\x9E\xEE\x14\x9BK\xD2\x12h]`\x01\x90V[P_T`\xFF\x16\x15a.\xCBW_h\x92\x9E\xEE\x14\x9BK\xD2\x12h]`\x01\x90V[_h\x92\x9E\xEE\x14\x9BK\xD2\x12hU`\x01\x90V[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x90\x91\x92\x93Pa.\xF80\x83a\x18\xDBV[\x92`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10\x82\x85Z\xF1=\x15`\x01_Q\x14\x17\x16\x15a/9Wa/1\x90_`4R0\x90a\x18\xDBV[\x90\x03\x90a-\xFFV[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[P_T`\xFF\x16\x15a/bW3h\x92\x9E\xEE\x14\x9BK\xD2\x12h]a-\xDEV[3h\x92\x9E\xEE\x14\x9BK\xD2\x12hUa-\xDEV[c\xF5|D\x8B_R` R`$`\x1C\xFD[Pa/\xBA6\x15`\xE0`@\x82\x17h\x92\x9E\xEE\x14\x9BK\xD2\x12h\x01`\xC0\x81\x015_R\x015` R`@_ \x90h\x92\x9E\xEE\x14\x9BK\xD2\x12ha\x1F\xF3V[\x80a-\x88V[Pa/\xBAh\x92\x9E\xEE\x14\x9BK\xD2\x12ha\x1F\xD3V[Ph\x92\x9E\xEE\x14\x9BK\xD2\x12h\\\x80a-\x88V[P_T`\xFF\x16\x15a0\x01Wh\x92\x9E\xEE\x14\x9BK\xD2\x12h\\\x80a-\x88V[h\x92\x9E\xEE\x14\x9BK\xD2\x12hTa/\xBAV[\x95\x94\x93\x91\x90\x92\x95\x80`,\x14a0\xF8W`-\x14a0;WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[`@Q\x93``\x85\x01R\x85\x84R_Q` a2o_9_Q\x90_R` \x85\x01\x963\x88RF`@\x87\x01R\x14\x15\x80a0\xE9W[`\x05\x1B`\x80\x01\x84 \x90\x83\x01\x90`\xA0\x82\x015\x84\x01\x90`\xC0\x825`\x05\x1B\x93\x015`\x05\x1B_\x90_[\x85\x81\x10a0\xBAWPPPPP``\x92`\xA0\x95\x96\x92`@\x92` \x01\x86 `\x80\x87\x01R\x85R\x01\x907 \x90V[\x80\x89\x01` \x84\x83\x01\x87\x01\x015\x81R\x82\x82\x14a0\xD9W[P` \x01a0\x90V[` \x90\x81\x01\x85\x90R\x92P\x82a0\xD0V[`\xA0\x84\x015`\x80\x86\x01Ra0kV[P``\x92`\xA0\x95\x96\x92\x86`@\x93\x84Q\x97\x87\x89\x01R\x85\x88R_Q` a2o_9_Q\x90_R` \x89\x01\x963\x88RF\x87\x8B\x01R\x14\x15\x80a1aW[`\x05\x1B`\x80\x01\x88 \x88R\x83\x01\x015\x82\x01\x805`\x05\x1B\x80\x91` \x01\x867` \x01\x86 `\x80\x87\x01R\x85R\x01\x907 \x90V[\x82\x85\x015`\x80\x8A\x01Ra12V[\x96\x95\x94\x93\x92\x91\x90\x96\x80`'\x14a2[W\x80`$\x14a2FW\x80`!\x14a21W\x80`#\x14a2!W\x80`\x1F\x14a2\x0CW\x80`&\x14a1\xF9W\x80`\"\x14a1\xEEW\x80`%\x14a1\xDBW`\x17\x14a1\xD2WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a\x1B\x99\x96a\x1CnV[P\x90`\x17\x95\x94\x93\x92\x91\x87a\x1B\x99\x98a!\xE3V[P\x86a\x1B\x99\x97a\x1B9V[P\x90`\x17\x95\x94\x93\x92\x91\x87a\x1B\x99\x98a\x1D\xC6V[P\x91a\x1B\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93a\x1D\xC6V[P\x90a\x1B\x99\x96\x92\x916\x15\x93a\x1B9V[P\x91a\x1B\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93a \xE9V[P\x91a\x1B\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93a!\xE3V[P\x90`\x17\x95\x94\x93\x92\x91\x87a\x1B\x99\x98a \xE9V\xFE)_\xEB\tWg\xCCg\xD7\xE7F\x95\xDA\n\xDA\xDD\xED\xE5M{q\x94\xA8\xA5Bo\xE8\xF05\x1E\x037\xA1dsolcC\0\x08\x1C\0\n",
    );
    /**```solidity
struct BasicClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BasicClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BasicClaim> for UnderlyingRustTuple<'_> {
            fn from(value: BasicClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BasicClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    id: tuple.5,
                    allocatedAmount: tuple.6,
                    claimant: tuple.7,
                    amount: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BasicClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BasicClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BasicClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BasicClaim {
            const NAME: &'static str = "BasicClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BasicClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BasicClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchClaim> for UnderlyingRustTuple<'_> {
            fn from(value: BatchClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    claims: tuple.5,
                    claimant: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchClaim {
            const NAME: &'static str = "BatchClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchClaimComponent { uint256 id; uint256 allocatedAmount; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchClaimComponent {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchClaimComponent> for UnderlyingRustTuple<'_> {
            fn from(value: BatchClaimComponent) -> Self {
                (value.id, value.allocatedAmount, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchClaimComponent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    id: tuple.0,
                    allocatedAmount: tuple.1,
                    amount: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchClaimComponent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchClaimComponent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchClaimComponent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchClaimComponent {
            const NAME: &'static str = "BatchClaimComponent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchClaimComponent(uint256 id,uint256 allocatedAmount,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchClaimComponent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchClaimWithWitness> for UnderlyingRustTuple<'_> {
            fn from(value: BatchClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    claims: tuple.7,
                    claimant: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchClaimWithWitness {
            const NAME: &'static str = "BatchClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchMultichainClaim> for UnderlyingRustTuple<'_> {
            fn from(value: BatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    claims: tuple.6,
                    claimant: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchMultichainClaim {
            const NAME: &'static str = "BatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: BatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for BatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    claims: tuple.8,
                    claimant: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for BatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchMultichainClaimWithWitness {
            const NAME: &'static str = "BatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimWithWitness> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    id: tuple.7,
                    allocatedAmount: tuple.8,
                    claimant: tuple.9,
                    amount: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ClaimWithWitness {
            const NAME: &'static str = "ClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    chainIndex: tuple.6,
                    notarizedChainId: tuple.7,
                    claims: tuple.8,
                    claimant: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousBatchMultichainClaim {
            const NAME: &'static str = "ExogenousBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    claims: tuple.10,
                    claimant: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousBatchMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    chainIndex: tuple.6,
                    notarizedChainId: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimant: tuple.10,
                    amount: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ExogenousMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousMultichainClaim {
            const NAME: &'static str = "ExogenousMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimant: tuple.12,
                    amount: tuple.13,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    claims: tuple.10,
                    claimant: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousQualifiedBatchMultichainClaim {
            const NAME: &'static str = "ExogenousQualifiedBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousQualifiedBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    chainIndex: tuple.10,
                    notarizedChainId: tuple.11,
                    claims: tuple.12,
                    claimant: tuple.13,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousQualifiedBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimant: tuple.12,
                    amount: tuple.13,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousQualifiedMultichainClaim {
            const NAME: &'static str = "ExogenousQualifiedMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousQualifiedMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    chainIndex: tuple.10,
                    notarizedChainId: tuple.11,
                    id: tuple.12,
                    allocatedAmount: tuple.13,
                    claimant: tuple.14,
                    amount: tuple.15,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousQualifiedMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousQualifiedMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedSplitBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedSplitBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedSplitBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedSplitBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedSplitBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    claims: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedSplitBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedSplitBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedSplitBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousQualifiedSplitBatchMultichainClaim {
            const NAME: &'static str = "ExogenousQualifiedSplitBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedSplitBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedSplitBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<
            ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
        > for UnderlyingRustTuple<'_> {
            fn from(
                value: ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            ) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    chainIndex: tuple.10,
                    notarizedChainId: tuple.11,
                    claims: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousQualifiedSplitBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedSplitBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedSplitMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedSplitMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedSplitMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedSplitMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedSplitMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimants: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedSplitMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedSplitMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedSplitMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousQualifiedSplitMultichainClaim {
            const NAME: &'static str = "ExogenousQualifiedSplitMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedSplitMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousQualifiedSplitMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedSplitMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedSplitMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedSplitMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedSplitMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    chainIndex: tuple.10,
                    notarizedChainId: tuple.11,
                    id: tuple.12,
                    allocatedAmount: tuple.13,
                    claimants: tuple.14,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousQualifiedSplitMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedSplitMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousSplitBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousSplitBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousSplitBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousSplitBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousSplitBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    chainIndex: tuple.6,
                    notarizedChainId: tuple.7,
                    claims: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousSplitBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousSplitBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousSplitBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousSplitBatchMultichainClaim {
            const NAME: &'static str = "ExogenousSplitBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousSplitBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousSplitBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousSplitBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousSplitBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousSplitBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousSplitBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousSplitBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    claims: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for ExogenousSplitBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousSplitBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousSplitBatchMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousSplitBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousSplitBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousSplitMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousSplitMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousSplitMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousSplitMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousSplitMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    chainIndex: tuple.6,
                    notarizedChainId: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimants: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousSplitMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousSplitMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousSplitMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousSplitMultichainClaim {
            const NAME: &'static str = "ExogenousSplitMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousSplitMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousSplitMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousSplitMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousSplitMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousSplitMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousSplitMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousSplitMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimants: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousSplitMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousSplitMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousSplitMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousSplitMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousSplitMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousSplitMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousSplitMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct MultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MultichainClaim> for UnderlyingRustTuple<'_> {
            fn from(value: MultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    id: tuple.6,
                    allocatedAmount: tuple.7,
                    claimant: tuple.8,
                    amount: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for MultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for MultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for MultichainClaim {
            const NAME: &'static str = "MultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "MultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct MultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: MultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for MultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimant: tuple.10,
                    amount: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for MultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for MultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for MultichainClaimWithWitness {
            const NAME: &'static str = "MultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "MultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedBatchClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedBatchClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedBatchClaim> for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedBatchClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QualifiedBatchClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    claims: tuple.7,
                    claimant: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedBatchClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedBatchClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedBatchClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedBatchClaim {
            const NAME: &'static str = "QualifiedBatchClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedBatchClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedBatchClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedBatchClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedBatchClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedBatchClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedBatchClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedBatchClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    claims: tuple.9,
                    claimant: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedBatchClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedBatchClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedBatchClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedBatchClaimWithWitness {
            const NAME: &'static str = "QualifiedBatchClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedBatchClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedBatchClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    claims: tuple.8,
                    claimant: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedBatchMultichainClaim {
            const NAME: &'static str = "QualifiedBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    claims: tuple.10,
                    claimant: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedBatchMultichainClaimWithWitness {
            const NAME: &'static str = "QualifiedBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedClaim> for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QualifiedClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    id: tuple.7,
                    allocatedAmount: tuple.8,
                    claimant: tuple.9,
                    amount: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedClaim {
            const NAME: &'static str = "QualifiedClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    id: tuple.9,
                    allocatedAmount: tuple.10,
                    claimant: tuple.11,
                    amount: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedClaimWithWitness {
            const NAME: &'static str = "QualifiedClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimant: tuple.10,
                    amount: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedMultichainClaim {
            const NAME: &'static str = "QualifiedMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimant: tuple.12,
                    amount: tuple.13,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedMultichainClaimWithWitness {
            const NAME: &'static str = "QualifiedMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitBatchClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitBatchClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitBatchClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitBatchClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitBatchClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    claims: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitBatchClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedSplitBatchClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitBatchClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitBatchClaim {
            const NAME: &'static str = "QualifiedSplitBatchClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitBatchClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitBatchClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitBatchClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitBatchClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitBatchClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitBatchClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitBatchClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    claims: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitBatchClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitBatchClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitBatchClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitBatchClaimWithWitness {
            const NAME: &'static str = "QualifiedSplitBatchClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitBatchClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitBatchClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    claims: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitBatchMultichainClaim {
            const NAME: &'static str = "QualifiedSplitBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    claims: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for QualifiedSplitBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for QualifiedSplitBatchMultichainClaimWithWitness {
            const NAME: &'static str = "QualifiedSplitBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for QualifiedSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitClaim> for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QualifiedSplitClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    id: tuple.7,
                    allocatedAmount: tuple.8,
                    claimants: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedSplitClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitClaim {
            const NAME: &'static str = "QualifiedSplitClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    id: tuple.9,
                    allocatedAmount: tuple.10,
                    claimants: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitClaimWithWitness {
            const NAME: &'static str = "QualifiedSplitClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimants: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitMultichainClaim {
            const NAME: &'static str = "QualifiedSplitMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimants: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitMultichainClaimWithWitness {
            const NAME: &'static str = "QualifiedSplitMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchClaim> for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitBatchClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    claims: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitBatchClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchClaim {
            const NAME: &'static str = "SplitBatchClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchClaimComponent { uint256 id; uint256 allocatedAmount; SplitComponent[] portions; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchClaimComponent {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub portions: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchClaimComponent>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchClaimComponent) -> Self {
                (value.id, value.allocatedAmount, value.portions)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitBatchClaimComponent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    id: tuple.0,
                    allocatedAmount: tuple.1,
                    portions: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchClaimComponent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitBatchClaimComponent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.portions),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchClaimComponent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchClaimComponent {
            const NAME: &'static str = "SplitBatchClaimComponent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchClaimComponent(uint256 id,uint256 allocatedAmount,SplitComponent[] portions)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.portions)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchClaimComponent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.portions,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.portions,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitBatchClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    claims: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for SplitBatchClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchClaimWithWitness {
            const NAME: &'static str = "SplitBatchClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    claims: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchMultichainClaim {
            const NAME: &'static str = "SplitBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    claims: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for SplitBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchMultichainClaimWithWitness {
            const NAME: &'static str = "SplitBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitClaim> for UnderlyingRustTuple<'_> {
            fn from(value: SplitClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    id: tuple.5,
                    allocatedAmount: tuple.6,
                    claimants: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitClaim {
            const NAME: &'static str = "SplitClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitClaimWithWitness> for UnderlyingRustTuple<'_> {
            fn from(value: SplitClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    id: tuple.7,
                    allocatedAmount: tuple.8,
                    claimants: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitClaimWithWitness {
            const NAME: &'static str = "SplitClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitComponent { address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitComponent {
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitComponent> for UnderlyingRustTuple<'_> {
            fn from(value: SplitComponent) -> Self {
                (value.claimant, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitComponent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    claimant: tuple.0,
                    amount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitComponent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitComponent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitComponent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitComponent {
            const NAME: &'static str = "SplitComponent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitComponent(address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitComponent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitMultichainClaim> for UnderlyingRustTuple<'_> {
            fn from(value: SplitMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    id: tuple.6,
                    allocatedAmount: tuple.7,
                    claimants: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitMultichainClaim {
            const NAME: &'static str = "SplitMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimants: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for SplitMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitMultichainClaimWithWitness {
            const NAME: &'static str = "SplitMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `OnlyDirectCalls()` and selector `0x25994314`.
```solidity
error OnlyDirectCalls();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OnlyDirectCalls {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OnlyDirectCalls> for UnderlyingRustTuple<'_> {
            fn from(value: OnlyDirectCalls) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OnlyDirectCalls {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OnlyDirectCalls {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OnlyDirectCalls()";
            const SELECTOR: [u8; 4] = [37u8, 153u8, 67u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TStoreAlreadyActivated()` and selector `0xf45b98b0`.
```solidity
error TStoreAlreadyActivated();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TStoreAlreadyActivated {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TStoreAlreadyActivated> for UnderlyingRustTuple<'_> {
            fn from(value: TStoreAlreadyActivated) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TStoreAlreadyActivated {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TStoreAlreadyActivated {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TStoreAlreadyActivated()";
            const SELECTOR: [u8; 4] = [244u8, 91u8, 152u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TStoreNotSupported()` and selector `0x70a4078f`.
```solidity
error TStoreNotSupported();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TStoreNotSupported {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TStoreNotSupported> for UnderlyingRustTuple<'_> {
            fn from(value: TStoreNotSupported) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TStoreNotSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TStoreNotSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TStoreNotSupported()";
            const SELECTOR: [u8; 4] = [112u8, 164u8, 7u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TloadTestContractDeploymentFailed()` and selector `0x2aea5887`.
```solidity
error TloadTestContractDeploymentFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TloadTestContractDeploymentFailed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TloadTestContractDeploymentFailed>
        for UnderlyingRustTuple<'_> {
            fn from(value: TloadTestContractDeploymentFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for TloadTestContractDeploymentFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TloadTestContractDeploymentFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TloadTestContractDeploymentFailed()";
            const SELECTOR: [u8; 4] = [42u8, 234u8, 88u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Function with signature `__activateTstore()` and selector `0x7423eb3c`.
```solidity
function __activateTstore() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct __activateTstoreCall {}
    ///Container type for the return parameters of the [`__activateTstore()`](__activateTstoreCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct __activateTstoreReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<__activateTstoreCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: __activateTstoreCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for __activateTstoreCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<__activateTstoreReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: __activateTstoreReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for __activateTstoreReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for __activateTstoreCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = __activateTstoreReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "__activateTstore()";
            const SELECTOR: [u8; 4] = [116u8, 35u8, 235u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x06659b7f`.
```solidity
function claim(ExogenousSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_0Call {
        pub claimPayload: <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_0Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_0Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_0Call {
            type Parameters<'a> = (ExogenousSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [6u8, 101u8, 155u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))` and selector `0x0d57fec9`.
```solidity
function claim(QualifiedClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_1Call {
        pub claimPayload: <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))`](claim_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_1Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_1Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_1Call {
            type Parameters<'a> = (QualifiedClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [13u8, 87u8, 254u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x107d4ee4`.
```solidity
function claim(QualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_2Call {
        pub claimPayload: <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))`](claim_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_2Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_2Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_2Call {
            type Parameters<'a> = (QualifiedBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [16u8, 125u8, 78u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x12a1e6ea`.
```solidity
function claim(QualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_3Call {
        pub claimPayload: <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claim_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_3Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                QualifiedSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_3Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_3Call {
            type Parameters<'a> = (QualifiedSplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [18u8, 161u8, 230u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))` and selector `0x12f9d21e`.
```solidity
function claim(QualifiedMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_4Call {
        pub claimPayload: <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))`](claim_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_4Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_4Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_4Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_4Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_4Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_4Call {
            type Parameters<'a> = (QualifiedMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [18u8, 249u8, 210u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x176f405a`.
```solidity
function claim(ExogenousQualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_5Call {
        pub claimPayload: <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_5Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_5Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_5Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_5Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_5Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_5Call {
            type Parameters<'a> = (ExogenousQualifiedBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_5Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [23u8, 111u8, 64u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))` and selector `0x1d474b14`.
```solidity
function claim(QualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_6Call {
        pub claimPayload: <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))`](claim_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_6Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_6Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_6Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_6Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_6Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_6Call {
            type Parameters<'a> = (QualifiedMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_6Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [29u8, 71u8, 75u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x2c4bbd17`.
```solidity
function claim(ExogenousQualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_7Call {
        pub claimPayload: <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_7Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_7Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_7Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_7Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_7Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_7Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_7Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_7Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_7Call {
            type Parameters<'a> = (
                ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_7Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [44u8, 75u8, 189u8, 23u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x32e2a803`.
```solidity
function claim(ExogenousMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_8Call {
        pub claimPayload: <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claim_8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_8Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_8Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_8Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_8Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_8Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_8Call {
            type Parameters<'a> = (ExogenousMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_8Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [50u8, 226u8, 168u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x409b3a7e`.
```solidity
function claim(ExogenousSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_9Call {
        pub claimPayload: <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_9Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_9Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_9Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_9Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_9Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_9Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_9Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_9Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_9Call {
            type Parameters<'a> = (ExogenousSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_9Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [64u8, 155u8, 58u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0x414fd914`.
```solidity
function claim(QualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_10Call {
        pub claimPayload: <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))`](claim_10Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_10Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_10Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_10Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_10Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_10Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_10Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_10Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_10Call {
            type Parameters<'a> = (QualifiedSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_10Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [65u8, 79u8, 217u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))` and selector `0x44b97d78`.
```solidity
function claim(ClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_11Call {
        pub claimPayload: <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))`](claim_11Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_11Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_11Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_11Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_11Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_11Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_11Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_11Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_11Call {
            type Parameters<'a> = (ClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_11Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [68u8, 185u8, 125u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x4c102416`.
```solidity
function claim(ExogenousQualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_12Call {
        pub claimPayload: <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_12Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_12Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_12Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_12Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_12Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_12Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_12Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_12Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_12Call {
            type Parameters<'a> = (ExogenousQualifiedSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_12Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [76u8, 16u8, 36u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x4d585fbf`.
```solidity
function claim(ExogenousQualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_13Call {
        pub claimPayload: <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_13Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_13Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedSplitMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_13Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_13Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_13Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_13Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_13Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_13Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_13Call {
            type Parameters<'a> = (ExogenousQualifiedSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_13Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [77u8, 88u8, 95u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x577cdc64`.
```solidity
function claim(SplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_14Call {
        pub claimPayload: <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claim_14Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_14Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_14Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_14Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_14Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_14Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_14Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_14Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_14Call {
            type Parameters<'a> = (SplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_14Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [87u8, 124u8, 220u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x59202128`.
```solidity
function claim(BatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_15Call {
        pub claimPayload: <BatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_15Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_15Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_15Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_15Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_15Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_15Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_15Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_15Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_15Call {
            type Parameters<'a> = (BatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_15Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [89u8, 32u8, 33u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BatchClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x5ac2ccf1`.
```solidity
function claim(ExogenousQualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_16Call {
        pub claimPayload: <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_16Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_16Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_16Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_16Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_16Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_16Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_16Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_16Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_16Call {
            type Parameters<'a> = (ExogenousQualifiedBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_16Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [90u8, 194u8, 204u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x5e6c91ff`.
```solidity
function claim(ExogenousMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_17Call {
        pub claimPayload: <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claim_17Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_17Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_17Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_17Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_17Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_17Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_17Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_17Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_17Call {
            type Parameters<'a> = (ExogenousMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_17Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [94u8, 108u8, 145u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))` and selector `0x63f5b1ad`.
```solidity
function claim(QualifiedClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_18Call {
        pub claimPayload: <QualifiedClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))`](claim_18Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_18Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_18Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_18Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_18Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_18Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_18Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_18Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_18Call {
            type Parameters<'a> = (QualifiedClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_18Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [99u8, 245u8, 177u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x6af2791b`.
```solidity
function claim(ExogenousQualifiedMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_19Call {
        pub claimPayload: <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claim_19Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_19Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_19Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_19Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_19Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_19Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_19Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_19Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_19Call {
            type Parameters<'a> = (ExogenousQualifiedMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_19Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [106u8, 242u8, 121u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))` and selector `0x86785559`.
```solidity
function claim(BasicClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_20Call {
        pub claimPayload: <BasicClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))`](claim_20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_20Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BasicClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BasicClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_20Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_20Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_20Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_20Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_20Call {
            type Parameters<'a> = (BasicClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_20Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [134u8, 120u8, 85u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BasicClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x935ed2ba`.
```solidity
function claim(SplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_21Call {
        pub claimPayload: <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claim_21Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_21Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_21Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_21Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_21Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_21Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_21Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_21Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_21Call {
            type Parameters<'a> = (SplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_21Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [147u8, 94u8, 210u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x9730f4fd`.
```solidity
function claim(BatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_22Call {
        pub claimPayload: <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))`](claim_22Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_22Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_22Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_22Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_22Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_22Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_22Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_22Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_22Call {
            type Parameters<'a> = (BatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_22Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [151u8, 48u8, 244u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))` and selector `0x996d3aac`.
```solidity
function claim(SplitClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_23Call {
        pub claimPayload: <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))`](claim_23Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_23Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_23Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_23Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_23Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_23Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_23Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_23Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_23Call {
            type Parameters<'a> = (SplitClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_23Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [153u8, 109u8, 58u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x9be5f537`.
```solidity
function claim(BatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_24Call {
        pub claimPayload: <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))`](claim_24Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_24Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_24Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_24Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_24Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_24Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_24Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_24Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_24Call {
            type Parameters<'a> = (BatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_24Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [155u8, 229u8, 245u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0xa4c7bd93`.
```solidity
function claim(ExogenousSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_25Call {
        pub claimPayload: <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_25Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_25Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_25Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_25Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_25Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_25Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_25Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_25Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_25Call {
            type Parameters<'a> = (ExogenousSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_25Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [164u8, 199u8, 189u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0xaa41c87e`.
```solidity
function claim(ExogenousSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_26Call {
        pub claimPayload: <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_26Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_26Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_26Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_26Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_26Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_26Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_26Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_26Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_26Call {
            type Parameters<'a> = (ExogenousSplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_26Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [170u8, 65u8, 200u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))` and selector `0xb24849b7`.
```solidity
function claim(QualifiedBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_27Call {
        pub claimPayload: <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))`](claim_27Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_27Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_27Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_27Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_27Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_27Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_27Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_27Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_27Call {
            type Parameters<'a> = (QualifiedBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_27Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [178u8, 72u8, 73u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0xb3244389`.
```solidity
function claim(QualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_28Call {
        pub claimPayload: <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))`](claim_28Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_28Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_28Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_28Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_28Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_28Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_28Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_28Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_28Call {
            type Parameters<'a> = (QualifiedBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_28Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [179u8, 36u8, 67u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))` and selector `0xb4039fc2`.
```solidity
function claim(QualifiedSplitClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_29Call {
        pub claimPayload: <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))`](claim_29Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_29Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_29Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_29Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_29Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_29Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_29Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_29Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_29Call {
            type Parameters<'a> = (QualifiedSplitClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_29Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [180u8, 3u8, 159u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))` and selector `0xb54baefd`.
```solidity
function claim(BatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_30Call {
        pub claimPayload: <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))`](claim_30Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_30Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_30Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_30Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_30Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_30Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_30Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_30Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_30Call {
            type Parameters<'a> = (BatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_30Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [181u8, 75u8, 174u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xb7ace047`.
```solidity
function claim(SplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_31Call {
        pub claimPayload: <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))`](claim_31Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_31Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_31Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_31Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_31Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_31Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_31Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_31Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_31Call {
            type Parameters<'a> = (SplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_31Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [183u8, 172u8, 224u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0xb8a5bbad`.
```solidity
function claim(SplitClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_32Call {
        pub claimPayload: <SplitClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_32Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_32Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_32Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_32Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_32Call {
            type Parameters<'a> = (SplitClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [184u8, 165u8, 187u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<SplitClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0xd204f11e`.
```solidity
function claim(SplitBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_33Call {
        pub claimPayload: <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_33Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_33Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_33Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_33Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_33Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_33Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_33Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_33Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_33Call {
            type Parameters<'a> = (SplitBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_33Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [210u8, 4u8, 241u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))` and selector `0xd34ddc82`.
```solidity
function claim(SplitBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_34Call {
        pub claimPayload: <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))`](claim_34Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_34Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_34Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_34Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_34Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_34Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_34Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_34Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_34Call {
            type Parameters<'a> = (SplitBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_34Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [211u8, 77u8, 220u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xd350188c`.
```solidity
function claim(QualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_35Call {
        pub claimPayload: <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))`](claim_35Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_35Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_35Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_35Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_35Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_35Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_35Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_35Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_35Call {
            type Parameters<'a> = (QualifiedSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_35Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [211u8, 80u8, 24u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))` and selector `0xdb04bc72`.
```solidity
function claim(QualifiedBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_36Call {
        pub claimPayload: <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))`](claim_36Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_36Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_36Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_36Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_36Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_36Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_36Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_36Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_36Call {
            type Parameters<'a> = (QualifiedBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_36Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [219u8, 4u8, 188u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))` and selector `0xe0565c49`.
```solidity
function claim(MultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_37Call {
        pub claimPayload: <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))`](claim_37Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_37Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_37Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_37Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_37Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_37Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_37Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_37Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_37Call {
            type Parameters<'a> = (MultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_37Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [224u8, 86u8, 92u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <MultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))` and selector `0xe6c5b654`.
```solidity
function claim(MultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_38Call {
        pub claimPayload: <MultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))`](claim_38Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_38Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_38Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_38Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_38Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_38Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_38Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_38Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_38Call {
            type Parameters<'a> = (MultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_38Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [230u8, 197u8, 182u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <MultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))` and selector `0xe8672f93`.
```solidity
function claim(QualifiedSplitClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_39Call {
        pub claimPayload: <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))`](claim_39Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_39Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_39Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_39Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_39Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_39Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_39Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_39Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_39Call {
            type Parameters<'a> = (QualifiedSplitClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_39Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [232u8, 103u8, 47u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0xea14532e`.
```solidity
function claim(ExogenousQualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_40Call {
        pub claimPayload: <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_40Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_40Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_40Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_40Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_40Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_40Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_40Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_40Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_40Call {
            type Parameters<'a> = (ExogenousQualifiedSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_40Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [234u8, 20u8, 83u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))` and selector `0xeaa67483`.
```solidity
function claim(QualifiedSplitBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_41Call {
        pub claimPayload: <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))`](claim_41Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_41Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_41Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_41Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_41Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_41Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_41Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_41Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_41Call {
            type Parameters<'a> = (QualifiedSplitBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_41Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [234u8, 166u8, 116u8, 131u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))` and selector `0xeb431821`.
```solidity
function claim(QualifiedSplitBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_42Call {
        pub claimPayload: <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))`](claim_42Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_42Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_42Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_42Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_42Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_42Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_42Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_42Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_42Call {
            type Parameters<'a> = (QualifiedSplitBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_42Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [235u8, 67u8, 24u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0xebcbd7b5`.
```solidity
function claim(ExogenousQualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_43Call {
        pub claimPayload: <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claim_43Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_43Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_43Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_43Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_43Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_43Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_43Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_43Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_43Call {
            type Parameters<'a> = (ExogenousQualifiedMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_43Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [235u8, 203u8, 215u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0xeed634ad`.
```solidity
function claim(ExogenousBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_44Call {
        pub claimPayload: <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_44Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_44Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_44Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_44Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_44Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_44Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_44Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_44Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_44Call {
            type Parameters<'a> = (ExogenousBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_44Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [238u8, 214u8, 52u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xf745381c`.
```solidity
function claim(SplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_45Call {
        pub claimPayload: <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))`](claim_45Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_45Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_45Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_45Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_45Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_45Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_45Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_45Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_45Call {
            type Parameters<'a> = (SplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_45Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [247u8, 69u8, 56u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0xfa1c5500`.
```solidity
function claim(ExogenousBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_46Call {
        pub claimPayload: <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_46Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_46Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_46Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_46Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_46Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_46Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_46Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_46Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_46Call {
            type Parameters<'a> = (ExogenousBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_46Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [250u8, 28u8, 85u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0xfb75fb69`.
```solidity
function claim(QualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_47Call {
        pub claimPayload: <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claim_47Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_47Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_47Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_47Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_47Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_47Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_47Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_47Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_47Call {
            type Parameters<'a> = (QualifiedSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_47Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [251u8, 117u8, 251u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x03417d72`.
```solidity
function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_0Call {
        pub claimPayload: <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_0Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_0Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_0Call {
            type Parameters<'a> = (ExogenousQualifiedBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [3u8, 65u8, 125u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))` and selector `0x06e8cc18`.
```solidity
function claimAndWithdraw(QualifiedSplitClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_1Call {
        pub claimPayload: <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_1Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_1Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_1Call {
            type Parameters<'a> = (QualifiedSplitClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [6u8, 232u8, 204u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))` and selector `0x08e600ee`.
```solidity
function claimAndWithdraw(QualifiedSplitBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_2Call {
        pub claimPayload: <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_2Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_2Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_2Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_2Call {
            type Parameters<'a> = (QualifiedSplitBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [8u8, 230u8, 0u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x0a133cf2`.
```solidity
function claimAndWithdraw(QualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_3Call {
        pub claimPayload: <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_3Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_3Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_3Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_3Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_3Call {
            type Parameters<'a> = (QualifiedSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [10u8, 19u8, 60u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x0f5eeadf`.
```solidity
function claimAndWithdraw(QualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_4Call {
        pub claimPayload: <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))`](claimAndWithdraw_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_4Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_4Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_4Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_4Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_4Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_4Call {
            type Parameters<'a> = (QualifiedBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [15u8, 94u8, 234u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))` and selector `0x13589bfe`.
```solidity
function claimAndWithdraw(QualifiedSplitBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_5Call {
        pub claimPayload: <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_5Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_5Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_5Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_5Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_5Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_5Call {
            type Parameters<'a> = (QualifiedSplitBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_5Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [19u8, 88u8, 155u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))` and selector `0x138cd819`.
```solidity
function claimAndWithdraw(QualifiedClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_6Call {
        pub claimPayload: <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))`](claimAndWithdraw_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_6Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_6Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_6Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_6Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_6Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_6Call {
            type Parameters<'a> = (QualifiedClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_6Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [19u8, 140u8, 216u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x14865907`.
```solidity
function claimAndWithdraw(QualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_7Call {
        pub claimPayload: <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))`](claimAndWithdraw_7Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_7Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_7Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_7Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_7Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_7Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_7Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_7Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_7Call {
            type Parameters<'a> = (QualifiedBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_7Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [20u8, 134u8, 89u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))` and selector `0x1b98b63f`.
```solidity
function claimAndWithdraw(MultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_8Call {
        pub claimPayload: <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))`](claimAndWithdraw_8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_8Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_8Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_8Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_8Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_8Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_8Call {
            type Parameters<'a> = (MultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_8Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [27u8, 152u8, 182u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <MultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))` and selector `0x1bb81a81`.
```solidity
function claimAndWithdraw(QualifiedClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_9Call {
        pub claimPayload: <QualifiedClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))`](claimAndWithdraw_9Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_9Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_9Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_9Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_9Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_9Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_9Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_9Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_9Call {
            type Parameters<'a> = (QualifiedClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_9Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [27u8, 184u8, 26u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x206620a1`.
```solidity
function claimAndWithdraw(ExogenousSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_10Call {
        pub claimPayload: <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_10Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_10Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_10Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_10Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_10Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_10Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_10Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_10Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_10Call {
            type Parameters<'a> = (ExogenousSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_10Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [32u8, 102u8, 32u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x25d7776b`.
```solidity
function claimAndWithdraw(QualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_11Call {
        pub claimPayload: <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_11Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_11Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                QualifiedSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_11Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_11Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_11Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_11Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_11Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_11Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_11Call {
            type Parameters<'a> = (QualifiedSplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_11Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [37u8, 215u8, 119u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0x2737edb9`.
```solidity
function claimAndWithdraw(SplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_12Call {
        pub claimPayload: <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_12Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_12Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_12Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_12Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_12Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_12Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_12Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_12Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_12Call {
            type Parameters<'a> = (SplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_12Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [39u8, 55u8, 237u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x2acd5dc3`.
```solidity
function claimAndWithdraw(ExogenousBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_13Call {
        pub claimPayload: <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_13Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_13Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_13Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_13Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_13Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_13Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_13Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_13Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_13Call {
            type Parameters<'a> = (ExogenousBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_13Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [42u8, 205u8, 93u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))` and selector `0x2e4d55cc`.
```solidity
function claimAndWithdraw(ClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_14Call {
        pub claimPayload: <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))`](claimAndWithdraw_14Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_14Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_14Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_14Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_14Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_14Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_14Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_14Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_14Call {
            type Parameters<'a> = (ClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_14Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [46u8, 77u8, 85u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x341056c5`.
```solidity
function claimAndWithdraw(ExogenousSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_15Call {
        pub claimPayload: <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_15Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_15Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_15Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_15Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_15Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_15Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_15Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_15Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_15Call {
            type Parameters<'a> = (ExogenousSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_15Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [52u8, 16u8, 86u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0x3f458a19`.
```solidity
function claimAndWithdraw(SplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_16Call {
        pub claimPayload: <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_16Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_16Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_16Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_16Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_16Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_16Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_16Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_16Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_16Call {
            type Parameters<'a> = (SplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_16Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [63u8, 69u8, 138u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x418a23f5`.
```solidity
function claimAndWithdraw(ExogenousQualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_17Call {
        pub claimPayload: <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_17Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_17Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_17Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_17Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_17Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_17Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_17Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_17Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_17Call {
            type Parameters<'a> = (ExogenousQualifiedMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_17Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [65u8, 138u8, 35u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))` and selector `0x4ad5205e`.
```solidity
function claimAndWithdraw(SplitClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_18Call {
        pub claimPayload: <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_18Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_18Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_18Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_18Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_18Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_18Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_18Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_18Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_18Call {
            type Parameters<'a> = (SplitClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_18Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [74u8, 213u8, 32u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))` and selector `0x4e55a548`.
```solidity
function claimAndWithdraw(BatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_19Call {
        pub claimPayload: <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_19Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_19Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_19Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_19Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_19Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_19Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_19Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_19Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_19Call {
            type Parameters<'a> = (BatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_19Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [78u8, 85u8, 165u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x548439e1`.
```solidity
function claimAndWithdraw(SplitBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_20Call {
        pub claimPayload: <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_20Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_20Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_20Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_20Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_20Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_20Call {
            type Parameters<'a> = (SplitBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_20Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [84u8, 132u8, 57u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x5d76a382`.
```solidity
function claimAndWithdraw(ExogenousSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_21Call {
        pub claimPayload: <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_21Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_21Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_21Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_21Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_21Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_21Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_21Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_21Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_21Call {
            type Parameters<'a> = (ExogenousSplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_21Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [93u8, 118u8, 163u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x62a420bb`.
```solidity
function claimAndWithdraw(SplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_22Call {
        pub claimPayload: <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_22Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_22Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_22Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_22Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_22Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_22Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_22Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_22Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_22Call {
            type Parameters<'a> = (SplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_22Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [98u8, 164u8, 32u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x64870556`.
```solidity
function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_23Call {
        pub claimPayload: <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_23Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_23Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedSplitMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_23Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_23Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_23Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_23Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_23Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_23Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_23Call {
            type Parameters<'a> = (ExogenousQualifiedSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_23Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [100u8, 135u8, 5u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x71f50127`.
```solidity
function claimAndWithdraw(SplitClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_24Call {
        pub claimPayload: <SplitClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_24Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_24Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_24Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_24Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_24Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_24Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_24Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_24Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_24Call {
            type Parameters<'a> = (SplitClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_24Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [113u8, 245u8, 1u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<SplitClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x721f6292`.
```solidity
function claimAndWithdraw(BatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_25Call {
        pub claimPayload: <BatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_25Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_25Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_25Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_25Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_25Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_25Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_25Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_25Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_25Call {
            type Parameters<'a> = (BatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_25Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [114u8, 31u8, 98u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BatchClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))` and selector `0x76d531d4`.
```solidity
function claimAndWithdraw(MultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_26Call {
        pub claimPayload: <MultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))`](claimAndWithdraw_26Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_26Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_26Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_26Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_26Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_26Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_26Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_26Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_26Call {
            type Parameters<'a> = (MultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_26Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [118u8, 213u8, 49u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <MultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x843719f0`.
```solidity
function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_27Call {
        pub claimPayload: <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_27Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_27Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_27Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_27Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_27Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_27Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_27Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_27Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_27Call {
            type Parameters<'a> = (ExogenousQualifiedSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_27Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [132u8, 55u8, 25u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x88d247c4`.
```solidity
function claimAndWithdraw(SplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_28Call {
        pub claimPayload: <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_28Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_28Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_28Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_28Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_28Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_28Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_28Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_28Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_28Call {
            type Parameters<'a> = (SplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_28Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [136u8, 210u8, 71u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x88da84d4`.
```solidity
function claimAndWithdraw(ExogenousQualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_29Call {
        pub claimPayload: <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_29Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_29Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_29Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_29Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_29Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_29Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_29Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_29Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_29Call {
            type Parameters<'a> = (ExogenousQualifiedSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_29Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [136u8, 218u8, 132u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x89ce0661`.
```solidity
function claimAndWithdraw(ExogenousMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_30Call {
        pub claimPayload: <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_30Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_30Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_30Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_30Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_30Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_30Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_30Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_30Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_30Call {
            type Parameters<'a> = (ExogenousMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_30Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [137u8, 206u8, 6u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))` and selector `0xb20abc48`.
```solidity
function claimAndWithdraw(QualifiedBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_31Call {
        pub claimPayload: <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_31Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_31Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_31Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_31Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_31Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_31Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_31Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_31Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_31Call {
            type Parameters<'a> = (QualifiedBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_31Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [178u8, 10u8, 188u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))` and selector `0xb602ae02`.
```solidity
function claimAndWithdraw(BasicClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_32Call {
        pub claimPayload: <BasicClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_32Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BasicClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BasicClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_32Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_32Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_32Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_32Call {
            type Parameters<'a> = (BasicClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [182u8, 2u8, 174u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BasicClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0xbc95bd7a`.
```solidity
function claimAndWithdraw(BatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_33Call {
        pub claimPayload: <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))`](claimAndWithdraw_33Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_33Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_33Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_33Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_33Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_33Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_33Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_33Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_33Call {
            type Parameters<'a> = (BatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_33Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [188u8, 149u8, 189u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0xc4d195e8`.
```solidity
function claimAndWithdraw(BatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_34Call {
        pub claimPayload: <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))`](claimAndWithdraw_34Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_34Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_34Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_34Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_34Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_34Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_34Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_34Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_34Call {
            type Parameters<'a> = (BatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_34Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [196u8, 209u8, 149u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0xca6cc39f`.
```solidity
function claimAndWithdraw(ExogenousMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_35Call {
        pub claimPayload: <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_35Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_35Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_35Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_35Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_35Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_35Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_35Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_35Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_35Call {
            type Parameters<'a> = (ExogenousMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_35Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [202u8, 108u8, 195u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xd2a1805f`.
```solidity
function claimAndWithdraw(QualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_36Call {
        pub claimPayload: <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_36Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_36Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_36Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_36Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_36Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_36Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_36Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_36Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_36Call {
            type Parameters<'a> = (QualifiedSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_36Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [210u8, 161u8, 128u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))` and selector `0xd3917f3c`.
```solidity
function claimAndWithdraw(QualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_37Call {
        pub claimPayload: <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))`](claimAndWithdraw_37Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_37Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_37Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_37Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_37Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_37Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_37Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_37Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_37Call {
            type Parameters<'a> = (QualifiedMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_37Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [211u8, 145u8, 127u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0xd921f36a`.
```solidity
function claimAndWithdraw(ExogenousQualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_38Call {
        pub claimPayload: <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_38Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_38Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_38Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_38Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_38Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_38Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_38Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_38Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_38Call {
            type Parameters<'a> = (
                ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_38Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [217u8, 33u8, 243u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0xe05c6e7d`.
```solidity
function claimAndWithdraw(ExogenousSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_39Call {
        pub claimPayload: <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_39Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_39Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_39Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_39Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_39Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_39Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_39Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_39Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_39Call {
            type Parameters<'a> = (ExogenousSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_39Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [224u8, 92u8, 110u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xeb196008`.
```solidity
function claimAndWithdraw(QualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_40Call {
        pub claimPayload: <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_40Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_40Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_40Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_40Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_40Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_40Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_40Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_40Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_40Call {
            type Parameters<'a> = (QualifiedSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_40Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [235u8, 25u8, 96u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0xeea77a78`.
```solidity
function claimAndWithdraw(ExogenousQualifiedMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_41Call {
        pub claimPayload: <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_41Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_41Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_41Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_41Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_41Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_41Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_41Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_41Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_41Call {
            type Parameters<'a> = (ExogenousQualifiedMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_41Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [238u8, 167u8, 122u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0xeed93572`.
```solidity
function claimAndWithdraw(ExogenousBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_42Call {
        pub claimPayload: <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_42Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_42Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_42Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_42Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_42Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_42Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_42Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_42Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_42Call {
            type Parameters<'a> = (ExogenousBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_42Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [238u8, 217u8, 53u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))` and selector `0xf23d923d`.
```solidity
function claimAndWithdraw(QualifiedMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_43Call {
        pub claimPayload: <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))`](claimAndWithdraw_43Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_43Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_43Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_43Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_43Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_43Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_43Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_43Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_43Call {
            type Parameters<'a> = (QualifiedMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_43Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [242u8, 61u8, 146u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))` and selector `0xf2f0def1`.
```solidity
function claimAndWithdraw(SplitBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_44Call {
        pub claimPayload: <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_44Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_44Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_44Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_44Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_44Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_44Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_44Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_44Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_44Call {
            type Parameters<'a> = (SplitBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_44Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [242u8, 240u8, 222u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))` and selector `0xf44a3452`.
```solidity
function claimAndWithdraw(QualifiedBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_45Call {
        pub claimPayload: <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_45Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_45Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_45Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_45Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_45Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_45Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_45Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_45Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_45Call {
            type Parameters<'a> = (QualifiedBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_45Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [244u8, 74u8, 52u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))` and selector `0xf95d3d16`.
```solidity
function claimAndWithdraw(QualifiedSplitClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_46Call {
        pub claimPayload: <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_46Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_46Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_46Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_46Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_46Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_46Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_46Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_46Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_46Call {
            type Parameters<'a> = (QualifiedSplitClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_46Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [249u8, 93u8, 61u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0xfcfe431a`.
```solidity
function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_47Call {
        pub claimPayload: <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_47Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_47Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_47Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_47Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_47Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_47Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_47Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_47Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_47Call {
            type Parameters<'a> = (ExogenousQualifiedBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_47Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [252u8, 254u8, 67u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`ClaimProcessor`](self) function calls.
    pub enum ClaimProcessorCalls {
        __activateTstore(__activateTstoreCall),
        claim_0(claim_0Call),
        claim_1(claim_1Call),
        claim_2(claim_2Call),
        claim_3(claim_3Call),
        claim_4(claim_4Call),
        claim_5(claim_5Call),
        claim_6(claim_6Call),
        claim_7(claim_7Call),
        claim_8(claim_8Call),
        claim_9(claim_9Call),
        claim_10(claim_10Call),
        claim_11(claim_11Call),
        claim_12(claim_12Call),
        claim_13(claim_13Call),
        claim_14(claim_14Call),
        claim_15(claim_15Call),
        claim_16(claim_16Call),
        claim_17(claim_17Call),
        claim_18(claim_18Call),
        claim_19(claim_19Call),
        claim_20(claim_20Call),
        claim_21(claim_21Call),
        claim_22(claim_22Call),
        claim_23(claim_23Call),
        claim_24(claim_24Call),
        claim_25(claim_25Call),
        claim_26(claim_26Call),
        claim_27(claim_27Call),
        claim_28(claim_28Call),
        claim_29(claim_29Call),
        claim_30(claim_30Call),
        claim_31(claim_31Call),
        claim_32(claim_32Call),
        claim_33(claim_33Call),
        claim_34(claim_34Call),
        claim_35(claim_35Call),
        claim_36(claim_36Call),
        claim_37(claim_37Call),
        claim_38(claim_38Call),
        claim_39(claim_39Call),
        claim_40(claim_40Call),
        claim_41(claim_41Call),
        claim_42(claim_42Call),
        claim_43(claim_43Call),
        claim_44(claim_44Call),
        claim_45(claim_45Call),
        claim_46(claim_46Call),
        claim_47(claim_47Call),
        claimAndWithdraw_0(claimAndWithdraw_0Call),
        claimAndWithdraw_1(claimAndWithdraw_1Call),
        claimAndWithdraw_2(claimAndWithdraw_2Call),
        claimAndWithdraw_3(claimAndWithdraw_3Call),
        claimAndWithdraw_4(claimAndWithdraw_4Call),
        claimAndWithdraw_5(claimAndWithdraw_5Call),
        claimAndWithdraw_6(claimAndWithdraw_6Call),
        claimAndWithdraw_7(claimAndWithdraw_7Call),
        claimAndWithdraw_8(claimAndWithdraw_8Call),
        claimAndWithdraw_9(claimAndWithdraw_9Call),
        claimAndWithdraw_10(claimAndWithdraw_10Call),
        claimAndWithdraw_11(claimAndWithdraw_11Call),
        claimAndWithdraw_12(claimAndWithdraw_12Call),
        claimAndWithdraw_13(claimAndWithdraw_13Call),
        claimAndWithdraw_14(claimAndWithdraw_14Call),
        claimAndWithdraw_15(claimAndWithdraw_15Call),
        claimAndWithdraw_16(claimAndWithdraw_16Call),
        claimAndWithdraw_17(claimAndWithdraw_17Call),
        claimAndWithdraw_18(claimAndWithdraw_18Call),
        claimAndWithdraw_19(claimAndWithdraw_19Call),
        claimAndWithdraw_20(claimAndWithdraw_20Call),
        claimAndWithdraw_21(claimAndWithdraw_21Call),
        claimAndWithdraw_22(claimAndWithdraw_22Call),
        claimAndWithdraw_23(claimAndWithdraw_23Call),
        claimAndWithdraw_24(claimAndWithdraw_24Call),
        claimAndWithdraw_25(claimAndWithdraw_25Call),
        claimAndWithdraw_26(claimAndWithdraw_26Call),
        claimAndWithdraw_27(claimAndWithdraw_27Call),
        claimAndWithdraw_28(claimAndWithdraw_28Call),
        claimAndWithdraw_29(claimAndWithdraw_29Call),
        claimAndWithdraw_30(claimAndWithdraw_30Call),
        claimAndWithdraw_31(claimAndWithdraw_31Call),
        claimAndWithdraw_32(claimAndWithdraw_32Call),
        claimAndWithdraw_33(claimAndWithdraw_33Call),
        claimAndWithdraw_34(claimAndWithdraw_34Call),
        claimAndWithdraw_35(claimAndWithdraw_35Call),
        claimAndWithdraw_36(claimAndWithdraw_36Call),
        claimAndWithdraw_37(claimAndWithdraw_37Call),
        claimAndWithdraw_38(claimAndWithdraw_38Call),
        claimAndWithdraw_39(claimAndWithdraw_39Call),
        claimAndWithdraw_40(claimAndWithdraw_40Call),
        claimAndWithdraw_41(claimAndWithdraw_41Call),
        claimAndWithdraw_42(claimAndWithdraw_42Call),
        claimAndWithdraw_43(claimAndWithdraw_43Call),
        claimAndWithdraw_44(claimAndWithdraw_44Call),
        claimAndWithdraw_45(claimAndWithdraw_45Call),
        claimAndWithdraw_46(claimAndWithdraw_46Call),
        claimAndWithdraw_47(claimAndWithdraw_47Call),
    }
    #[automatically_derived]
    impl ClaimProcessorCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [3u8, 65u8, 125u8, 114u8],
            [6u8, 101u8, 155u8, 127u8],
            [6u8, 232u8, 204u8, 24u8],
            [8u8, 230u8, 0u8, 238u8],
            [10u8, 19u8, 60u8, 242u8],
            [13u8, 87u8, 254u8, 201u8],
            [15u8, 94u8, 234u8, 223u8],
            [16u8, 125u8, 78u8, 228u8],
            [18u8, 161u8, 230u8, 234u8],
            [18u8, 249u8, 210u8, 30u8],
            [19u8, 88u8, 155u8, 254u8],
            [19u8, 140u8, 216u8, 25u8],
            [20u8, 134u8, 89u8, 7u8],
            [23u8, 111u8, 64u8, 90u8],
            [27u8, 152u8, 182u8, 63u8],
            [27u8, 184u8, 26u8, 129u8],
            [29u8, 71u8, 75u8, 20u8],
            [32u8, 102u8, 32u8, 161u8],
            [37u8, 215u8, 119u8, 107u8],
            [39u8, 55u8, 237u8, 185u8],
            [42u8, 205u8, 93u8, 195u8],
            [44u8, 75u8, 189u8, 23u8],
            [46u8, 77u8, 85u8, 204u8],
            [50u8, 226u8, 168u8, 3u8],
            [52u8, 16u8, 86u8, 197u8],
            [63u8, 69u8, 138u8, 25u8],
            [64u8, 155u8, 58u8, 126u8],
            [65u8, 79u8, 217u8, 20u8],
            [65u8, 138u8, 35u8, 245u8],
            [68u8, 185u8, 125u8, 120u8],
            [74u8, 213u8, 32u8, 94u8],
            [76u8, 16u8, 36u8, 22u8],
            [77u8, 88u8, 95u8, 191u8],
            [78u8, 85u8, 165u8, 72u8],
            [84u8, 132u8, 57u8, 225u8],
            [87u8, 124u8, 220u8, 100u8],
            [89u8, 32u8, 33u8, 40u8],
            [90u8, 194u8, 204u8, 241u8],
            [93u8, 118u8, 163u8, 130u8],
            [94u8, 108u8, 145u8, 255u8],
            [98u8, 164u8, 32u8, 187u8],
            [99u8, 245u8, 177u8, 173u8],
            [100u8, 135u8, 5u8, 86u8],
            [106u8, 242u8, 121u8, 27u8],
            [113u8, 245u8, 1u8, 39u8],
            [114u8, 31u8, 98u8, 146u8],
            [116u8, 35u8, 235u8, 60u8],
            [118u8, 213u8, 49u8, 212u8],
            [132u8, 55u8, 25u8, 240u8],
            [134u8, 120u8, 85u8, 89u8],
            [136u8, 210u8, 71u8, 196u8],
            [136u8, 218u8, 132u8, 212u8],
            [137u8, 206u8, 6u8, 97u8],
            [147u8, 94u8, 210u8, 186u8],
            [151u8, 48u8, 244u8, 253u8],
            [153u8, 109u8, 58u8, 172u8],
            [155u8, 229u8, 245u8, 55u8],
            [164u8, 199u8, 189u8, 147u8],
            [170u8, 65u8, 200u8, 126u8],
            [178u8, 10u8, 188u8, 72u8],
            [178u8, 72u8, 73u8, 183u8],
            [179u8, 36u8, 67u8, 137u8],
            [180u8, 3u8, 159u8, 194u8],
            [181u8, 75u8, 174u8, 253u8],
            [182u8, 2u8, 174u8, 2u8],
            [183u8, 172u8, 224u8, 71u8],
            [184u8, 165u8, 187u8, 173u8],
            [188u8, 149u8, 189u8, 122u8],
            [196u8, 209u8, 149u8, 232u8],
            [202u8, 108u8, 195u8, 159u8],
            [210u8, 4u8, 241u8, 30u8],
            [210u8, 161u8, 128u8, 95u8],
            [211u8, 77u8, 220u8, 130u8],
            [211u8, 80u8, 24u8, 140u8],
            [211u8, 145u8, 127u8, 60u8],
            [217u8, 33u8, 243u8, 106u8],
            [219u8, 4u8, 188u8, 114u8],
            [224u8, 86u8, 92u8, 73u8],
            [224u8, 92u8, 110u8, 125u8],
            [230u8, 197u8, 182u8, 84u8],
            [232u8, 103u8, 47u8, 147u8],
            [234u8, 20u8, 83u8, 46u8],
            [234u8, 166u8, 116u8, 131u8],
            [235u8, 25u8, 96u8, 8u8],
            [235u8, 67u8, 24u8, 33u8],
            [235u8, 203u8, 215u8, 181u8],
            [238u8, 167u8, 122u8, 120u8],
            [238u8, 214u8, 52u8, 173u8],
            [238u8, 217u8, 53u8, 114u8],
            [242u8, 61u8, 146u8, 61u8],
            [242u8, 240u8, 222u8, 241u8],
            [244u8, 74u8, 52u8, 82u8],
            [247u8, 69u8, 56u8, 28u8],
            [249u8, 93u8, 61u8, 22u8],
            [250u8, 28u8, 85u8, 0u8],
            [251u8, 117u8, 251u8, 105u8],
            [252u8, 254u8, 67u8, 26u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ClaimProcessorCalls {
        const NAME: &'static str = "ClaimProcessorCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 97usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::__activateTstore(_) => {
                    <__activateTstoreCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claim_0(_) => <claim_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_1(_) => <claim_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_2(_) => <claim_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_3(_) => <claim_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_4(_) => <claim_4Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_5(_) => <claim_5Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_6(_) => <claim_6Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_7(_) => <claim_7Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_8(_) => <claim_8Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_9(_) => <claim_9Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_10(_) => <claim_10Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_11(_) => <claim_11Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_12(_) => <claim_12Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_13(_) => <claim_13Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_14(_) => <claim_14Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_15(_) => <claim_15Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_16(_) => <claim_16Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_17(_) => <claim_17Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_18(_) => <claim_18Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_19(_) => <claim_19Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_20(_) => <claim_20Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_21(_) => <claim_21Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_22(_) => <claim_22Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_23(_) => <claim_23Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_24(_) => <claim_24Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_25(_) => <claim_25Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_26(_) => <claim_26Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_27(_) => <claim_27Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_28(_) => <claim_28Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_29(_) => <claim_29Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_30(_) => <claim_30Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_31(_) => <claim_31Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_32(_) => <claim_32Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_33(_) => <claim_33Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_34(_) => <claim_34Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_35(_) => <claim_35Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_36(_) => <claim_36Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_37(_) => <claim_37Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_38(_) => <claim_38Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_39(_) => <claim_39Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_40(_) => <claim_40Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_41(_) => <claim_41Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_42(_) => <claim_42Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_43(_) => <claim_43Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_44(_) => <claim_44Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_45(_) => <claim_45Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_46(_) => <claim_46Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_47(_) => <claim_47Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claimAndWithdraw_0(_) => {
                    <claimAndWithdraw_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_1(_) => {
                    <claimAndWithdraw_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_2(_) => {
                    <claimAndWithdraw_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_3(_) => {
                    <claimAndWithdraw_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_4(_) => {
                    <claimAndWithdraw_4Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_5(_) => {
                    <claimAndWithdraw_5Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_6(_) => {
                    <claimAndWithdraw_6Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_7(_) => {
                    <claimAndWithdraw_7Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_8(_) => {
                    <claimAndWithdraw_8Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_9(_) => {
                    <claimAndWithdraw_9Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_10(_) => {
                    <claimAndWithdraw_10Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_11(_) => {
                    <claimAndWithdraw_11Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_12(_) => {
                    <claimAndWithdraw_12Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_13(_) => {
                    <claimAndWithdraw_13Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_14(_) => {
                    <claimAndWithdraw_14Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_15(_) => {
                    <claimAndWithdraw_15Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_16(_) => {
                    <claimAndWithdraw_16Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_17(_) => {
                    <claimAndWithdraw_17Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_18(_) => {
                    <claimAndWithdraw_18Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_19(_) => {
                    <claimAndWithdraw_19Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_20(_) => {
                    <claimAndWithdraw_20Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_21(_) => {
                    <claimAndWithdraw_21Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_22(_) => {
                    <claimAndWithdraw_22Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_23(_) => {
                    <claimAndWithdraw_23Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_24(_) => {
                    <claimAndWithdraw_24Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_25(_) => {
                    <claimAndWithdraw_25Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_26(_) => {
                    <claimAndWithdraw_26Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_27(_) => {
                    <claimAndWithdraw_27Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_28(_) => {
                    <claimAndWithdraw_28Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_29(_) => {
                    <claimAndWithdraw_29Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_30(_) => {
                    <claimAndWithdraw_30Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_31(_) => {
                    <claimAndWithdraw_31Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_32(_) => {
                    <claimAndWithdraw_32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_33(_) => {
                    <claimAndWithdraw_33Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_34(_) => {
                    <claimAndWithdraw_34Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_35(_) => {
                    <claimAndWithdraw_35Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_36(_) => {
                    <claimAndWithdraw_36Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_37(_) => {
                    <claimAndWithdraw_37Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_38(_) => {
                    <claimAndWithdraw_38Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_39(_) => {
                    <claimAndWithdraw_39Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_40(_) => {
                    <claimAndWithdraw_40Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_41(_) => {
                    <claimAndWithdraw_41Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_42(_) => {
                    <claimAndWithdraw_42Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_43(_) => {
                    <claimAndWithdraw_43Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_44(_) => {
                    <claimAndWithdraw_44Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_45(_) => {
                    <claimAndWithdraw_45Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_46(_) => {
                    <claimAndWithdraw_46Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_47(_) => {
                    <claimAndWithdraw_47Call as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ClaimProcessorCalls>] = &[
                {
                    fn claimAndWithdraw_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_0)
                    }
                    claimAndWithdraw_0
                },
                {
                    fn claim_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_0)
                    }
                    claim_0
                },
                {
                    fn claimAndWithdraw_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_1)
                    }
                    claimAndWithdraw_1
                },
                {
                    fn claimAndWithdraw_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_2)
                    }
                    claimAndWithdraw_2
                },
                {
                    fn claimAndWithdraw_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_3)
                    }
                    claimAndWithdraw_3
                },
                {
                    fn claim_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_1)
                    }
                    claim_1
                },
                {
                    fn claimAndWithdraw_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_4)
                    }
                    claimAndWithdraw_4
                },
                {
                    fn claim_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_2)
                    }
                    claim_2
                },
                {
                    fn claim_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_3)
                    }
                    claim_3
                },
                {
                    fn claim_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_4)
                    }
                    claim_4
                },
                {
                    fn claimAndWithdraw_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_5Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_5)
                    }
                    claimAndWithdraw_5
                },
                {
                    fn claimAndWithdraw_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_6Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_6)
                    }
                    claimAndWithdraw_6
                },
                {
                    fn claimAndWithdraw_7(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_7Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_7)
                    }
                    claimAndWithdraw_7
                },
                {
                    fn claim_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_5Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_5)
                    }
                    claim_5
                },
                {
                    fn claimAndWithdraw_8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_8Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_8)
                    }
                    claimAndWithdraw_8
                },
                {
                    fn claimAndWithdraw_9(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_9Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_9)
                    }
                    claimAndWithdraw_9
                },
                {
                    fn claim_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_6Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_6)
                    }
                    claim_6
                },
                {
                    fn claimAndWithdraw_10(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_10Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_10)
                    }
                    claimAndWithdraw_10
                },
                {
                    fn claimAndWithdraw_11(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_11Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_11)
                    }
                    claimAndWithdraw_11
                },
                {
                    fn claimAndWithdraw_12(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_12Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_12)
                    }
                    claimAndWithdraw_12
                },
                {
                    fn claimAndWithdraw_13(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_13Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_13)
                    }
                    claimAndWithdraw_13
                },
                {
                    fn claim_7(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_7Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_7)
                    }
                    claim_7
                },
                {
                    fn claimAndWithdraw_14(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_14Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_14)
                    }
                    claimAndWithdraw_14
                },
                {
                    fn claim_8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_8Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_8)
                    }
                    claim_8
                },
                {
                    fn claimAndWithdraw_15(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_15Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_15)
                    }
                    claimAndWithdraw_15
                },
                {
                    fn claimAndWithdraw_16(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_16Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_16)
                    }
                    claimAndWithdraw_16
                },
                {
                    fn claim_9(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_9Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_9)
                    }
                    claim_9
                },
                {
                    fn claim_10(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_10Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_10)
                    }
                    claim_10
                },
                {
                    fn claimAndWithdraw_17(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_17Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_17)
                    }
                    claimAndWithdraw_17
                },
                {
                    fn claim_11(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_11Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_11)
                    }
                    claim_11
                },
                {
                    fn claimAndWithdraw_18(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_18Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_18)
                    }
                    claimAndWithdraw_18
                },
                {
                    fn claim_12(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_12Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_12)
                    }
                    claim_12
                },
                {
                    fn claim_13(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_13Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_13)
                    }
                    claim_13
                },
                {
                    fn claimAndWithdraw_19(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_19Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_19)
                    }
                    claimAndWithdraw_19
                },
                {
                    fn claimAndWithdraw_20(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_20)
                    }
                    claimAndWithdraw_20
                },
                {
                    fn claim_14(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_14Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_14)
                    }
                    claim_14
                },
                {
                    fn claim_15(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_15Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_15)
                    }
                    claim_15
                },
                {
                    fn claim_16(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_16Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_16)
                    }
                    claim_16
                },
                {
                    fn claimAndWithdraw_21(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_21Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_21)
                    }
                    claimAndWithdraw_21
                },
                {
                    fn claim_17(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_17Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_17)
                    }
                    claim_17
                },
                {
                    fn claimAndWithdraw_22(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_22Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_22)
                    }
                    claimAndWithdraw_22
                },
                {
                    fn claim_18(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_18Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_18)
                    }
                    claim_18
                },
                {
                    fn claimAndWithdraw_23(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_23Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_23)
                    }
                    claimAndWithdraw_23
                },
                {
                    fn claim_19(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_19Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_19)
                    }
                    claim_19
                },
                {
                    fn claimAndWithdraw_24(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_24Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_24)
                    }
                    claimAndWithdraw_24
                },
                {
                    fn claimAndWithdraw_25(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_25Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_25)
                    }
                    claimAndWithdraw_25
                },
                {
                    fn __activateTstore(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <__activateTstoreCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::__activateTstore)
                    }
                    __activateTstore
                },
                {
                    fn claimAndWithdraw_26(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_26Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_26)
                    }
                    claimAndWithdraw_26
                },
                {
                    fn claimAndWithdraw_27(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_27Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_27)
                    }
                    claimAndWithdraw_27
                },
                {
                    fn claim_20(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_20)
                    }
                    claim_20
                },
                {
                    fn claimAndWithdraw_28(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_28Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_28)
                    }
                    claimAndWithdraw_28
                },
                {
                    fn claimAndWithdraw_29(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_29Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_29)
                    }
                    claimAndWithdraw_29
                },
                {
                    fn claimAndWithdraw_30(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_30Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_30)
                    }
                    claimAndWithdraw_30
                },
                {
                    fn claim_21(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_21Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_21)
                    }
                    claim_21
                },
                {
                    fn claim_22(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_22Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_22)
                    }
                    claim_22
                },
                {
                    fn claim_23(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_23Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_23)
                    }
                    claim_23
                },
                {
                    fn claim_24(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_24Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_24)
                    }
                    claim_24
                },
                {
                    fn claim_25(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_25Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_25)
                    }
                    claim_25
                },
                {
                    fn claim_26(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_26Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_26)
                    }
                    claim_26
                },
                {
                    fn claimAndWithdraw_31(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_31Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_31)
                    }
                    claimAndWithdraw_31
                },
                {
                    fn claim_27(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_27Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_27)
                    }
                    claim_27
                },
                {
                    fn claim_28(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_28Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_28)
                    }
                    claim_28
                },
                {
                    fn claim_29(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_29Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_29)
                    }
                    claim_29
                },
                {
                    fn claim_30(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_30Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_30)
                    }
                    claim_30
                },
                {
                    fn claimAndWithdraw_32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_32)
                    }
                    claimAndWithdraw_32
                },
                {
                    fn claim_31(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_31Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_31)
                    }
                    claim_31
                },
                {
                    fn claim_32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_32)
                    }
                    claim_32
                },
                {
                    fn claimAndWithdraw_33(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_33Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_33)
                    }
                    claimAndWithdraw_33
                },
                {
                    fn claimAndWithdraw_34(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_34Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_34)
                    }
                    claimAndWithdraw_34
                },
                {
                    fn claimAndWithdraw_35(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_35Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_35)
                    }
                    claimAndWithdraw_35
                },
                {
                    fn claim_33(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_33Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_33)
                    }
                    claim_33
                },
                {
                    fn claimAndWithdraw_36(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_36Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_36)
                    }
                    claimAndWithdraw_36
                },
                {
                    fn claim_34(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_34Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_34)
                    }
                    claim_34
                },
                {
                    fn claim_35(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_35Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_35)
                    }
                    claim_35
                },
                {
                    fn claimAndWithdraw_37(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_37Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_37)
                    }
                    claimAndWithdraw_37
                },
                {
                    fn claimAndWithdraw_38(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_38Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_38)
                    }
                    claimAndWithdraw_38
                },
                {
                    fn claim_36(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_36Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_36)
                    }
                    claim_36
                },
                {
                    fn claim_37(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_37Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_37)
                    }
                    claim_37
                },
                {
                    fn claimAndWithdraw_39(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_39Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_39)
                    }
                    claimAndWithdraw_39
                },
                {
                    fn claim_38(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_38Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_38)
                    }
                    claim_38
                },
                {
                    fn claim_39(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_39Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_39)
                    }
                    claim_39
                },
                {
                    fn claim_40(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_40Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_40)
                    }
                    claim_40
                },
                {
                    fn claim_41(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_41Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_41)
                    }
                    claim_41
                },
                {
                    fn claimAndWithdraw_40(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_40Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_40)
                    }
                    claimAndWithdraw_40
                },
                {
                    fn claim_42(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_42Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_42)
                    }
                    claim_42
                },
                {
                    fn claim_43(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_43Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_43)
                    }
                    claim_43
                },
                {
                    fn claimAndWithdraw_41(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_41Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_41)
                    }
                    claimAndWithdraw_41
                },
                {
                    fn claim_44(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_44Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_44)
                    }
                    claim_44
                },
                {
                    fn claimAndWithdraw_42(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_42Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_42)
                    }
                    claimAndWithdraw_42
                },
                {
                    fn claimAndWithdraw_43(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_43Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_43)
                    }
                    claimAndWithdraw_43
                },
                {
                    fn claimAndWithdraw_44(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_44Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_44)
                    }
                    claimAndWithdraw_44
                },
                {
                    fn claimAndWithdraw_45(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_45Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_45)
                    }
                    claimAndWithdraw_45
                },
                {
                    fn claim_45(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_45Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_45)
                    }
                    claim_45
                },
                {
                    fn claimAndWithdraw_46(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_46Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_46)
                    }
                    claimAndWithdraw_46
                },
                {
                    fn claim_46(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_46Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_46)
                    }
                    claim_46
                },
                {
                    fn claim_47(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claim_47Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claim_47)
                    }
                    claim_47
                },
                {
                    fn claimAndWithdraw_47(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorCalls> {
                        <claimAndWithdraw_47Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorCalls::claimAndWithdraw_47)
                    }
                    claimAndWithdraw_47
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::__activateTstore(inner) => {
                    <__activateTstoreCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claim_0(inner) => {
                    <claim_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_1(inner) => {
                    <claim_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_2(inner) => {
                    <claim_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_3(inner) => {
                    <claim_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_4(inner) => {
                    <claim_4Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_5(inner) => {
                    <claim_5Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_6(inner) => {
                    <claim_6Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_7(inner) => {
                    <claim_7Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_8(inner) => {
                    <claim_8Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_9(inner) => {
                    <claim_9Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_10(inner) => {
                    <claim_10Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_11(inner) => {
                    <claim_11Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_12(inner) => {
                    <claim_12Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_13(inner) => {
                    <claim_13Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_14(inner) => {
                    <claim_14Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_15(inner) => {
                    <claim_15Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_16(inner) => {
                    <claim_16Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_17(inner) => {
                    <claim_17Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_18(inner) => {
                    <claim_18Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_19(inner) => {
                    <claim_19Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_20(inner) => {
                    <claim_20Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_21(inner) => {
                    <claim_21Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_22(inner) => {
                    <claim_22Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_23(inner) => {
                    <claim_23Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_24(inner) => {
                    <claim_24Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_25(inner) => {
                    <claim_25Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_26(inner) => {
                    <claim_26Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_27(inner) => {
                    <claim_27Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_28(inner) => {
                    <claim_28Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_29(inner) => {
                    <claim_29Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_30(inner) => {
                    <claim_30Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_31(inner) => {
                    <claim_31Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_32(inner) => {
                    <claim_32Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_33(inner) => {
                    <claim_33Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_34(inner) => {
                    <claim_34Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_35(inner) => {
                    <claim_35Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_36(inner) => {
                    <claim_36Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_37(inner) => {
                    <claim_37Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_38(inner) => {
                    <claim_38Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_39(inner) => {
                    <claim_39Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_40(inner) => {
                    <claim_40Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_41(inner) => {
                    <claim_41Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_42(inner) => {
                    <claim_42Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_43(inner) => {
                    <claim_43Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_44(inner) => {
                    <claim_44Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_45(inner) => {
                    <claim_45Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_46(inner) => {
                    <claim_46Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_47(inner) => {
                    <claim_47Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claimAndWithdraw_0(inner) => {
                    <claimAndWithdraw_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_1(inner) => {
                    <claimAndWithdraw_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_2(inner) => {
                    <claimAndWithdraw_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_3(inner) => {
                    <claimAndWithdraw_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_4(inner) => {
                    <claimAndWithdraw_4Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_5(inner) => {
                    <claimAndWithdraw_5Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_6(inner) => {
                    <claimAndWithdraw_6Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_7(inner) => {
                    <claimAndWithdraw_7Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_8(inner) => {
                    <claimAndWithdraw_8Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_9(inner) => {
                    <claimAndWithdraw_9Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_10(inner) => {
                    <claimAndWithdraw_10Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_11(inner) => {
                    <claimAndWithdraw_11Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_12(inner) => {
                    <claimAndWithdraw_12Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_13(inner) => {
                    <claimAndWithdraw_13Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_14(inner) => {
                    <claimAndWithdraw_14Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_15(inner) => {
                    <claimAndWithdraw_15Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_16(inner) => {
                    <claimAndWithdraw_16Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_17(inner) => {
                    <claimAndWithdraw_17Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_18(inner) => {
                    <claimAndWithdraw_18Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_19(inner) => {
                    <claimAndWithdraw_19Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_20(inner) => {
                    <claimAndWithdraw_20Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_21(inner) => {
                    <claimAndWithdraw_21Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_22(inner) => {
                    <claimAndWithdraw_22Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_23(inner) => {
                    <claimAndWithdraw_23Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_24(inner) => {
                    <claimAndWithdraw_24Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_25(inner) => {
                    <claimAndWithdraw_25Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_26(inner) => {
                    <claimAndWithdraw_26Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_27(inner) => {
                    <claimAndWithdraw_27Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_28(inner) => {
                    <claimAndWithdraw_28Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_29(inner) => {
                    <claimAndWithdraw_29Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_30(inner) => {
                    <claimAndWithdraw_30Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_31(inner) => {
                    <claimAndWithdraw_31Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_32(inner) => {
                    <claimAndWithdraw_32Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_33(inner) => {
                    <claimAndWithdraw_33Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_34(inner) => {
                    <claimAndWithdraw_34Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_35(inner) => {
                    <claimAndWithdraw_35Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_36(inner) => {
                    <claimAndWithdraw_36Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_37(inner) => {
                    <claimAndWithdraw_37Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_38(inner) => {
                    <claimAndWithdraw_38Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_39(inner) => {
                    <claimAndWithdraw_39Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_40(inner) => {
                    <claimAndWithdraw_40Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_41(inner) => {
                    <claimAndWithdraw_41Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_42(inner) => {
                    <claimAndWithdraw_42Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_43(inner) => {
                    <claimAndWithdraw_43Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_44(inner) => {
                    <claimAndWithdraw_44Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_45(inner) => {
                    <claimAndWithdraw_45Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_46(inner) => {
                    <claimAndWithdraw_46Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_47(inner) => {
                    <claimAndWithdraw_47Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::__activateTstore(inner) => {
                    <__activateTstoreCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_0(inner) => {
                    <claim_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_1(inner) => {
                    <claim_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_2(inner) => {
                    <claim_2Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_3(inner) => {
                    <claim_3Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_4(inner) => {
                    <claim_4Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_5(inner) => {
                    <claim_5Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_6(inner) => {
                    <claim_6Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_7(inner) => {
                    <claim_7Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_8(inner) => {
                    <claim_8Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_9(inner) => {
                    <claim_9Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_10(inner) => {
                    <claim_10Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_11(inner) => {
                    <claim_11Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_12(inner) => {
                    <claim_12Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_13(inner) => {
                    <claim_13Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_14(inner) => {
                    <claim_14Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_15(inner) => {
                    <claim_15Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_16(inner) => {
                    <claim_16Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_17(inner) => {
                    <claim_17Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_18(inner) => {
                    <claim_18Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_19(inner) => {
                    <claim_19Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_20(inner) => {
                    <claim_20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_21(inner) => {
                    <claim_21Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_22(inner) => {
                    <claim_22Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_23(inner) => {
                    <claim_23Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_24(inner) => {
                    <claim_24Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_25(inner) => {
                    <claim_25Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_26(inner) => {
                    <claim_26Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_27(inner) => {
                    <claim_27Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_28(inner) => {
                    <claim_28Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_29(inner) => {
                    <claim_29Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_30(inner) => {
                    <claim_30Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_31(inner) => {
                    <claim_31Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_32(inner) => {
                    <claim_32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_33(inner) => {
                    <claim_33Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_34(inner) => {
                    <claim_34Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_35(inner) => {
                    <claim_35Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_36(inner) => {
                    <claim_36Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_37(inner) => {
                    <claim_37Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_38(inner) => {
                    <claim_38Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_39(inner) => {
                    <claim_39Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_40(inner) => {
                    <claim_40Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_41(inner) => {
                    <claim_41Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_42(inner) => {
                    <claim_42Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_43(inner) => {
                    <claim_43Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_44(inner) => {
                    <claim_44Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_45(inner) => {
                    <claim_45Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_46(inner) => {
                    <claim_46Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_47(inner) => {
                    <claim_47Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_0(inner) => {
                    <claimAndWithdraw_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_1(inner) => {
                    <claimAndWithdraw_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_2(inner) => {
                    <claimAndWithdraw_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_3(inner) => {
                    <claimAndWithdraw_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_4(inner) => {
                    <claimAndWithdraw_4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_5(inner) => {
                    <claimAndWithdraw_5Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_6(inner) => {
                    <claimAndWithdraw_6Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_7(inner) => {
                    <claimAndWithdraw_7Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_8(inner) => {
                    <claimAndWithdraw_8Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_9(inner) => {
                    <claimAndWithdraw_9Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_10(inner) => {
                    <claimAndWithdraw_10Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_11(inner) => {
                    <claimAndWithdraw_11Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_12(inner) => {
                    <claimAndWithdraw_12Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_13(inner) => {
                    <claimAndWithdraw_13Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_14(inner) => {
                    <claimAndWithdraw_14Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_15(inner) => {
                    <claimAndWithdraw_15Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_16(inner) => {
                    <claimAndWithdraw_16Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_17(inner) => {
                    <claimAndWithdraw_17Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_18(inner) => {
                    <claimAndWithdraw_18Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_19(inner) => {
                    <claimAndWithdraw_19Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_20(inner) => {
                    <claimAndWithdraw_20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_21(inner) => {
                    <claimAndWithdraw_21Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_22(inner) => {
                    <claimAndWithdraw_22Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_23(inner) => {
                    <claimAndWithdraw_23Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_24(inner) => {
                    <claimAndWithdraw_24Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_25(inner) => {
                    <claimAndWithdraw_25Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_26(inner) => {
                    <claimAndWithdraw_26Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_27(inner) => {
                    <claimAndWithdraw_27Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_28(inner) => {
                    <claimAndWithdraw_28Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_29(inner) => {
                    <claimAndWithdraw_29Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_30(inner) => {
                    <claimAndWithdraw_30Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_31(inner) => {
                    <claimAndWithdraw_31Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_32(inner) => {
                    <claimAndWithdraw_32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_33(inner) => {
                    <claimAndWithdraw_33Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_34(inner) => {
                    <claimAndWithdraw_34Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_35(inner) => {
                    <claimAndWithdraw_35Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_36(inner) => {
                    <claimAndWithdraw_36Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_37(inner) => {
                    <claimAndWithdraw_37Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_38(inner) => {
                    <claimAndWithdraw_38Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_39(inner) => {
                    <claimAndWithdraw_39Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_40(inner) => {
                    <claimAndWithdraw_40Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_41(inner) => {
                    <claimAndWithdraw_41Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_42(inner) => {
                    <claimAndWithdraw_42Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_43(inner) => {
                    <claimAndWithdraw_43Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_44(inner) => {
                    <claimAndWithdraw_44Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_45(inner) => {
                    <claimAndWithdraw_45Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_46(inner) => {
                    <claimAndWithdraw_46Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_47(inner) => {
                    <claimAndWithdraw_47Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ClaimProcessor`](self) custom errors.
    pub enum ClaimProcessorErrors {
        OnlyDirectCalls(OnlyDirectCalls),
        TStoreAlreadyActivated(TStoreAlreadyActivated),
        TStoreNotSupported(TStoreNotSupported),
        TloadTestContractDeploymentFailed(TloadTestContractDeploymentFailed),
    }
    #[automatically_derived]
    impl ClaimProcessorErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [37u8, 153u8, 67u8, 20u8],
            [42u8, 234u8, 88u8, 135u8],
            [112u8, 164u8, 7u8, 143u8],
            [244u8, 91u8, 152u8, 176u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ClaimProcessorErrors {
        const NAME: &'static str = "ClaimProcessorErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 4usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::OnlyDirectCalls(_) => {
                    <OnlyDirectCalls as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TStoreAlreadyActivated(_) => {
                    <TStoreAlreadyActivated as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TStoreNotSupported(_) => {
                    <TStoreNotSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TloadTestContractDeploymentFailed(_) => {
                    <TloadTestContractDeploymentFailed as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ClaimProcessorErrors>] = &[
                {
                    fn OnlyDirectCalls(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorErrors> {
                        <OnlyDirectCalls as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorErrors::OnlyDirectCalls)
                    }
                    OnlyDirectCalls
                },
                {
                    fn TloadTestContractDeploymentFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorErrors> {
                        <TloadTestContractDeploymentFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorErrors::TloadTestContractDeploymentFailed)
                    }
                    TloadTestContractDeploymentFailed
                },
                {
                    fn TStoreNotSupported(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorErrors> {
                        <TStoreNotSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorErrors::TStoreNotSupported)
                    }
                    TStoreNotSupported
                },
                {
                    fn TStoreAlreadyActivated(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ClaimProcessorErrors> {
                        <TStoreAlreadyActivated as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ClaimProcessorErrors::TStoreAlreadyActivated)
                    }
                    TStoreAlreadyActivated
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::OnlyDirectCalls(inner) => {
                    <OnlyDirectCalls as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TStoreAlreadyActivated(inner) => {
                    <TStoreAlreadyActivated as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TStoreNotSupported(inner) => {
                    <TStoreNotSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TloadTestContractDeploymentFailed(inner) => {
                    <TloadTestContractDeploymentFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::OnlyDirectCalls(inner) => {
                    <OnlyDirectCalls as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TStoreAlreadyActivated(inner) => {
                    <TStoreAlreadyActivated as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TStoreNotSupported(inner) => {
                    <TStoreNotSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TloadTestContractDeploymentFailed(inner) => {
                    <TloadTestContractDeploymentFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ClaimProcessor`](self) contract instance.

See the [wrapper's documentation](`ClaimProcessorInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ClaimProcessorInstance<T, P, N> {
        ClaimProcessorInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ClaimProcessorInstance<T, P, N>>,
    > {
        ClaimProcessorInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        ClaimProcessorInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`ClaimProcessor`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ClaimProcessor`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ClaimProcessorInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ClaimProcessorInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ClaimProcessorInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ClaimProcessorInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`ClaimProcessor`](self) contract instance.

See the [wrapper's documentation](`ClaimProcessorInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<ClaimProcessorInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ClaimProcessorInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ClaimProcessorInstance<T, P, N> {
            ClaimProcessorInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ClaimProcessorInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`__activateTstore`] function.
        pub fn __activateTstore(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, __activateTstoreCall, N> {
            self.call_builder(&__activateTstoreCall {})
        }
        ///Creates a new call builder for the [`claim_0`] function.
        pub fn claim_0(
            &self,
            claimPayload: <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_0Call, N> {
            self.call_builder(&claim_0Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_1`] function.
        pub fn claim_1(
            &self,
            claimPayload: <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_1Call, N> {
            self.call_builder(&claim_1Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_2`] function.
        pub fn claim_2(
            &self,
            claimPayload: <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_2Call, N> {
            self.call_builder(&claim_2Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_3`] function.
        pub fn claim_3(
            &self,
            claimPayload: <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_3Call, N> {
            self.call_builder(&claim_3Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_4`] function.
        pub fn claim_4(
            &self,
            claimPayload: <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_4Call, N> {
            self.call_builder(&claim_4Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_5`] function.
        pub fn claim_5(
            &self,
            claimPayload: <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_5Call, N> {
            self.call_builder(&claim_5Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_6`] function.
        pub fn claim_6(
            &self,
            claimPayload: <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_6Call, N> {
            self.call_builder(&claim_6Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_7`] function.
        pub fn claim_7(
            &self,
            claimPayload: <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_7Call, N> {
            self.call_builder(&claim_7Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_8`] function.
        pub fn claim_8(
            &self,
            claimPayload: <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_8Call, N> {
            self.call_builder(&claim_8Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_9`] function.
        pub fn claim_9(
            &self,
            claimPayload: <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_9Call, N> {
            self.call_builder(&claim_9Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_10`] function.
        pub fn claim_10(
            &self,
            claimPayload: <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_10Call, N> {
            self.call_builder(&claim_10Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_11`] function.
        pub fn claim_11(
            &self,
            claimPayload: <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_11Call, N> {
            self.call_builder(&claim_11Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_12`] function.
        pub fn claim_12(
            &self,
            claimPayload: <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_12Call, N> {
            self.call_builder(&claim_12Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_13`] function.
        pub fn claim_13(
            &self,
            claimPayload: <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_13Call, N> {
            self.call_builder(&claim_13Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_14`] function.
        pub fn claim_14(
            &self,
            claimPayload: <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_14Call, N> {
            self.call_builder(&claim_14Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_15`] function.
        pub fn claim_15(
            &self,
            claimPayload: <BatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_15Call, N> {
            self.call_builder(&claim_15Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_16`] function.
        pub fn claim_16(
            &self,
            claimPayload: <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_16Call, N> {
            self.call_builder(&claim_16Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_17`] function.
        pub fn claim_17(
            &self,
            claimPayload: <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_17Call, N> {
            self.call_builder(&claim_17Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_18`] function.
        pub fn claim_18(
            &self,
            claimPayload: <QualifiedClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_18Call, N> {
            self.call_builder(&claim_18Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_19`] function.
        pub fn claim_19(
            &self,
            claimPayload: <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_19Call, N> {
            self.call_builder(&claim_19Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_20`] function.
        pub fn claim_20(
            &self,
            claimPayload: <BasicClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_20Call, N> {
            self.call_builder(&claim_20Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_21`] function.
        pub fn claim_21(
            &self,
            claimPayload: <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_21Call, N> {
            self.call_builder(&claim_21Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_22`] function.
        pub fn claim_22(
            &self,
            claimPayload: <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_22Call, N> {
            self.call_builder(&claim_22Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_23`] function.
        pub fn claim_23(
            &self,
            claimPayload: <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_23Call, N> {
            self.call_builder(&claim_23Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_24`] function.
        pub fn claim_24(
            &self,
            claimPayload: <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_24Call, N> {
            self.call_builder(&claim_24Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_25`] function.
        pub fn claim_25(
            &self,
            claimPayload: <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_25Call, N> {
            self.call_builder(&claim_25Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_26`] function.
        pub fn claim_26(
            &self,
            claimPayload: <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_26Call, N> {
            self.call_builder(&claim_26Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_27`] function.
        pub fn claim_27(
            &self,
            claimPayload: <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_27Call, N> {
            self.call_builder(&claim_27Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_28`] function.
        pub fn claim_28(
            &self,
            claimPayload: <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_28Call, N> {
            self.call_builder(&claim_28Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_29`] function.
        pub fn claim_29(
            &self,
            claimPayload: <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_29Call, N> {
            self.call_builder(&claim_29Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_30`] function.
        pub fn claim_30(
            &self,
            claimPayload: <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_30Call, N> {
            self.call_builder(&claim_30Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_31`] function.
        pub fn claim_31(
            &self,
            claimPayload: <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_31Call, N> {
            self.call_builder(&claim_31Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_32`] function.
        pub fn claim_32(
            &self,
            claimPayload: <SplitClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_32Call, N> {
            self.call_builder(&claim_32Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_33`] function.
        pub fn claim_33(
            &self,
            claimPayload: <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_33Call, N> {
            self.call_builder(&claim_33Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_34`] function.
        pub fn claim_34(
            &self,
            claimPayload: <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_34Call, N> {
            self.call_builder(&claim_34Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_35`] function.
        pub fn claim_35(
            &self,
            claimPayload: <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_35Call, N> {
            self.call_builder(&claim_35Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_36`] function.
        pub fn claim_36(
            &self,
            claimPayload: <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_36Call, N> {
            self.call_builder(&claim_36Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_37`] function.
        pub fn claim_37(
            &self,
            claimPayload: <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_37Call, N> {
            self.call_builder(&claim_37Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_38`] function.
        pub fn claim_38(
            &self,
            claimPayload: <MultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_38Call, N> {
            self.call_builder(&claim_38Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_39`] function.
        pub fn claim_39(
            &self,
            claimPayload: <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_39Call, N> {
            self.call_builder(&claim_39Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_40`] function.
        pub fn claim_40(
            &self,
            claimPayload: <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_40Call, N> {
            self.call_builder(&claim_40Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_41`] function.
        pub fn claim_41(
            &self,
            claimPayload: <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_41Call, N> {
            self.call_builder(&claim_41Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_42`] function.
        pub fn claim_42(
            &self,
            claimPayload: <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_42Call, N> {
            self.call_builder(&claim_42Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_43`] function.
        pub fn claim_43(
            &self,
            claimPayload: <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_43Call, N> {
            self.call_builder(&claim_43Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_44`] function.
        pub fn claim_44(
            &self,
            claimPayload: <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_44Call, N> {
            self.call_builder(&claim_44Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_45`] function.
        pub fn claim_45(
            &self,
            claimPayload: <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_45Call, N> {
            self.call_builder(&claim_45Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_46`] function.
        pub fn claim_46(
            &self,
            claimPayload: <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_46Call, N> {
            self.call_builder(&claim_46Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_47`] function.
        pub fn claim_47(
            &self,
            claimPayload: <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_47Call, N> {
            self.call_builder(&claim_47Call { claimPayload })
        }
        ///Creates a new call builder for the [`claimAndWithdraw_0`] function.
        pub fn claimAndWithdraw_0(
            &self,
            claimPayload: <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_0Call, N> {
            self.call_builder(
                &claimAndWithdraw_0Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_1`] function.
        pub fn claimAndWithdraw_1(
            &self,
            claimPayload: <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_1Call, N> {
            self.call_builder(
                &claimAndWithdraw_1Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_2`] function.
        pub fn claimAndWithdraw_2(
            &self,
            claimPayload: <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_2Call, N> {
            self.call_builder(
                &claimAndWithdraw_2Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_3`] function.
        pub fn claimAndWithdraw_3(
            &self,
            claimPayload: <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_3Call, N> {
            self.call_builder(
                &claimAndWithdraw_3Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_4`] function.
        pub fn claimAndWithdraw_4(
            &self,
            claimPayload: <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_4Call, N> {
            self.call_builder(
                &claimAndWithdraw_4Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_5`] function.
        pub fn claimAndWithdraw_5(
            &self,
            claimPayload: <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_5Call, N> {
            self.call_builder(
                &claimAndWithdraw_5Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_6`] function.
        pub fn claimAndWithdraw_6(
            &self,
            claimPayload: <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_6Call, N> {
            self.call_builder(
                &claimAndWithdraw_6Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_7`] function.
        pub fn claimAndWithdraw_7(
            &self,
            claimPayload: <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_7Call, N> {
            self.call_builder(
                &claimAndWithdraw_7Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_8`] function.
        pub fn claimAndWithdraw_8(
            &self,
            claimPayload: <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_8Call, N> {
            self.call_builder(
                &claimAndWithdraw_8Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_9`] function.
        pub fn claimAndWithdraw_9(
            &self,
            claimPayload: <QualifiedClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_9Call, N> {
            self.call_builder(
                &claimAndWithdraw_9Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_10`] function.
        pub fn claimAndWithdraw_10(
            &self,
            claimPayload: <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_10Call, N> {
            self.call_builder(
                &claimAndWithdraw_10Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_11`] function.
        pub fn claimAndWithdraw_11(
            &self,
            claimPayload: <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_11Call, N> {
            self.call_builder(
                &claimAndWithdraw_11Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_12`] function.
        pub fn claimAndWithdraw_12(
            &self,
            claimPayload: <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_12Call, N> {
            self.call_builder(
                &claimAndWithdraw_12Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_13`] function.
        pub fn claimAndWithdraw_13(
            &self,
            claimPayload: <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_13Call, N> {
            self.call_builder(
                &claimAndWithdraw_13Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_14`] function.
        pub fn claimAndWithdraw_14(
            &self,
            claimPayload: <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_14Call, N> {
            self.call_builder(
                &claimAndWithdraw_14Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_15`] function.
        pub fn claimAndWithdraw_15(
            &self,
            claimPayload: <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_15Call, N> {
            self.call_builder(
                &claimAndWithdraw_15Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_16`] function.
        pub fn claimAndWithdraw_16(
            &self,
            claimPayload: <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_16Call, N> {
            self.call_builder(
                &claimAndWithdraw_16Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_17`] function.
        pub fn claimAndWithdraw_17(
            &self,
            claimPayload: <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_17Call, N> {
            self.call_builder(
                &claimAndWithdraw_17Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_18`] function.
        pub fn claimAndWithdraw_18(
            &self,
            claimPayload: <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_18Call, N> {
            self.call_builder(
                &claimAndWithdraw_18Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_19`] function.
        pub fn claimAndWithdraw_19(
            &self,
            claimPayload: <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_19Call, N> {
            self.call_builder(
                &claimAndWithdraw_19Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_20`] function.
        pub fn claimAndWithdraw_20(
            &self,
            claimPayload: <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_20Call, N> {
            self.call_builder(
                &claimAndWithdraw_20Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_21`] function.
        pub fn claimAndWithdraw_21(
            &self,
            claimPayload: <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_21Call, N> {
            self.call_builder(
                &claimAndWithdraw_21Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_22`] function.
        pub fn claimAndWithdraw_22(
            &self,
            claimPayload: <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_22Call, N> {
            self.call_builder(
                &claimAndWithdraw_22Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_23`] function.
        pub fn claimAndWithdraw_23(
            &self,
            claimPayload: <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_23Call, N> {
            self.call_builder(
                &claimAndWithdraw_23Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_24`] function.
        pub fn claimAndWithdraw_24(
            &self,
            claimPayload: <SplitClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_24Call, N> {
            self.call_builder(
                &claimAndWithdraw_24Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_25`] function.
        pub fn claimAndWithdraw_25(
            &self,
            claimPayload: <BatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_25Call, N> {
            self.call_builder(
                &claimAndWithdraw_25Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_26`] function.
        pub fn claimAndWithdraw_26(
            &self,
            claimPayload: <MultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_26Call, N> {
            self.call_builder(
                &claimAndWithdraw_26Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_27`] function.
        pub fn claimAndWithdraw_27(
            &self,
            claimPayload: <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_27Call, N> {
            self.call_builder(
                &claimAndWithdraw_27Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_28`] function.
        pub fn claimAndWithdraw_28(
            &self,
            claimPayload: <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_28Call, N> {
            self.call_builder(
                &claimAndWithdraw_28Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_29`] function.
        pub fn claimAndWithdraw_29(
            &self,
            claimPayload: <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_29Call, N> {
            self.call_builder(
                &claimAndWithdraw_29Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_30`] function.
        pub fn claimAndWithdraw_30(
            &self,
            claimPayload: <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_30Call, N> {
            self.call_builder(
                &claimAndWithdraw_30Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_31`] function.
        pub fn claimAndWithdraw_31(
            &self,
            claimPayload: <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_31Call, N> {
            self.call_builder(
                &claimAndWithdraw_31Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_32`] function.
        pub fn claimAndWithdraw_32(
            &self,
            claimPayload: <BasicClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_32Call, N> {
            self.call_builder(
                &claimAndWithdraw_32Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_33`] function.
        pub fn claimAndWithdraw_33(
            &self,
            claimPayload: <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_33Call, N> {
            self.call_builder(
                &claimAndWithdraw_33Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_34`] function.
        pub fn claimAndWithdraw_34(
            &self,
            claimPayload: <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_34Call, N> {
            self.call_builder(
                &claimAndWithdraw_34Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_35`] function.
        pub fn claimAndWithdraw_35(
            &self,
            claimPayload: <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_35Call, N> {
            self.call_builder(
                &claimAndWithdraw_35Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_36`] function.
        pub fn claimAndWithdraw_36(
            &self,
            claimPayload: <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_36Call, N> {
            self.call_builder(
                &claimAndWithdraw_36Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_37`] function.
        pub fn claimAndWithdraw_37(
            &self,
            claimPayload: <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_37Call, N> {
            self.call_builder(
                &claimAndWithdraw_37Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_38`] function.
        pub fn claimAndWithdraw_38(
            &self,
            claimPayload: <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_38Call, N> {
            self.call_builder(
                &claimAndWithdraw_38Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_39`] function.
        pub fn claimAndWithdraw_39(
            &self,
            claimPayload: <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_39Call, N> {
            self.call_builder(
                &claimAndWithdraw_39Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_40`] function.
        pub fn claimAndWithdraw_40(
            &self,
            claimPayload: <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_40Call, N> {
            self.call_builder(
                &claimAndWithdraw_40Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_41`] function.
        pub fn claimAndWithdraw_41(
            &self,
            claimPayload: <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_41Call, N> {
            self.call_builder(
                &claimAndWithdraw_41Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_42`] function.
        pub fn claimAndWithdraw_42(
            &self,
            claimPayload: <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_42Call, N> {
            self.call_builder(
                &claimAndWithdraw_42Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_43`] function.
        pub fn claimAndWithdraw_43(
            &self,
            claimPayload: <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_43Call, N> {
            self.call_builder(
                &claimAndWithdraw_43Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_44`] function.
        pub fn claimAndWithdraw_44(
            &self,
            claimPayload: <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_44Call, N> {
            self.call_builder(
                &claimAndWithdraw_44Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_45`] function.
        pub fn claimAndWithdraw_45(
            &self,
            claimPayload: <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_45Call, N> {
            self.call_builder(
                &claimAndWithdraw_45Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_46`] function.
        pub fn claimAndWithdraw_46(
            &self,
            claimPayload: <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_46Call, N> {
            self.call_builder(
                &claimAndWithdraw_46Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_47`] function.
        pub fn claimAndWithdraw_47(
            &self,
            claimPayload: <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_47Call, N> {
            self.call_builder(
                &claimAndWithdraw_47Call {
                    claimPayload,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ClaimProcessorInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
