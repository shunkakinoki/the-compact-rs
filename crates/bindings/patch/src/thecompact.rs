///Module containing a contract's types and functions.
/**

```solidity
library ISignatureTransfer {
    struct TokenPermissions { address token; uint256 amount; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod ISignatureTransfer {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct TokenPermissions { address token; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TokenPermissions {
        pub token: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TokenPermissions> for UnderlyingRustTuple<'_> {
            fn from(value: TokenPermissions) -> Self {
                (value.token, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TokenPermissions {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    token: tuple.0,
                    amount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for TokenPermissions {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for TokenPermissions {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for TokenPermissions {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for TokenPermissions {
            const NAME: &'static str = "TokenPermissions";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "TokenPermissions(address token,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.token,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for TokenPermissions {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.token,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.token,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ISignatureTransfer`](self) contract instance.

See the [wrapper's documentation](`ISignatureTransferInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ISignatureTransferInstance<T, P, N> {
        ISignatureTransferInstance::<T, P, N>::new(address, provider)
    }
    /**A [`ISignatureTransfer`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ISignatureTransfer`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ISignatureTransferInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ISignatureTransferInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ISignatureTransferInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ISignatureTransferInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`ISignatureTransfer`](self) contract instance.

See the [wrapper's documentation](`ISignatureTransferInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ISignatureTransferInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ISignatureTransferInstance<T, P, N> {
            ISignatureTransferInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ISignatureTransferInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ISignatureTransferInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library ISignatureTransfer {
    struct TokenPermissions {
        address token;
        uint256 amount;
    }
}

interface TheCompact {
    type CompactCategory is uint8;
    type ForcedWithdrawalStatus is uint8;
    type ResetPeriod is uint8;
    type Scope is uint8;
    struct BasicClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct BasicTransfer {
        bytes allocatorSignature;
        uint256 nonce;
        uint256 expires;
        uint256 id;
        uint256 amount;
        address recipient;
    }
    struct BatchClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct BatchClaimComponent {
        uint256 id;
        uint256 allocatedAmount;
        uint256 amount;
    }
    struct BatchClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct BatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct BatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct BatchTransfer {
        bytes allocatorSignature;
        uint256 nonce;
        uint256 expires;
        TransferComponent[] transfers;
        address recipient;
    }
    struct ClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ExogenousBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ExogenousMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousQualifiedBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ExogenousQualifiedBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct ExogenousQualifiedMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousQualifiedMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct ExogenousQualifiedSplitBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        SplitBatchClaimComponent[] claims;
    }
    struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        SplitBatchClaimComponent[] claims;
    }
    struct ExogenousQualifiedSplitMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct ExogenousQualifiedSplitMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct ExogenousSplitBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        SplitBatchClaimComponent[] claims;
    }
    struct ExogenousSplitBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        SplitBatchClaimComponent[] claims;
    }
    struct ExogenousSplitMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct ExogenousSplitMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 chainIndex;
        uint256 notarizedChainId;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct MultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct MultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedBatchClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct QualifiedBatchClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct QualifiedBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct QualifiedBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        BatchClaimComponent[] claims;
        address claimant;
    }
    struct QualifiedClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        address claimant;
        uint256 amount;
    }
    struct QualifiedSplitBatchClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        SplitBatchClaimComponent[] claims;
    }
    struct QualifiedSplitBatchClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        SplitBatchClaimComponent[] claims;
    }
    struct QualifiedSplitBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        SplitBatchClaimComponent[] claims;
    }
    struct QualifiedSplitBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        SplitBatchClaimComponent[] claims;
    }
    struct QualifiedSplitClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct QualifiedSplitClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct QualifiedSplitMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct QualifiedSplitMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32 qualificationTypehash;
        bytes qualificationPayload;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitBatchClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        SplitBatchClaimComponent[] claims;
    }
    struct SplitBatchClaimComponent {
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] portions;
    }
    struct SplitBatchClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        SplitBatchClaimComponent[] claims;
    }
    struct SplitBatchMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        SplitBatchClaimComponent[] claims;
    }
    struct SplitBatchMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        SplitBatchClaimComponent[] claims;
    }
    struct SplitBatchTransfer {
        bytes allocatorSignature;
        uint256 nonce;
        uint256 expires;
        SplitByIdComponent[] transfers;
    }
    struct SplitByIdComponent {
        uint256 id;
        SplitComponent[] portions;
    }
    struct SplitClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitComponent {
        address claimant;
        uint256 amount;
    }
    struct SplitMultichainClaim {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitMultichainClaimWithWitness {
        bytes allocatorSignature;
        bytes sponsorSignature;
        address sponsor;
        uint256 nonce;
        uint256 expires;
        bytes32 witness;
        string witnessTypestring;
        bytes32[] additionalChains;
        uint256 id;
        uint256 allocatedAmount;
        SplitComponent[] claimants;
    }
    struct SplitTransfer {
        bytes allocatorSignature;
        uint256 nonce;
        uint256 expires;
        uint256 id;
        SplitComponent[] recipients;
    }
    struct TransferComponent {
        uint256 id;
        uint256 amount;
    }

    error AllocatedAmountExceeded(uint256 allocatedAmount, uint256 providedAmount);
    error BalanceOverflow();
    error Expired(uint256 expiration);
    error ForcedWithdrawalAlreadyDisabled(address account, uint256 id);
    error InsufficientBalance();
    error InsufficientPermission();
    error InvalidBatchAllocation();
    error InvalidBatchDepositStructure();
    error InvalidDepositBalanceChange();
    error InvalidDepositTokenOrdering();
    error InvalidRegistrationDuration(uint256 duration);
    error InvalidRegistrationProof(address allocator);
    error InvalidScope(uint256 id);
    error InvalidSignature();
    error InvalidToken(address token);
    error OnlyDirectCalls();
    error Permit2CallFailed();
    error PrematureWithdrawal(uint256 id);
    error ReentrantCall(address existingCaller);
    error TStoreAlreadyActivated();
    error TStoreNotSupported();
    error TloadTestContractDeploymentFailed();
    error UnallocatedTransfer(address operator, address from, address to, uint256 id, uint256 amount);

    event AllocatorRegistered(uint96 allocatorId, address allocator);
    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);
    event Claim(address indexed sponsor, address indexed allocator, address indexed arbiter, bytes32 claimHash);
    event CompactRegistered(address indexed sponsor, bytes32 claimHash, bytes32 typehash, uint256 expires);
    event ForcedWithdrawalStatusUpdated(address indexed account, uint256 indexed id, bool activating, uint256 withdrawableAt);
    event OperatorSet(address indexed owner, address indexed operator, bool approved);
    event Transfer(address by, address indexed from, address indexed to, uint256 indexed id, uint256 amount);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function __activateTstore() external;
    function __registerAllocator(address allocator, bytes memory proof) external returns (uint96);
    function allocatedTransfer(BatchTransfer memory transfer) external returns (bool);
    function allocatedTransfer(SplitBatchTransfer memory transfer) external returns (bool);
    function allocatedTransfer(SplitTransfer memory transfer) external returns (bool);
    function allocatedTransfer(BasicTransfer memory transfer) external returns (bool);
    function allocatedWithdrawal(BasicTransfer memory withdrawal) external returns (bool);
    function allocatedWithdrawal(SplitBatchTransfer memory withdrawal) external returns (bool);
    function allocatedWithdrawal(BatchTransfer memory withdrawal) external returns (bool);
    function allocatedWithdrawal(SplitTransfer memory withdrawal) external returns (bool);
    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);
    function approve(address spender, uint256 id, uint256 amount) external payable returns (bool);
    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);
    function claim(ExogenousSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedMultichainClaim memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousMultichainClaim memory claimPayload) external returns (bool);
    function claim(ExogenousSplitMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(SplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(BatchClaim memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedClaim memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedMultichainClaim memory claimPayload) external returns (bool);
    function claim(BasicClaim memory claimPayload) external returns (bool);
    function claim(SplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(BatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(SplitClaimWithWitness memory claimPayload) external returns (bool);
    function claim(BatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(ExogenousSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedSplitClaim memory claimPayload) external returns (bool);
    function claim(BatchClaimWithWitness memory claimPayload) external returns (bool);
    function claim(SplitMultichainClaim memory claimPayload) external returns (bool);
    function claim(SplitClaim memory claimPayload) external returns (bool);
    function claim(SplitBatchClaim memory claimPayload) external returns (bool);
    function claim(SplitBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claim(QualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedBatchClaim memory claimPayload) external returns (bool);
    function claim(MultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(MultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitBatchClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousQualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(SplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claim(ExogenousBatchMultichainClaim memory claimPayload) external returns (bool);
    function claim(QualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitBatchClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(MultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(BatchClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitBatchClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(BatchClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(MultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(BasicClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(BatchMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(BatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousSplitMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedMultichainClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(SplitBatchClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedBatchClaim memory claimPayload) external returns (bool);
    function claimAndWithdraw(QualifiedSplitClaimWithWitness memory claimPayload) external returns (bool);
    function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
    function consume(uint256[] memory nonces) external returns (bool);
    function decimals(uint256 id) external view returns (uint8);
    function deposit(address token, uint256, uint256, uint256, address, address, ResetPeriod, Scope, address recipient, bytes memory signature) external returns (uint256);
    function deposit(address allocator, ResetPeriod resetPeriod, Scope scope, address recipient) external payable returns (uint256);
    function deposit(address token, address allocator, ResetPeriod resetPeriod, Scope scope, uint256 amount, address recipient) external returns (uint256);
    function deposit(address token, address allocator, uint256 amount) external returns (uint256);
    function deposit(address, ISignatureTransfer.TokenPermissions[] memory permitted, uint256, uint256, address, ResetPeriod, Scope, address recipient, bytes memory signature) external payable returns (uint256[] memory);
    function deposit(uint256[2][] memory idsAndAmounts, address recipient) external payable returns (bool);
    function deposit(address allocator) external payable returns (uint256);
    function depositAndRegister(address token, uint256, uint256, uint256, address depositor, address, ResetPeriod resetPeriod, Scope, bytes32 claimHash, CompactCategory compactCategory, string memory witness, bytes memory signature) external returns (uint256);
    function depositAndRegister(uint256[2][] memory idsAndAmounts, bytes32[2][] memory claimHashesAndTypehashes, uint256 duration) external payable returns (bool);
    function depositAndRegister(address allocator, bytes32 claimHash, bytes32 typehash) external payable returns (uint256 id);
    function depositAndRegister(address depositor, ISignatureTransfer.TokenPermissions[] memory permitted, uint256, uint256, address, ResetPeriod resetPeriod, Scope, bytes32 claimHash, CompactCategory compactCategory, string memory witness, bytes memory signature) external payable returns (uint256[] memory);
    function depositAndRegister(address token, address allocator, uint256 amount, bytes32 claimHash, bytes32 typehash) external returns (uint256 id);
    function disableForcedWithdrawal(uint256 id) external returns (bool);
    function enableForcedWithdrawal(uint256 id) external returns (uint256);
    function extsload(bytes32 slot) external view returns (bytes32);
    function extsload(bytes32[] memory slots) external view returns (bytes32[] memory);
    function exttload(bytes32 slot) external view returns (bytes32);
    function forcedWithdrawal(uint256 id, address recipient, uint256 amount) external returns (bool);
    function getForcedWithdrawalStatus(address account, uint256 id) external view returns (ForcedWithdrawalStatus, uint256);
    function getLockDetails(uint256 id) external view returns (address, address, ResetPeriod, Scope);
    function getRegistrationStatus(address sponsor, bytes32 claimHash, bytes32 typehash) external view returns (bool isActive, uint256 expires);
    function hasConsumedAllocatorNonce(uint256 nonce, address allocator) external view returns (bool);
    function isOperator(address owner, address spender) external view returns (bool status);
    function name(uint256 id) external view returns (string memory);
    function name() external pure returns (string memory);
    function register(bytes32[2][] memory claimHashesAndTypehashes, uint256 duration) external returns (bool);
    function register(bytes32 claimHash, bytes32 typehash, uint256 duration) external returns (bool);
    function setOperator(address operator, bool approved) external payable returns (bool);
    function supportsInterface(bytes4 interfaceId) external view returns (bool result);
    function symbol(uint256 id) external view returns (string memory);
    function tokenURI(uint256 id) external view returns (string memory);
    function transfer(address to, uint256 id, uint256 amount) external payable returns (bool);
    function transferFrom(address from, address to, uint256 id, uint256 amount) external payable returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "DOMAIN_SEPARATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "__activateTstore",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "__registerAllocator",
    "inputs": [
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "proof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint96",
        "internalType": "uint96"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allocatedTransfer",
    "inputs": [
      {
        "name": "transfer",
        "type": "tuple",
        "internalType": "struct BatchTransfer",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "transfers",
            "type": "tuple[]",
            "internalType": "struct TransferComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allocatedTransfer",
    "inputs": [
      {
        "name": "transfer",
        "type": "tuple",
        "internalType": "struct SplitBatchTransfer",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "transfers",
            "type": "tuple[]",
            "internalType": "struct SplitByIdComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allocatedTransfer",
    "inputs": [
      {
        "name": "transfer",
        "type": "tuple",
        "internalType": "struct SplitTransfer",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "recipients",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allocatedTransfer",
    "inputs": [
      {
        "name": "transfer",
        "type": "tuple",
        "internalType": "struct BasicTransfer",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allocatedWithdrawal",
    "inputs": [
      {
        "name": "withdrawal",
        "type": "tuple",
        "internalType": "struct BasicTransfer",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allocatedWithdrawal",
    "inputs": [
      {
        "name": "withdrawal",
        "type": "tuple",
        "internalType": "struct SplitBatchTransfer",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "transfers",
            "type": "tuple[]",
            "internalType": "struct SplitByIdComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allocatedWithdrawal",
    "inputs": [
      {
        "name": "withdrawal",
        "type": "tuple",
        "internalType": "struct BatchTransfer",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "transfers",
            "type": "tuple[]",
            "internalType": "struct TransferComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allocatedWithdrawal",
    "inputs": [
      {
        "name": "withdrawal",
        "type": "tuple",
        "internalType": "struct SplitTransfer",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "recipients",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BasicClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct MultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct MultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claim",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct MultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct MultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitBatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BasicClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct BatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedMultichainClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct SplitBatchClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct SplitBatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "portions",
                "type": "tuple[]",
                "internalType": "struct SplitComponent[]",
                "components": [
                  {
                    "name": "claimant",
                    "type": "address",
                    "internalType": "address"
                  },
                  {
                    "name": "amount",
                    "type": "uint256",
                    "internalType": "uint256"
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedBatchClaim",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct QualifiedSplitClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "id",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "allocatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claimants",
            "type": "tuple[]",
            "internalType": "struct SplitComponent[]",
            "components": [
              {
                "name": "claimant",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimAndWithdraw",
    "inputs": [
      {
        "name": "claimPayload",
        "type": "tuple",
        "internalType": "struct ExogenousQualifiedBatchMultichainClaimWithWitness",
        "components": [
          {
            "name": "allocatorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsorSignature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "sponsor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "nonce",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "expires",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "witness",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "witnessTypestring",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "qualificationTypehash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "qualificationPayload",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "additionalChains",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "chainIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "notarizedChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "claims",
            "type": "tuple[]",
            "internalType": "struct BatchClaimComponent[]",
            "components": [
              {
                "name": "id",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "allocatedAmount",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "claimant",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "consume",
    "inputs": [
      {
        "name": "nonces",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum ResetPeriod"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum Scope"
      },
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "resetPeriod",
        "type": "uint8",
        "internalType": "enum ResetPeriod"
      },
      {
        "name": "scope",
        "type": "uint8",
        "internalType": "enum Scope"
      },
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "resetPeriod",
        "type": "uint8",
        "internalType": "enum ResetPeriod"
      },
      {
        "name": "scope",
        "type": "uint8",
        "internalType": "enum Scope"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "permitted",
        "type": "tuple[]",
        "internalType": "struct ISignatureTransfer.TokenPermissions[]",
        "components": [
          {
            "name": "token",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum ResetPeriod"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum Scope"
      },
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "idsAndAmounts",
        "type": "uint256[2][]",
        "internalType": "uint256[2][]"
      },
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositAndRegister",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "depositor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "resetPeriod",
        "type": "uint8",
        "internalType": "enum ResetPeriod"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum Scope"
      },
      {
        "name": "claimHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "compactCategory",
        "type": "uint8",
        "internalType": "enum CompactCategory"
      },
      {
        "name": "witness",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "depositAndRegister",
    "inputs": [
      {
        "name": "idsAndAmounts",
        "type": "uint256[2][]",
        "internalType": "uint256[2][]"
      },
      {
        "name": "claimHashesAndTypehashes",
        "type": "bytes32[2][]",
        "internalType": "bytes32[2][]"
      },
      {
        "name": "duration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositAndRegister",
    "inputs": [
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "claimHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "typehash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositAndRegister",
    "inputs": [
      {
        "name": "depositor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "permitted",
        "type": "tuple[]",
        "internalType": "struct ISignatureTransfer.TokenPermissions[]",
        "components": [
          {
            "name": "token",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "resetPeriod",
        "type": "uint8",
        "internalType": "enum ResetPeriod"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum Scope"
      },
      {
        "name": "claimHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "compactCategory",
        "type": "uint8",
        "internalType": "enum CompactCategory"
      },
      {
        "name": "witness",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositAndRegister",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "claimHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "typehash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "disableForcedWithdrawal",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enableForcedWithdrawal",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "extsload",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "extsload",
    "inputs": [
      {
        "name": "slots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "exttload",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "forcedWithdrawal",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getForcedWithdrawalStatus",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum ForcedWithdrawalStatus"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLockDetails",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum ResetPeriod"
      },
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum Scope"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRegistrationStatus",
    "inputs": [
      {
        "name": "sponsor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "claimHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "typehash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "isActive",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "expires",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hasConsumedAllocatorNonce",
    "inputs": [
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isOperator",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "status",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "register",
    "inputs": [
      {
        "name": "claimHashesAndTypehashes",
        "type": "bytes32[2][]",
        "internalType": "bytes32[2][]"
      },
      {
        "name": "duration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "register",
    "inputs": [
      {
        "name": "claimHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "typehash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "duration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setOperator",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "tokenURI",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "AllocatorRegistered",
    "inputs": [
      {
        "name": "allocatorId",
        "type": "uint96",
        "indexed": false,
        "internalType": "uint96"
      },
      {
        "name": "allocator",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Claim",
    "inputs": [
      {
        "name": "sponsor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "allocator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "arbiter",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "claimHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CompactRegistered",
    "inputs": [
      {
        "name": "sponsor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "claimHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "typehash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "expires",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ForcedWithdrawalStatusUpdated",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "activating",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "withdrawableAt",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorSet",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "by",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AllocatedAmountExceeded",
    "inputs": [
      {
        "name": "allocatedAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "providedAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "BalanceOverflow",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Expired",
    "inputs": [
      {
        "name": "expiration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ForcedWithdrawalAlreadyDisabled",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientPermission",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidBatchAllocation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidBatchDepositStructure",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidDepositBalanceChange",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidDepositTokenOrdering",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidRegistrationDuration",
    "inputs": [
      {
        "name": "duration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidRegistrationProof",
    "inputs": [
      {
        "name": "allocator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidScope",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidToken",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OnlyDirectCalls",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Permit2CallFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PrematureWithdrawal",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ReentrantCall",
    "inputs": [
      {
        "name": "existingCaller",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "TStoreAlreadyActivated",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TStoreNotSupported",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TloadTestContractDeploymentFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnallocatedTransfer",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod TheCompact {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6101a060405234610085576100126100a8565b604051615ff19081610248823960805181611cda015260a05181611caa015260c05181613a4c015260e051816139d301526101005181613bac015261012051816137eb015261014051816137ca0152610160518181816115170152818161252e015261315001526101805181614eb10152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040513d5f823e3d90fd5b696002601e613d5c3d52f35f52600a60165ff06001600160a01b03811615610238575f80808084600a5a04fa3d15610233573d6001600160401b0381116102195760405190601f8101601f19908116603f011682016001600160401b038111838210176102195760405281525f60203d92013e5b801561021e57600160c052600360e0526005610100525b60a05260805246610120526101c74660a090604051907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208301527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d604083015260608201523060808201522090565b61014052604051613e2a8082016001600160401b03811183821017610219578291616239833903905ff0801561021457610160526e22d473030f116ddee9f6b43ac78ba33b151561018052565b61009d565b610089565b600260c052600460e052600661010052610133565b61011c565b632aea588760e01b5f5260045ffdfe6080806040526004361015610012575f80fd5b5f3560e01c908162ad800c1461312757508062fdd58e146130eb57806301ffc9a7146130a757806303417d721461309057806306659b7f1461307b57806306e8cc181461306657806306fdde031461303c57806308e600ee14613027578063095bcdb614612f4e5780630a133cf214612f395780630d57fec914612f245780630f5eeadf14612f0f578063107d4ee414612ec857806310d8267214612dff57806312a1e6ea14612dea57806312d4888514612d7a57806312f9d21e14612d6557806313589bfe14612d50578063138cd81914612d2a578063144bd5b514612cc85780631486590714612cb3578063176f405a14612c525780631b98b63f14612c3d5780631bb81a8114612c285780631d474b1414612c135780631e2eaeaf14612bf7578063200f0c4d14612b8f578063206620a114612b3f57806325d7776b14612b155780632737edb914612afe57806327c777a914612a815780632a9c4d0d146129515780632acd5dc31461293c5780632c4bbd17146129255780632e3ff2f7146128c15780632e4d55cc146128ac57806331bbae3e1461286e57806332e2a80314612859578063341056c5146128445780633644e5151461282a578063393c33e21461272f5780633f458a19146127185780633f47e662146126fc5780634073c0cc146126d9578063409b3a7e146126c4578063414fd914146126af578063418a23f51461269a578063426a849314612636578063440a0ec3146125ed57806344b97d78146125ba5780634ad5205e146125a35780634c1024161461258c5780634d585fbf146125755780634e41a1fb146125015780634e55a548146124ea578063507cb46f1461249057806353e5006714612350578063548439e114612339578063558a7297146122c4578063577cdc64146122ad5780635920212814612296578063598af9e7146122605780635ac2ccf1146122495780635b15bfd9146121dd5780635b6016ec146121765780635d76a382146121615780635e6c91ff1461214c57806362a420bb1461211557806363f5b1ad146120d8578063648705561461209a578063671b3bd61461202a5780636a9a4c4414611f895780636af2791b14611f745780637003019014611f125780637112406d14611dc857806371f5012714611db1578063721f629214611d765780637423eb3c14611c9157806376d531d414611c7c5780638340f54914611c41578063843719f014611bf15780638678555914611bdc57806388d247c414611bc557806388da84d414611bae57806389ce066114611b59578063935ed2ba14611b1e5780639730f4fd14611b07578063996d3aac14611adc57806399cf8b9b146119e85780639be5f537146119d1578063a23941471461191c578063a4c7bd93146118e2578063aa41c87e14611895578063aa8b845d14611863578063b20abc481461184e578063b24849b714611824578063b3244389146117ee578063b4039fc2146117c1578063b54baefd1461178c578063b602ae021461174a578063b6363cf214611705578063b7ace047146116c0578063b8a5bbad14611682578063bc95bd7a14611637578063c4d195e8146115f0578063c8091041146115b4578063c87b56dd14611432578063ca6cc39f146113e5578063d204f11e1461139a578063d2a1805f14611379578063d34ddc8214611362578063d350188c1461134d578063d3917f3c146112ff578063d921f36a146112b8578063da15ee7f1461112f578063da2f268b146110e6578063db04bc72146110d1578063dbd035ff14611059578063dd589cfc14610fdc578063e0565c4914610f8e578063e05c6e7d14610f41578063e6c5b65414610ee6578063e8672f9314610ed1578063ea14532e14610e6a578063eaa6748314610e33578063eb19600814610df9578063eb35a6d214610d89578063eb43182114610d4d578063ebcbd7b514610cf6578063ecaca40e14610c8d578063eea77a7814610c18578063eed634ad14610c03578063eed9357214610bb8578063f135baaa14610b9c578063f23d923d14610b2e578063f2f0def114610ae9578063f340fa0114610ab8578063f44a345214610a5a578063f745381c14610a24578063f95d3d16146109ea578063fa1c55001461098a578063fb75fb6914610924578063fcfe431a146108c1578063fdc060e7146107d75763fe99049a14610655575f80fd5b60803660031901126107d3576106696131bd565b6106716131ff565b6044359160643561068d60016001605c1b038560a01c16614862565b9260018060a01b0383169260018060a01b038216945f60208160a460405194828052601c8601948591631a808f91885233868901528b60408901528c60608901528d60808901528a60a08901525af15f5163e57f706f60e01b016107b85750505067edcaa89a82293940603452602852336014526034602020541561077f575b84601452604060142080548084116107725783900390556028528360145260406014208054908282019182106107655755335f526020525f516020615f655f395f51905f5260405fa45f603452602060405160018152f35b6389560ca15f526004601cfd5b63f4d678b85f526004601cfd5b845f5260545f20805460018101610798575b505061070d565b8084116107ab5783900390555f80610791565b63deda90305f526004601cfd5b3d1517156107cb5763014c931060a49252fd5b3d5f803e3d5ffd5b5f80fd5b346107d3576107e536613408565b608081015f806107f5838561377f565b905f915b80831061089c5750505061088a576108796035928461087461087f9660e06040515f516020615fa55f395f51905f52815233602082015233604082015260208301976060898184013760c0820152209560608201359661086f61086760016001605c1b038a60a01c16614862565b809335613fcf565b614012565b61377f565b9061527d565b602060405160018152f35b634e487b715f5260116020526024601cfd5b90919260019060206108af8685876138cd565b013580960195861017930191906107f9565b346107d357602061091a601760356108d8366133d4565b6101806108f96108f36108ed83850185613c23565b90614bee565b83615c0a565b9290919361090b610160820135613c58565b926109146137c8565b95614d26565b6040519015158152f35b346107d357602061091a603461093936613249565b61095b61095361094d610100840184613898565b90614e53565b826030615651565b9061010061096b3615848461532d565b916109796001361517613cdd565b926109826137c8565b946021615e45565b346107d357602061091a603461099f3661327d565b6109bb6109b36108ed610100840184613c23565b826031615651565b906109c960e0820135613c58565b6101006109d96002361517613cdd565b926109e26137c8565b946026615e45565b346107d357602061091a60356109ff36613215565b610120610a10604036151783615bc9565b92919390610a1c6137c8565b946024615e45565b346107d357602061091a60176034610a3b3661333c565b610a4481615571565b90610100610a506137c8565b93361592806152df565b346107d357602061091a6035610a6f36613249565b610a8a610a826108ed60e0840184613c23565b82602b615651565b9060e0610a993615848461532d565b91610aa76001361517613cdd565b92610ab06137c8565b94601f615e45565b60203660031901126107d3576020610ad6610ad16131bd565b614320565b610ae134823361437c565b604051908152f35b346107d357602061091a60176035610b00366133a0565b610b19610b1361094d60e0840184613898565b82615834565b9060e0610b246137c8565b93361592806151a7565b346107d357602061091a6035610b4336613215565b3615610100610b73610b6b60408417859060e0910160c08101355f52013560205260405f2090565b846030615651565b92610b8b6002610b8485878561532d565b9417613cdd565b92610b946137c8565b946023615e45565b346107d35760203660031901126107d3576004355c5f5260205ff35b346107d357602061091a6035610bcd36613215565b610be7610be16108ed610140840184613c23565b82615b8a565b9091610140610bfa610120830135613c58565b916109e26137c8565b346107d357602061091a6034610bcd36613215565b346107d357602061091a6035610c2d366133d4565b361590610c5b610c5360808417839060e0910160c08101355f52013560205260405f2090565b826032615651565b91610140610c6a82858561532d565b92610c7e6002610b84610120840135613c58565b93610c876137c8565b95614239565b346107d35760a03660031901126107d3576020610ca86131bd565b610cd9610cc4610cb66131ff565b610cbf846148dc565b6142e2565b91610ccd6139d1565b8260443591339061487c565b610ce1613baa565b610ae1610258361517608435606435336141b4565b346107d357602061091a6034610d0b366134d1565b610180610d326108f360c0361517849060e0910160c08101355f52013560205260405f2090565b92909193610d44610160820135613c58565b92610c876137c8565b346107d357602061091a6034610d623661327d565b610120610d7d610d7761094d83850185613898565b83615baa565b929193906109826137c8565b346107d35760203660031901126107d3576020600435610ae162ffffff77278d00094890015180000f3c00025800003c00000f000001601860078560fc1c16021c1642018281610df38195339190604051926014526341d0e04b5f526034526038601c2091604052565b556148f6565b346107d357602061091a6035610e0e3661333c565b610100610e1a826155cc565b919092610e2a6002361517613cdd565b92610a1c6137c8565b346107d357602061091a6034610e48366133a0565b610e5b610a8261094d60e0840184613898565b9060e061096b3615848461532d565b346107d357602061091a60176034610e813661333c565b610e95610c5361094d610140840184613898565b90610ea23615838361532d565b90610140610eb4610120830135613c58565b91610ec26002361517613cdd565b93610ecb6137c8565b956151a7565b346107d357602061091a60346109ff36613215565b346107d357602061091a6034610efb3661327d565b610f20610f188260e09060c08101355f52013560205260405f2090565b82602f615651565b90361560c0610f3160028317613cdd565b92610f3a6137c8565b9480614239565b346107d357602061091a6035610f563661333c565b610f5f81615250565b90610f6d60e0820135613c58565b610100610f7d6002361517613cdd565b92610f866137c8565b946025615e45565b346107d357602061091a6034610fa336613215565b6101003615610fd1610fcb60408317859060e0910160c08101355f52013560205260405f2090565b84615b66565b929093610f3a6137c8565b346107d357602061091a610fef3661343b565b6040515f516020615fa55f395f51905f528152338482015233604082015261103f8260e0868201936080856060830137209260608201359361086f61086760016001605c1b038760a01c16614862565b608061104d60a084016137b4565b92013591336034615c31565b346107d35760203660031901126107d3576004356001600160401b0381116107d357611089903690600401613370565b6040519160408360208152836020820152019160051b8301916020806040850193925b83355481520191019084838210156110c85750602080916110ac565b60408186030190f35b346107d357602061091a6034610a6f36613249565b346107d35760403660031901126107d35760206004356111046131ff565b906040519183526303f37b1a600c52806040526001603760282054918360405260ff161b1615158152f35b6101603660031901126107d3576111446131bd565b6024356001600160401b0381116107d35761116390369060040161346e565b61116e9291926131d3565b5060a4359060088210156107d357600260c43510156107d35760e43591610104359460038610156107d357610124356001600160401b0381116107d3576111b990369060040161330f565b9661014435906001600160401b0382116107d357869588926111df90369060040161330f565b6111ed8584899e949e614984565b96819f939183839b949b0160051b90602001209561120b8b84614a8c565b83839992993615976001891792611221946143c6565b9f9091604051925f5260205260405260605f206080890152604052601f19916002811460061b90600114600b020190801515010160f301169060071b01610180019060c01761126f94613e72565b611279948a614b38565b60180277278d00094890015180000f3c00025800003c00000f000001901c62ffffff16916112a6936141b4565b6040516112b48192826135c0565b0390f35b346107d357602061091a601760356112cf366132db565b6101806112e46108f361094d83850185613898565b929091936112f6610160820135613c58565b92610ecb6137c8565b346107d357602061091a6035611314366133d4565b61014061134161133b6080361517849060e0910160c08101355f52013560205260405f2090565b83615bd9565b92919390610b946137c8565b346107d357602061091a6034610e0e3661333c565b346107d357602061091a60176034610b00366133a0565b346107d357602061091a603561138e366132db565b610140610a10826155f4565b346107d357602061091a601760346113b13661343b565b6113c4610a8261094d60a0840184613898565b90361560a06113d560018317613cdd565b926113de6137c8565b94806151a7565b346107d357602061091a60356113fa36613215565b61140381615250565b9061141160e0820135613c58565b6101006114216002361517613cdd565b9261142a6137c8565b946022615e45565b346107d35760203660031901126107d357604051600435608082016001600160401b038111838210176115a05760409081525f60208401818152918401818152606085019182526001600160a01b03848116865261149c60a086901c60016001605c1b0316614862565b16835260078460fc1c16600881101561158c5781528360ff1c90600282101561158c5790825260405163d637ca8d60e01b815294516001600160a01b03908116600487015292519092166024850152905161150b91906115009060448601906135a6565b5160648401906135b3565b60848201525f8160a4817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015611581576112b4915f9161155f575b5060405191829182613193565b61157b91503d805f833e61157381836135f9565b810190613635565b82611552565b6040513d5f823e3d90fd5b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b60403660031901126107d3576004356001600160401b0381116107d3576115e261087f91369060040161346e565b6115ea6131ff565b916138dd565b346107d357602061091a601760356116073661327d565b61162161161b6108ed610100840184613c23565b82615b66565b9061010061162d6137c8565b9336159280614d26565b346107d357602061091a6017603561164e366133a0565b611661610f186108ed60c0840184613c23565b90361560c061167260028317613cdd565b9261167b6137c8565b9480614d26565b346107d357602061091a60176034611699366133a0565b6116a281615516565b90361560a06116b082613cdd565b926116b96137c8565b94806152df565b346107d357602061091a601760346116d736613249565b6116f4610f188260e09060c08101355f52013560205260405f2090565b90361560c06116b060028317613cdd565b346107d35760403660031901126107d35761171e6131bd565b6117266131ff565b9067edcaa89a822939406020526014525f5260206034600c20546040519015158152f35b346107d357602061091a603561175f36613249565b361561176d81836028615651565b9061177781613cdd565b916117806137c8565b9360a083179180614239565b346107d357602061091a601760346117a336613249565b6117b6610b136108ed60e0840184613c23565b9060e061162d6137c8565b346107d357602061091a60346117d63661327d565b60e06117e182615524565b919092610e2a3615613cdd565b346107d357602061091a603461180336613215565b61014061181861133b6108ed83850185613c23565b92919390610ab06137c8565b346107d357602061091a60346118393661333c565b610120611818610d776108ed83850185613c23565b346107d357602061091a60356118393661333c565b602061187c610ae1611874366132b1565b939091614320565b9261188834853361437c565b61025836151791336141b4565b346107d357602061091a60346118aa3661333c565b6118be610be161094d610140840184613898565b90916101406118d1610120830135613c58565b916118da6137c8565b946027615e45565b346107d357602061091a60346118f7366132db565b61190081615542565b9091610140611913610120830135613c58565b91610f866137c8565b346107d35761192a36613408565b608081015f8061193a838561377f565b905f915b8083106119ac5750505061088a576108796034928461087461087f9660e06040515f516020615fa55f395f51905f52815233602082015233604082015260208301976060898184013760c0820152209560608201359661086f61086760016001605c1b038a60a01c16614862565b90919260019060206119bf8685876138cd565b0135809601958610179301919061193e565b346107d357602061091a6017603461164e366133a0565b6101203660031901126107d3576119fd6131bd565b506024356001600160401b0381116107d357611a1d90369060040161346e565b611a256131d3565b50600860a43510156107d357600260c43510156107d35760e435916001600160a01b03831683036107d35761010435906001600160401b0382116107d3576112b493611aca611a7b611ad094369060040161330f565b959093611a89848383614984565b9592611ab660c09b9399929b361592611aa460848517613d1e565b611aae8d83614a8c565b949094613db8565b608084015260071b61022001921790613e72565b86614b38565b604051918291826135c0565b346107d357602061091a60176034611af33661327d565b611afc81615774565b9060e0610a506137c8565b346107d357602061091a601760346116073661327d565b346107d357602061091a60176034611b3536613539565b611b48610f1861094d60c0840184613898565b90361560c06113d560028317613cdd565b346107d357602061091a6035611b6e366133d4565b611b92610be16080361517839060e0910160c08101355f52013560205260405f2090565b9091610140611ba5610120830135613c58565b9161142a6137c8565b346107d357602061091a60176035610e813661333c565b346107d357602061091a60176035611b3536613539565b346107d357602061091a603461175f36613249565b346107d357602061091a60176035611c08366132db565b611c118161559c565b9091610140611c24610120830135613c58565b91611c326002361517613cdd565b93611c3b6137c8565b956152df565b346107d3576020611c63611c74611c573661356c565b919390610cbf856148dc565b8093611c6d6139d1565b339061487c565b610ae1613baa565b346107d357602061091a6035610efb3661327d565b346107d3575f3660031901126107d357323303611d67577f00000000000000000000000000000000000000000000000000000000000000008015611d5c575b611d4d575f8080807f0000000000000000000000000000000000000000000000000000000000000000600a5a04fa3d15611d48573d611d0e8161361a565b90611d1c60405192836135f9565b81525f60203d92013e5b15611d39575f805460ff19166001179055005b6370a4078f60e01b5f5260045ffd5b611d26565b630f45b98b60e41b5f5260045ffd5b5060ff5f5416611cd0565b63096650c560e21b5f5260045ffd5b346107d357602061091a60176035611d8d36613539565b611da0610a826108ed60a0840184613c23565b90361560a061167260018317613cdd565b346107d357602061091a60176035611699366133a0565b346107d357611dd63661349e565b60608101611de48183613898565b8060069492941b81810460401482151715611efe57611e0290614bad565b935f915f5b818110611e955750505061088a57611e4d81611e2d856020611e52975191012082615373565b611e476039611e3c8785613898565b6020860135916140ed565b90614012565b613898565b5f5b818110611e6657602060405160018152f35b80611e8f6034611e796001948688614192565b611e86602082018261377f565b9091359161527d565b01611e54565b611ea0818385614192565b5f90611eaf602082018261377f565b905f915b808310611ed957505050906040839260019460061b8b0190356020820152015201611e07565b9091976001906020611eec8b85876138cd565b01358096019586101798019190611eb3565b634e487b7160e01b5f52601160045260245ffd5b346107d35760203660031901126107d357600435611f4981339190604051926014526341d0e04b5f526034526038601c2091604052565b805415611f5f57905f61087f92553615906148f6565b5063e632dbad5f52336020526040526044601cfd5b346107d357602061091a6034610c2d366133d4565b346107d3576080611f9936613408565b611fed611fe460608301611fde84611fc6611fb4848361377f565b6040519060061b809282372082615373565b611e47611fd3858461377f565b60208501359161406f565b8361377f565b939092016137b4565b905f5b83811061200257602060405160018152f35b8061202361201360019387866138cd565b6020810135903586336035615c31565b5001611ff0565b346107d35760c03660031901126107d3576120436131bd565b61204b6131ff565b906044359160088310156107d3576064359160028310156107d357612087611c74926020956120786131e9565b95612082856148dc565b61434b565b80936120916139d1565b6084359261487c565b346107d357602061091a601760356120b136613505565b6101806120bd82615626565b929091936120cf610160820135613c58565b92611c3b6137c8565b346107d357602061091a60346120ed3661333c565b361560e061210060408317846028615651565b92610b8b61210f84868461532d565b93613cdd565b346107d357602061091a6017603561212c36613249565b61214061161b61094d610100840184613898565b90610100610b246137c8565b346107d357602061091a6034611b6e366133d4565b346107d357602061091a60356118aa3661333c565b60603660031901126107d3576004356001600160401b0381116107d3576121a190369060040161346e565b602435906001600160401b0382116107d3576020926121d46121ca61091a94369060040161346e565b92909333916138dd565b60443591614159565b346107d35760203660031901126107d357608060043561224761220b60016001605c1b038360a01c16614862565b604080516001600160a01b038086168252909216602083015290929061223a90840160fc83901c6007166135a6565b606083019060ff1c6135b3565bf35b346107d357602061091a601760346108d8366133d4565b346107d35761226e3661356c565b9167edcaa89a822939406034526028526014525f52602060545f20545f603452604051908152f35b346107d357602061091a60176034611d8d36613539565b346107d357602061091a6017603461212c36613249565b60403660031901126107d3576122d86131bd565b602435908115158092036107d35767edcaa89a82293940602052336014525f52806034600c2055602052600c5160601c337fceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa267602080a3602060405160018152f35b346107d357602061091a601760356113b13661343b565b346107d3576101803660031901126107d35761236a6131bd565b6123726131d3565b9061237b6131e9565b5060c43560088110156107d357600260e43510156107d3576101043590610124359060038210156107d357610144356001600160401b0381116107d3576123c690369060040161330f565b94909261016435956001600160401b0387116107d35787966123ec90369060040161330f565b9890916123f885613d53565b839d93969297919436159b61240e938d936143c6565b9990604051905f52866020528b60405260605f20610100860152604052601f1961016085015161017f0116906101401761244794613e72565b61245093613eca565b60180277278d00094890015180000f3c00025800003c00000f000001901c62ffffff169161247d936141b4565b612485613baa565b604051908152602090f35b60803660031901126107d3576124a46131bd565b60243560088110156107d3576044359060028210156107d357606435916001600160a01b03831683036107d357602093610ae1926124e1926142b1565b9182349161437c565b346107d357602061091a601760356117a336613249565b346107d35760203660031901126107d357604051634e41a1fb60e01b815260048035908201525f816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015611581576112b4915f9161155f575060405191829182613193565b346107d357602061091a601760346120b136613505565b346107d357602061091a60176034611c08366132db565b346107d357602061091a60176035611af33661327d565b346107d357602061091a60346125cf3661333c565b6125d881615774565b9060e06125e36137c8565b9336159280614239565b346107d3576040612627612600366132b1565b91605892601c926040519260148401526368a30dd083526034830152605482015201205490565b81519042811182526020820152f35b61263f366132b1565b909167edcaa89a8229394060345233602852601452815f528060545f20555f5260205160601c337fb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a760205fa45f603452602060405160018152f35b346107d357602061091a6035610d0b366134d1565b346107d357602061091a603461138e366132db565b346107d357602061091a6034610f563661333c565b346107d35760603660031901126107d35761087f604435602435600435336141b4565b346107d35760203660031901126107d357602060405160128152f35b346107d357602061091a60176035610a3b3661333c565b346107d35761273d3661349e565b6060810161274b8183613898565b8060069492941b81810460401482151715611efe5761276990614bad565b935f915f5b8181106127c15750505061088a57611e4d81611e2d856020612794975191012082615373565b5f5b8181106127a857602060405160018152f35b806127bb6035611e796001948688614192565b01612796565b6127cc818385614192565b5f906127db602082018261377f565b905f915b80831061280557505050906040839260019460061b8b019035602082015201520161276e565b90919760019060206128188b85876138cd565b013580960195861017980191906127df565b346107d3575f3660031901126107d3576020610ae16137c8565b346107d357602061091a60356118f7366132db565b346107d357602061091a60346113fa36613215565b346107d35760403660031901126107d3576004356001600160401b0381116107d35761091a6128a3602092369060040161346e565b60243591614159565b346107d357602061091a60356125cf3661333c565b346107d35760603660031901126107d3576004356128dd6131ff565b60408051336014526341d0e04b5f5260348490526038601c209152544281119015176129145761091a906020926044359133613697565b50639287bcb05f526020526024601cfd5b346107d357602061091a601760346112cf366132db565b346107d357602061091a603561099f3661327d565b346107d35760403660031901126107d35761296a6131bd565b6024356001600160401b0381116107d35761298990369060040161330f565b6001600160a01b03909216916055811491338414843b1515179183612a35575b50501715612a25576129ba81613ef9565b806744036fc77deaed23605c1b1791825480612a1157508060209355815f5282527fc54dcaa67a8fd7b4a9aa6fd57351934c792613d5ec1acbd65274270e6de8f7e460405fa16001600160601b0360405191168152f35b8263c18b0e975f526020526040526044601cfd5b634e7f492b5f526020526024601cfd5b809192935015612a6d57808260405137604051206001600160a01b031683146001600160f81b031991358216909114169083806129a9565b634e487b7160e01b5f52603260045260245ffd5b346107d357602061091a612a943661343b565b6040515f516020615fa55f395f51905f5281523384820152336040820152612ae48260e0868201936080856060830137209260608201359361086f61086760016001605c1b038760a01c16614862565b6080612af260a084016137b4565b92013591336035615c31565b346107d357602061091a601760356116d736613249565b346107d357602061091a6035612b2a3661333c565b610140610d7d61133b61094d83850185613898565b346107d357602061091a6035612b5436613249565b612b686109b361094d610100840184613898565b90612b7660e0820135613c58565b610100612b866002361517613cdd565b926118da6137c8565b346107d3576080612b9f36613408565b612bba611fe460608301611fde84611fc6611fb4848361377f565b905f5b838110612bcf57602060405160018152f35b80612bf0612be060019387866138cd565b6020810135903586336034615c31565b5001612bbd565b346107d35760203660031901126107d357600435545f5260205ff35b346107d357602061091a6034611314366133d4565b346107d357602061091a60356120ed3661333c565b346107d357602061091a6035610fa336613215565b346107d357602061091a60176034612c6936613215565b612c7d610c536108ed610140840184613c23565b90612c8a3615838361532d565b90610140612c9c610120830135613c58565b91612caa6002361517613cdd565b936109146137c8565b346107d357602061091a603561180336613215565b346107d35760403660031901126107d357612d06612ce46131bd565b602435909190604051926014526341d0e04b5f526034526038601c2091604052565b546040518115154283116002030291600383101561158c5760409282526020820152f35b346107d357602061091a6035612d3f366132db565b610120611341604036151783615bc9565b346107d357602061091a6035610e48366133a0565b346107d357602061091a6034610b4336613215565b346107d35760203660031901126107d3576004356001600160401b0381116107d357612daa903690600401613370565b90612dbc612db733613ef9565b613fa8565b809160051b01905b818110612dd657602060405160018152f35b602090612de4338235613fcf565b01612dc4565b346107d357602061091a6034612b2a3661333c565b346107d3576101403660031901126107d357612e196131bd565b612e216131d3565b50612e2a6131e9565b50600860c43510156107d357600260e43510156107d35761010435906001600160a01b03821682036107d357610124356001600160401b0381116107d357602092612ead92612e80611c7493369060040161330f565b929091612ec3361594612e9560a48717613d1e565b94612e9f84613d53565b9b839c9a939991929a613db8565b6101008201526101406102008317921790613e72565b613eca565b346107d357602061091a6034612edd3661327d565b612ef16109536108ed610100840184613c23565b90610100612f013615848461532d565b91610aa76002361517613cdd565b346107d357602061091a6035612edd3661327d565b346107d357602061091a6034612d3f366132db565b346107d357602061091a603561093936613249565b612f57366132b1565b612f6f60016001605c1b038360a09594951c16614862565b9160018060a01b038116925f60208160a460405194828052601c8601948591631a808f91885233868901523360408901528a60608901528b60808901528960a08901525af15f5163e57f706f60e01b016107b85750505067edcaa89a8229394060205233601452835f5260405f208054808411610772578390039055601452825f5260405f208054908282019182106107655755335f52602052335f516020615f655f395f51905f5260405fa4602060405160018152f35b346107d357602061091a6035610d623661327d565b346107d3575f3660031901126107d357602080526b0b54686520436f6d70616374604b5260606020f35b346107d357602061091a60356117d63661327d565b346107d357602061091a6034612b5436613249565b346107d357602061091a60176035612c6936613215565b346107d35760203660031901126107d3576004356001600160e01b0319811681036107d35760209060e01c604051906301ffc9a7630f632fb3821491141715158152f35b346107d35760403660031901126107d3576131046131bd565b67edcaa89a822939406020526014526024355f52602060405f2054604051908152f35b346107d35760203660031901126107d357622b600360e21b815260048035908201525f816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015611581576112b4915f9161155f5750604051918291825b602060409281835280519182918282860152018484015e5f828201840152601f01601f1916010190565b600435906001600160a01b03821682036107d357565b608435906001600160a01b03821682036107d357565b60a435906001600160a01b03821682036107d357565b602435906001600160a01b03821682036107d357565b60206003198201126107d357600435906001600160401b0382116107d3576101809082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576101209082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576101409082900360031901126107d35760040190565b60609060031901126107d3576004356001600160a01b03811681036107d357906024359060443590565b60206003198201126107d357600435906001600160401b0382116107d3576101a09082900360031901126107d35760040190565b9181601f840112156107d3578235916001600160401b0383116107d357602083818601950101116107d357565b60206003198201126107d357600435906001600160401b0382116107d3576101609082900360031901126107d35760040190565b9181601f840112156107d3578235916001600160401b0383116107d3576020808501948460051b0101116107d357565b60206003198201126107d357600435906001600160401b0382116107d3576101009082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576101c09082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d35760a09082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d35760c09082900360031901126107d35760040190565b9181601f840112156107d3578235916001600160401b0383116107d3576020808501948460061b0101116107d357565b60206003198201126107d357600435906001600160401b0382116107d35760809082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576102009082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576101e09082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d35760e09082900360031901126107d35760040190565b60609060031901126107d3576004356001600160a01b03811681036107d357906024356001600160a01b03811681036107d3579060443590565b90600882101561158c5752565b90600282101561158c5752565b60206040818301928281528451809452019201905f5b8181106135e35750505090565b82518452602093840193909201916001016135d6565b90601f801991011681019081106001600160401b038211176115a057604052565b6001600160401b0381116115a057601f01601f191660200190565b6020818303126107d3578051906001600160401b0382116107d3570181601f820112156107d3578051906136688261361a565b9261367660405194856135f9565b828452602083830101116107d357815f9260208093018386015e8301015290565b909291926136a36139d1565b6001600160a01b0384168061372457505f9081808538935af115613717575b67edcaa89a8229394060205280601452825f5260405f209182549283821161077257815f9403905533835260205260018060a01b03165f516020615f655f395f51905f52604083a4613712613baa565b600190565b63b12d13eb5f526004601cfd5b9091926137313083613b85565b9260145260345263a9059cbb60601b5f5260205f6044601082855af13d1560015f51141716156137725761376a905f6034523090613b85565b9003906136c2565b6390b8ec185f526004601cfd5b903590601e19813603018212156107d357018035906001600160401b0382116107d357602001918160061b360383136107d357565b356001600160a01b03811681036107d35790565b7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000046186138135790565b5060a06040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208201527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d60408201524660608201523060808201522090565b903590601e19813603018212156107d357018035906001600160401b0382116107d357602001918160051b360383136107d357565b9190811015612a6d5760061b0190565b91906138e76139d1565b82359060018060a01b03821615916020850135341415831634158414178215176139c4578060016001605c1b03849260a01c1661392381613fa8565b936139b2575b505b81811061394157505050505061393f613baa565b565b61394c8183876138cd565b80359060016001605c1b038260a01c166001600160601b0386168103613991575b506001929161398b916020013590876001600160a01b03821661487c565b0161392b565b61398b919550916020836139a760019695613fa8565b96925050919261396d565b6139be9034908661437c565b5f613929565b63ca0fc08e5f526004601cfd5b7f000000000000000000000000000000000000000000000000000000000000000080600414613b595780600314613b475780600914613b105780600a14613ad357600814613a2d57634e487b7160e01b5f52605160045260245ffd5b613a43361568929eee149b4bd212686028615651565b805b613ac357507f000000000000000000000000000000000000000000000000000000000000000080600214613a9c57600114613a8e57634e487b7160e01b5f52605160045260245ffd5b3368929eee149b4bd212685d565b505f5460ff1615613ab5573368929eee149b4bd212685d565b3368929eee149b4bd2126855565b63f57c448b5f526020526024601cfd5b5060e0604036151768929eee149b4bd212680160c08101355f520135602052613b0a60405f2068929eee149b4bd212686031615651565b80613a45565b5068929eee149b4bd21328355f90815268929eee149b4bd213483560205260409020613b0a9068929eee149b4bd21268602f615651565b5068929eee149b4bd212685c80613a45565b505f5460ff1615613b755768929eee149b4bd212685c80613a45565b68929eee149b4bd2126854613b0a565b602460106020939284936014526370a0823160601b5f525afa601f3d11166020510290565b7f000000000000000000000000000000000000000000000000000000000000000080600614613bfc57600514613bee57634e487b7160e01b5f52605160045260245ffd5b5f68929eee149b4bd212685d565b505f5460ff1615613c15575f68929eee149b4bd212685d565b5f68929eee149b4bd2126855565b903590601e19813603018212156107d357018035906001600160401b0382116107d3576020019160608202360383136107d357565b60a090604051907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208301527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d604083015260608201523060808201522090565b90604051915f516020615fa55f395f51905f525f525f516020615fc55f395f51905f526020525f516020615f855f395f51905f5260405260051b5191604052565b60a0906080604051917fe055493563385cc588fffacbffe2dab023fef807baa449530431169b0eeb5b69835260208301372090565b90613d5c6139d1565b613d7c613d7460a43560c43560e435612082876148dc565b923090613b85565b906040519063137c29fe82526080600460208401373060a083015260243560c083015260843560e0830152610140610120830152610160820190565b60807f63697069656e7429546f6b656e5065726d697373696f6e73286164647265737391609681527f436f6d706163744465706f736974207769746e65737329436f6d70616374446560208201527f706f736974286164647265737320616c6c6f6361746f722c75696e743820726560408201527f736574506572696f642c75696e74382073636f70652c6164647265737320726560608201527520746f6b656e2c75696e7432353620616d6f756e742960968201520152565b9093805f9493601c92869582613e86614eaf565b9987015260408387018360208201520137016024019101826e22d473030f116ddee9f6b43ac78ba35af11615613eb857565b3d6107cb57637f28c61e5f526004601cfd5b613ed8909291923090613b85565b9283811015613eec5761393f93039161437c565b63426d8dcf5f526004601cfd5b6affffffffffffffffffffff6a7fffffffffffffffffffff8260491c16818360481c16178060021c178060041c178060081c178060101c178060201c176755555555555555558160011c169003673333333333333333808260021c169116018060041c01670f0f0f0f0f0f0f0f660f0f0f0f0f0f0f8260081c169116018060101c01911690690fedcba9876543210000600f60581b91607f600319918060201c0116604803161c60581b161790565b6744036fc77deaed23605c1b81175415613fbf5750565b63cf90c3a85f526020526024601cfd5b604051916020526303f37b1a600c5280604052603760282090600182549160ff161b9080821661400157179055604052565b63dbc205b160601b600c526044601cfd5b916140206040820135614f51565b803590601e19813603018212156107d35701918235926001600160401b0384116107d3576020019280360384136107d35761393f93614069916140616137c8565b918585614f6c565b336150bc565b90929183159161408185826038615aa0565b9161409561408e84614862565b8092613fcf565b946001600160601b0360019316905b8084106140c257505050506140b557565b633a03d3bb5f526004601cfd5b90919293600190836001600160601b036140df8886896038615b0a565b1614151794019291906140a4565b919093928415926140ff868284615aa0565b9261410c61408e85614862565b956001600160601b0360019416915b81851061412d5750505050506140b557565b9091929394600190846001600160601b0361414a8987878b615b0a565b1614151795019392919061411b565b91905f5b81811061416d5750505050600190565b8061418c8461417f60019486896138cd565b60208101359035336141b4565b0161415d565b9190811015612a6d5760051b81013590603e19813603018212156107d3570190565b91929092604051908360148301526368a30dd082526034820194855260548201526058601c8201208242019262278d00811182548510176142295750829055607401526001600160a01b0316907ff78a2f33ff80ef4391f7449c748dc2d577a62cd645108f4f4069f4a7e0635b6a90606090a2565b631f9a96f45f526020526024601cfd5b939195909497969286019586359560208801359760608101359861425d89876152bf565b89811061429c575091614299999a93916142939593604060018060a01b03910135169760016001605c1b038a60a01c1690614c4a565b90615c31565b90565b8990633078b2f65f526020526040526044601cfd5b90916142bc81613ef9565b6744036fc77deaed23605c1b811754909118613fbf5760a01b9160fc1b9060ff1b171790565b6142eb82613ef9565b6744036fc77deaed23605c1b81175490921861430f57600360fc1b9160a01b171790565b5063cf90c3a85f526020526024601cfd5b61432981613ef9565b6744036fc77deaed23605c1b811754909118613fbf5760a01b600360fc1b1790565b9261435581613ef9565b6744036fc77deaed23605c1b811754909118613fbf5760a01b9160fc1b9060ff1b17171790565b909167edcaa89a8229394060205281601452825f5260405f208054908282019182106107655755335f5260205260018060a01b03165f5f516020615f655f395f51905f52604082a4565b939194925f9160208601925f935f9515908161481f575b85156147ce575b505f92801561473a575b5f1981011561469b575b83156145e1575b8415614460575050508184959697823701946e75696e7432353620616d6f756e7429600e8701527f29546f6b656e5065726d697373696f6e73286164647265737320746f6b656e2c5f19870152600e81870301905280850390209303902090565b91985096935083919450600e925060051b936e75696e7432353620616d6f756e7429838201527f29546f6b656e5065726d697373696f6e73286164647265737320746f6b656e2c5f19820152030190526040519261456d575b83156144f9575b5f516020615fa55f395f51905f525f525f516020615fc55f395f51905f526020525f516020615f855f395f51905f526040525191604052565b7f45012d42fad8c9e937cff5a2d750ee18713dd45aadcd718660d5523056618d995f527fc2e16a823b8cdddfdf889991d7a461f0a19faf1f8e608f1c164495a52151cc3e6020527fd2f6ad391328936f118250f231e63c7e639f9756a9ebf972d81763870a772d87604052805193506144c0565b7f2bf981c42c7f423b06fa49ba996d2930887e2f1f53d9a26b8c7423ac1cf83e615f527fd14445d78213a5acddfa89171b0199de521c3b36738b835264cae18f5a53dbf36020527f329b3c527a3c74b8cabc51c304669d1866b87352cafdf440ef2becd6dc261d1e604052805193506144b9565b7f4d756c7469636861696e436f6d7061637420636f6d70616374294d756c74696387527f6861696e436f6d7061637428616464726573732073706f6e736f722c75696e7460208801527f323536206e6f6e63652c75696e7432353620657870697265732c5365676d656e60408801526f5d20696473416e64416d6f756e74732c60708801527f697465722c75696e7432353620636861696e49642c75696e743235365b325d5b6060880152601a87019660900193506143ff565b7f4261746368436f6d7061637420636f6d70616374294261746368436f6d70616387527f74286164647265737320617262697465722c616464726573732073706f6e736f60208801527a75696e743235365b325d5b5d20696473416e64416d6f756e74732c605b8801527f722c75696e74323536206e6f6e63652c75696e7432353620657870697265732c60408801526015870196607b0193506143f8565b7f436f6d7061637420636f6d7061637429436f6d7061637428616464726573732087527f617262697465722c616464726573732073706f6e736f722c75696e743235362060208801526f2c75696e7432353620616d6f756e742c60508801527f6e6f6e63652c75696e7432353620657870697265732c75696e743235362069646040880152601087019660700193506143ee565b7569766174696f6e2875696e743235365b5d206964732c60368a01527f426174636841637469766174696f6e207769746e65737329426174636841637490526056880195506038880194505f6143e4565b686e743235362069642c60298a01527f41637469766174696f6e207769746e6573732941637469766174696f6e28756981526049890196506033890195506143dd565b6744036fc77deaed23605c1b81175491908215613fbf5750565b91906148883084613b85565b9260405194606052306040523360601b602c526323b872dd60601b600c5260205f6064601c82855af13d1560015f51141716156148cf5761393f945f606052604052613eca565b637939f4245f526004601cfd5b8060601b156148e85790565b63961c9a4f6040526024605cfd5b908015155f52602052337fe27f5e0382cf5347965fc81d5c81cd141897fe9ce402d22c496b7c2ddc84e5fd60405fa3565b6001600160401b0381116115a05760051b60200190565b9061494882614927565b61495560405191826135f9565b8281528092614966601f1991614927565b0190602036910137565b8051821015612a6d5760209160051b010190565b919261498e6139d1565b6001600160a01b03833516159260208101353490811415851690158514178315176139c45783926149c660843560a43560c4356142b1565b956149d08261493e565b94614a6d575b50848103956149e48761493e565b925f925f5b898110614a0857505050506149fb5790565b630f2f1e515f526004601cfd5b80614a598a600193979596970194614a29614a2487878a6138cd565b6137b4565b90848060a01b0382166001600160601b0360a01b8a1617988911151797614a5181978d614970565b523090613b85565b614a638289614970565b52019291926149e9565b614a799087349161437c565b835115612a6d578560208501525f6149d6565b91604051918360061b8460071b9160061b6024350163fe8ec1a7855260c06020860152816101400160408601526004356060860152826101600160a0860152606060e0860152604435610100860152606435610120860152856101408601528160248201610160870137818501956101608701525f5b828110614b185750939450508301610180019150565b806040918801306101808201526101a06044838601013591015201614b02565b83515f96909594939290875b878110614b5f575050505050505050613eec5761393f613baa565b80614ba783600193019a614b818c614b7c614a2430928c8b6138cd565b613b85565b90614b9d614b8f858c614970565b519183831015179d89614970565b519103908a61437c565b01614b44565b90614bb78261361a565b614bc460405191826135f9565b8281528092614966601f199161361a565b9015612a6d5790565b9190811015612a6d576060020190565b8160061b82810460401483151715611efe57614c0990614bad565b915f5b818110614c20575050506020815191012090565b80614c2e6001928486614bde565b604060208360061b880192803582850152013591015201614c0c565b60408401356001600160a01b031697969095939486948994919387358801936020890135890192909183359190614c8460808c0135614f51565b614c8d90614862565b6060819b013590614c9d91613fcf565b86811502019181151587841415179081159b614cd49961393f9d614cf0575b505050614cda575b5050508582359260200191614f6c565b846150bc565b614ce8926020018c89614f6c565b5f8080614cc4565b614d1b9350605892601c926040519260148401526368a30dd083526034830152605482015201205490565b4210155f898e614cbc565b98979380959196614d6b939894890198893581019860208a81019a359b013597614d63614d538d8d614bd5565b3560a01c60016001605c1b031690565b9d8e91615e45565b90614d768686614bd5565b95614d9f6020614d93878a35809b6040810135948591013561535c565b83151798868686615c31565b506001600160601b0360019916985b818110614dc7575050505050505061371291925061536d565b614dd2818389614bde565b80359889918860408201359b8c926020013592614dee9361535c565b8c8360a01c60016001605c1b03161415171798614e0d91878787615c31565b50600101614dae565b9015612a6d57803590605e19813603018212156107d3570190565b9190811015612a6d5760051b81013590605e19813603018212156107d3570190565b8160061b82810460401483151715611efe57614e6e90614bad565b915f5b818110614e85575050506020815191012090565b80614e936001928486614e31565b604060208360061b880192803582850152013591015201614e71565b7f0000000000000000000000000000000000000000000000000000000000000000613712576e22d473030f116ddee9f6b43ac78ba33b151590565b60a092916040606092815194848601525f516020615f455f395f51905f5285528560208601933385524684880152608087208752820101358101803560051b80916020018537602001852060808601525f516020615f855f395f51905f5285520190372090565b42811115614f5c5750565b63f80dbaea5f526020526024601cfd5b604080516119015f9081526020979097529181526042601e20918152919390929091606483019083146001600160a01b0386166041851481614fc7575b5050505050505033141715614fba57565b638baa579f5f526004601cfd5b909192939495975060405192885f5261506c575b61502d575b60209495965f60605282604052630b135d3f60e11b83526004830152602482019586946040865281604485015260648401375afa9051630b135d3f60e11b1416905f808080808080614fa9565b60408401355f1a60205260408481376020600160805f825afa5181183d1517614fe0575094505050506001915f6060526040525f808080808080614fa9565b60208581013560ff81901c601b01825286356040526001600160ff1b0316606052600160805f825afa5182183d1517614fdb57505094505050506001915f6060526040525f808080808080614fa9565b5f91825233926001600160a01b03908116929116907f770c32a2314b700d6239ee35ba23a9690f2fceb93a55d8c753e953059b3b18d490602090a4565b6040519260608401525f516020615f455f395f51905f5283526020830191338352466040850152608084209082019060a082013583019060c0823560051b93013560051b5f905f5b85811061517857505050505091604060609260a09594602001852060808601525f516020615f855f395f51905f5285520190372090565b8089016020848301870101358152828214615197575b50602001615141565b602090810185905292508261518e565b949195849197966151d4948101358101988960200199359a6151cc614d538d8d614e16565b988991615e45565b8515956001600160601b035f9416935b8181106151fb57505050505050506137129061536d565b806152498761520d600194868c614e31565b80359b8c8a60016001605c1b036152248c846153b0565b9260a01c16141517179b87602061523e604085018561377f565b9190940135936153c6565b50016151e4565b614299906152756040361517829060e0910160c08101355f52013560205260405f2090565b906031615651565b9291905f5b818110615290575050505050565b806152b86152a160019385896138cd565b8560206152ad836137b4565b920135913389615c31565b5001615282565b8160ff1c15901517156152cf5750565b63a06356f55f526020526024601cfd5b95849061530e9399949692968a01998a3597889660408d013583019a60016001605c1b038960a01c1691615e45565b9561531f60209261429998946152bf565b0135928035906020016153c6565b60a0916040519382019160c0830135019081359384930135855260208501526020016040840137604001902090565b9261536791926153b0565b91101790565b6140b557565b60c09160408051925f516020615fc55f395f51905f5284523360208501523382850152602081013560608501520135608083015260a08201522090565b60ff1c600281101561158c576001149015151690565b91949290925f958415945f5b81811061540157505050505050828210176153ee575050600190565b633078b2f65f526020526040526044601cfd5b8061543460209a988761542d61541a600196888d6138cd565b9d8e0135928c84019c8d10179b9d6137b4565b8789615c31565b50016153d2565b906040519160c08101350191823580937f4d756c7469636861696e436f6d7061637428616464726573732073706f6e736f83527f722c75696e74323536206e6f6e63652c75696e7432353620657870697265732c60208401527f5365676d656e745b5d207365676d656e7473295365676d656e7428616464726560408401527535365b325d5b5d20696473416e64416d6f756e74732c60768401527f737320617262697465722c75696e7432353620636861696e49642c75696e74326060840152602001609683013782604301605382012092609601902090565b614299903615906028615651565b906142996155386040361517846028615651565b928336159161532d565b61556d906155676080361517829060e0910160c08101355f52013560205260405f2090565b90615b8a565b9091565b61556d906155966040361517829060e0910160c08101355f52013560205260405f2090565b90615b66565b906142996155386155c46080361517859060e0910160c08101355f52013560205260405f2090565b846032615651565b90614299615538610b6b6040361517859060e0910160c08101355f52013560205260405f2090565b61561f906156196080361517829060e0910160c08101355f52013560205260405f2090565b90615bd9565b9192909190565b61561f9061564b60c0361517829060e0910160c08101355f52013560205260405f2090565b90615c0a565b91909180603214615764578060311461575757806030146157475780602b146157165780602f1461570957806028146156c857806033146156b057602a146156a757634e487b7160e01b5f52605160045260245ffd5b61429991615373565b5060e0910160c08101355f52013560205260405f2090565b5060c060e092606060408051948301925f516020615fa55f395f51905f52865233602087015201604085013760a081013560a0840152013560c08201522090565b5061429991361590614eea565b509060c091606060408051935f516020615fc55f395f51905f52855233602086015201604084013760a08201522090565b5061429991604036151790614eea565b50614299913615906150f9565b50614299916040361517906150f9565b9061010060405160a060c085013585019460608635967f436f6d70616374286164647265737320617262697465722c6164647265737320855260208501977f73706f6e736f722c75696e74323536206e6f6e63652c75696e7432353620657889528060408701927f70697265732c75696e743235362069642c75696e7432353620616d6f756e742c845260200184880137820185209788865233905260408301903760e0810135828401528381013560c0840152013560e0820152209190565b60e09092919260a06040519160c081013581019560608735977f4261746368436f6d70616374286164647265737320617262697465722c616464865260208601987f726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e74328a52656f756e74732c60468801528060408801927f353620657870697265732c75696e743235365b325d5b5d20696473416e64416d8452602001606689013760660186209889875233905260408401903782840152013560c0820152209190565b92919280602c146159df5760291461591d57634e487b7160e01b5f52605160045260245ffd5b6101009060a0604051918360c082013582019660608835987f436f6d70616374286164647265737320617262697465722c6164647265737320875260208701997f73706f6e736f722c75696e74323536206e6f6e63652c75696e743235362065788b528060408901927f70697265732c75696e743235362069642c75696e7432353620616d6f756e742c8452602001848a013782018720998a8852339052604085019037820160e081013584860152013560c0840152013560e0820152209190565b5060e09060a06040519160c081013581019560608735977f4261746368436f6d70616374286164647265737320617262697465722c616464865260208601987f726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e74328a52656f756e74732c60468801528060408801927f353620657870697265732c75696e743235365b325d5b5d20696473416e64416d8452602001606689013760660186209889875233905260408401903782840152013560c0820152209190565b91909180603814615af45780603914615ad857600714615ace57634e487b7160e01b5f52605160045260245ffd5b614299915f615651565b505f615aec9160016001605c1b0393614192565b3560a01c1690565b5015612a6d573560a01c60016001605c1b031690565b80603814615b525780603914615b3e57600714615b3557634e487b7160e01b5f52605160045260245ffd5b61429992615651565b5091615aec9160016001605c1b0393614192565b5091615aec9160016001605c1b03936138cd565b9190615b8690615b758461543b565b94908591604036151790602d615ce7565b9190565b9190615b8690615b998461543b565b94908591604036151790602e615ce7565b91615bba615b869284602c6158f7565b9290938460403615179161532d565b91615bba615b86928460296158f7565b91615b86604093615c0093615bed8261543b565b959091863615936080851786602d615ce7565b958691179161532d565b91615b86604093615c0093615c1e8261543b565b959091863615936080851786602e615ce7565b939291909380603514615cdd5780603414615c6a57603714615c6157634e487b7160e01b5f52605160045260245ffd5b614299936140ed565b5090929167edcaa89a8229394060205282601452835f5260405f20805480831183151761077257829003905581601452835f5260405f208054908282019182106107655755335f5260205260018060a01b03169060018060a01b03165f516020615f655f395f51905f5260405fa4600190565b5061429993613697565b9594939190929580602d14615dce57602e14615d1157634e487b7160e01b5f52605160045260245ffd5b6040519360608501528584525f516020615f455f395f51905f526020850196338852466040870152141580615dbf575b60051b60800184209083019060a082013584019060c0823560051b93013560051b5f905f5b858110615d9057505050505060609260a09596926040926020018620608087015285520190372090565b8089016020848301870101358152828214615daf575b50602001615d66565b6020908101859052925082615da6565b60a08401356080860152615d41565b5060609260a095969286604093845197878901528588525f516020615f455f395f51905f52602089019633885246878b0152141580615e37575b60051b60800188208852830101358201803560051b809160200186376020018620608087015285520190372090565b8285013560808a0152615e08565b969594939291909680602714615f315780602414615f1c5780602114615f075780602314615ef75780601f14615ee25780602614615ecf5780602214615ec45780602514615eb157601714615ea857634e487b7160e01b5f52605160045260245ffd5b61429996614c4a565b50906017959493929187614299986152df565b508661429997614239565b5090601795949392918761429998614d26565b50916142999691601796959493361593614d26565b5090614299969291361593614239565b509161429996916017969594933615936151a7565b509161429996916017969594933615936152df565b50906017959493929187614299986151a756fe295feb095767cc67d7e74695da0adaddede54d7b7194a8a5426fe8f0351e03371b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288595ca9a66b8bbf0d2316e90dfa3df465f0790b277b25393a3ef4d67e1f50865057cdca950b17b5efc016b74b912d8527dfba5e404a688cbc3dab16cb943287fec25a7fee8000a237929ef9be08f2933c4b4f320b00b38809f3c7aa104d5421049fa164736f6c634300081c000a60808060405234601557613e10908161001a8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c8062ad800c146137045780634e41a1fb146136965763d637ca8d14610039575f80fd5b3461367e57366003190160a0811261367e5760801361367e576040516080810181811067ffffffffffffffff82111761368257604052600435906001600160a01b0382169081830361367e57828152602435906001600160a01b038216820361367e576020810191825260443592600884101561367e576040820193845260643594600286101561367e5760608381019687521b6bffffffffffffffffffffffff191661366c575061011c6040516100f2604082613793565b600c81526b2730ba34bb32902a37b5b2b760a11b6020820152925b516001600160a01b03166138a1565b9251600881101561365857610130906139c8565b935160028110156136585761014490613bba565b8151610158906001600160a01b03166137b5565b825190919061016f906001600160a01b0316613834565b925163313ce56760049081525f81905260209182919082906001600160a01b0316620186a0fa3d601f10166020510260ff166101aa90613c59565b916040519560208701977103d913730b6b2911d101121b7b6b830b1ba160751b89528786518060208901603284015e810161088b60f21b603282015203603201601d19810189526002016101fe9089613793565b6040519460208601947f226465736372697074696f6e223a2022436f6d7061637420000000000000000086528451806020870160388a015e87016038810161040560f31b90528951908160208c01603a83015e01603801600281017f29207265736f75726365206c6f636b207769746820616c6c6f6361746f72200090528451908160208701602183015e0160020193601f85017401030b732103932b9b2ba103832b934b7b21037b31605d1b905287845160208601968188603483015e01601f0161088b60f21b601582015203601501601d19810189526002016102e39089613793565b6102ee608435613c59565b604051906102fd604083613793565b6002825261125160f21b602083015261031591613c9e565b9960405190610325604083613793565b600d82526c546f6b656e204164647265737360981b602083015261034891613c9e565b9560405190610358604083613793565b600a825269546f6b656e204e616d6560b01b602083015261037891613c9e565b9860405190610388604083613793565b600c82526b151bdad95b8814de5b589bdb60a21b60208301526103aa91613c9e565b92604051906103ba604083613793565b600e82526d546f6b656e20446563696d616c7360901b60208301526103de91613c9e565b90604051906103ee604083613793565b600982526820b63637b1b0ba37b960b91b602083015261040d91613c9e565b916040519061041d604083613793565b600582526453636f706560d81b602083015261043891613c9e565b9260405195610448604088613793565b600c875260208701906b14995cd95d0814195c9a5bd960a21b825260405190610472602083613793565b5f8252604051978893602085019a6f3d913a3930b4ba2fba3cb832911d101160811b8c52518091603087015e8401906c111610113b30b63ab2911d101160991b6030830152518092603d83015e0160300161227d60f01b600d82015281516020819301600f83015e01600d01600281015f905203600201601f19810186526104fa9086613793565b604051998a97602089019c8d6e2261747472696275746573223a205b60881b905280516020819201602f8c015e8901602f8101915f83528051926020849201905e01602f015f815281516020819301825e015f815281516020819301825e015f815281516020819301825e015f815281516020819301825e015f815281516020819301825e01905f8252518092825e01615d7d60f01b815203601d19810184526002016105a79084613793565b604051906105b76127c083613793565b61278e82527f22696d616765223a2022646174613a696d6167652f7376672b786d6c3b62617360208084019182527f6536342c5044393462577767646d567963326c76626a30694d5334774969426c6040808601919091527f626d4e765a476c755a7a306961584e764c5467344e546b744d53492f5067304b60608601527f504345744c5342485a57356c636d4630623349364945466b62324a6c49456c7360808601527f6248567a64484a68644739794944497a4c6a41754e53776755315a484945563460a08601527f63473979644342516248566e4c556c754943346755315a4849465a6c636e4e7060c08601527f62323436494459754d444167516e5670624751674d436b67494330745067304b60e08601527f50484e325a7942325a584a7a61573975505349784c6a4569494868746247357a6101008601527f50534a6f644852774f693876643364334c6e637a4c6d39795a7938794d4441776101208601527f4c334e325a79496765473173626e4d3665477870626d7339496d6830644841366101408601527f4c79393364336375647a4d7562334a6e4c7a45354f546b7665477870626d73696101608601527f49486739496a427765434967655430694d4842344967304b43534232615756336101808601527f516d393450534977494441674e446b79494451354d69496763335235624755396101a08601527f496d567559574a735a53316959574e725a334a766457356b4f6d356c647941776101c08601527f494441674e446b79494451354d6a7369494868746244707a6347466a5a5430696101e08601527f63484a6c63325679646d55695067304b5047636761575139496b31686333526c6102008601527f636c394d59586c6c636c3879496a344e436a77765a7a344e436a786e49476c6b6102208601527f50534a4d59586c6c636c3878496a344e43676b385a7a344e43676b4a5047632b6102408601527f44516f4a43516b385a7a344e43676b4a43516b385a7a344e43676b4a43516b4a6102608601527f50484268644767676333523562475539496d5a7062477774636e56735a54706c6102808601527f646d56756232526b4f324e7361584174636e56735a54706c646d56756232526b6102a08601527f4f325a7062477736497a49784d6a45794d54736949475139496b307a4d6a45756102c08601527f4d7a41344c4449354e4334344e6a526a4e53347a4e5449734e53347a4d6a67736102e08601527f4f5334304e5459734d5449754d5451304c4445314c6a63354d6977344c6a677a6103008601527f4d67304b43516b4a43516b4a597a49754e4451344c5445754d6a63794c4455756103208601527f4d4459304c544d754d446b324c4463754d7a49744e5334794e545a6a4d7934336103408601527f4e4451744d7934314e7a59734f4334794e5459744f5334314d6a67734e4334326103608601527f4e5459744d5451754d6a686a4c5445794c6a51314e6930784d5334354e7a59746103808601527f4d7a59754d7a67304c544d794c6a45784d69307a4e6934304e5459744d7a49756103a08601527f4d54594e43676b4a43516b4a435777334c6a55324c5467754e545934597a41756103c08601527f4d4449304c4441754d4449304c4455754d5459734e4334314d7a59734d5445756103e08601527f4f444d794c4445774c6a67794e474d344c6a59344f4377344c6a49774f4377796104008601527f4d4334344e5459734d5459754d6977794e6934334d7a59734d6a51754e4441346104208601527f44516f4a43516b4a43516c6a4d79347a4d5449734e4334324d4467734d6934326104408601527f4d5459734d5449754e7a51304c4441754f4459304c4445334c6a5579597930786104608601527f4c6a4d354d69777a4c6a67304c5451754d5441304c4463754e4459304c5463756104808601527f4d7a49734d5441754e544d325979307a4c6a41794e4377794c6a6b774e4330326104a08601527f4c6a59734e5334304c546b754f5459734e7934784d6a674e43676b4a43516b4a6104c08601527f43574d744d79347a4f4451734d5334334e5449744e6934334f5449734d6934336104e08601527f4e6930354c6a59354e6977794c6a63344e474d744d4334774f5459734d4334306105008601527f4e5459744d4334794d5459734d4334354d7a59744d43347a4d7a59734d53347a6105208601527f4f544a6a4c5441754f5459734d7934794e43307a4c6a41794e4377324c6a41336105408601527f4d6930314c6a59784e6977344c6a514e43676b4a43516b4a43574d744d69347a6105608601527f4d6a67734d6934774f4467744e5334784d7a59734d7934344d5459744e7934356105808601527f4e4451734e5334774e6a526a4c544d754d4463794c4445754d7a51304c5459756105a08601527f4d6a67344c4449754d5445794c546b754d5459344c4449754d545a6a4c5441756105c08601527f4d446b324c4441754f544d324c5441754d6a67344c4445754f4451344c5441756105e08601527f4e5455794c4449754e7a594e43676b4a43516b4a43574d744d4334354e69777a6106008601527f4c6a49304c544d754d4449304c4459754d4463794c5455754e6a45324c4467756106208601527f4e474d744d69347a4d6a67734d6934774f4467744e5334784d7a59734d7934346106408601527f4d5459744e7934354e4451734e5334774e6a526a4c5451754d5449344c4445756106608601527f4f4449304c5467754e5451304c4449754e5459344c5445794c4445754f5459346106808601527f44516f4a43516b4a43516c6a4c5441754d5449734d5334794d6a51744d43347a6106a08601527f4e6977794c6a51744d4334324f5459734d7934314d4452324d4334774d6a526a6106c08601527f4c5445754d444d794c444d754d7a67304c544d734e6934794e4330314c6a55796106e08601527f4c4467754d7a5579597930794c6a55794c4449754d5445794c5455754e546b796107008601527f4c444d754e4467744f4334344e5459734d7934354d7a594e43676b4a43516b4a6107208601527f43574d744d7934354e6977774c6a55314d6930344c6a45324c5441754d6a51746107408601527f4d5445754f5441304c5449754e6a6734597930784c6a417a4d6930774c6a59336107608601527f4d6930794c6a45324c5445754e544d324c544d754e4467744d6934314f544a736107808601527f4c5441754e7a51304c5441754e546332624330784d5334784e6930344c6a59786107a08601527f4e6d77324c6a6b324c546b754d444930624445784c6a45324c4467754e6a45326107c08601527f44516f4a43516b4a43516c734d4334334e4451734d4334314e7a5a6a4d5334776107e08601527f4d7a49734d4334334f5449734d5334344f5459734d5334304f4467734d6934336108008601527f4f4451734d6934774e474d784c6a49354e6977774c6a67324e4377794c6a637a6108208601527f4e6977784c6a45794f4377304c6a41344c4441754f545a6a4d5334784d6a67746108408601527f4d4334784e6a67734d6934784f4451744d4334324e4467734d7934774e7a49746108608601527f4d53347a4f54494e43676b4a43516b4a43574d774c6a67324e4330774c6a63796108808601527f4c4445754e5459744d5334334d6a67734d5334354d6930794c6a6b774e4777776108a08601527f4c44426a4d4334304e5459744d5334314e6977774c6a4d344e43307a4c6a55776108c08601527f4e4330774c6a51314e6930314c6a6332597930354c6a55794f4330784d7934796108e08601527f4f5459744d6a6b754e4451344c5449354c6a51794e4330794f5334304f5459746109008601527f4d6a6b754e44637944516f4a43516b4a43516c734e7934794c5467754f4455326109208601527f597a41754d4451344c4441754d4449304c4467754d5445794c4459754e5463326109408601527f4c4445324c6a63314d6977784e5334774d6a526a4d69347a4d4451734d6934796109608601527f4e5459734e4334344e4467734e4334334e5449734e7934314d5449734e7934786109808601527f4d6a686a4d4334304f4377774c6a517a4d6977774c6a6b344e4377774c6a67326109a08601527f4e4377784c6a51324e4377784c6a49354e67304b43516b4a43516b4a624441736109c08601527f4d4777774c44426a4d4334774f5459734d4334774f5459734d4334794d5459736109e08601527f4d4334784f5449734d43347a4d5449734d4334794f44686a4d4334324d6a5173610a008601527f4d4334314e5449734d5334794e4467734d5334784d6a67734d5334344e7a4973610a208601527f4d5334334d44526a4d6934784d5449734d5334344f5459734e4334794c444d75610a408601527f4f4445324c4459754d7a67304c4455754e446b3244516f4a43516b4a43516c6a610a608601527f4d6934314f5449734d5334344e4467734d6934314e4451734d6934794d7a4973610a808601527f4e5334304f5459734d53347a4e44526a4d4334324d6a51744d4334784f544973610aa08601527f4d5334794f5459744d4334314d6a67734d6934774d5459744d4334344e474d78610ac08601527f4c6a63334e6930774c6a63324f43777a4c6a55774e4330784c6a67304f437730610ae08601527f4c6a67354e69307a4c6a41354e67304b43516b4a43516b4a597a45754d544934610b008601527f4c5445754d444d794c4445754f546b794c5449754d5445794c4449754d7a4130610b208601527f4c544d754d545934597a41754d6a51744d4334344e4377774c6a41334d693078610b408601527f4c6a67304f4330774c6a63304e4330794c6a6b334e6d4d744f5334314e7a5974610b608601527f4d544d754d7a49744d7a55754f5441304c544d324c6a51314e69307a4e533435610b808601527f4e7a59744d7a59754e544934624463754e5459744f4334314e6a674e43676b4a610ba08601527f43516b4a43574d774c6a41304f4377774c6a41304f4377784e4334324f446773610bc08601527f4d5449754f5445794c4449324c6a59784e6977794e5334304f44686a4d793479610be08601527f4e43777a4c6a45354d6977344c6a41324e4377334c6a55324c4445784c6a5530610c008601527f4e4377784d4334794e7a4a6a4d5334794e7a49734d4334354d5449734d693478610c208601527f4e6977794c6a41344f4377304c6a41344c4445754e44453244516f4a43516b4a610c408601527f43516c6a4d4334344d5459744d4334794f4467734d5334344e4467744d433432610c608601527f4f5459734d7930784c6a4a6a4d5334334e7a59744d4334334e6a67734d793431610c808601527f4d4451744d5334344e4467734e4334344f5459744d7934774f545a6a4d533478610ca08601527f4d6a67744d5334774d4467734d5334354f5449744d6934784d5449734d69347a610cc08601527f4d4451744d7934784e6a674e43676b4a43516b4a43574d774c6a49304c544175610ce08601527f4f4451734d4334774e7a49744d5334344e4467744d4334334e4451744d324d74610d008601527f4f5334314e7a59744d544d754d7a49744d7a55754f5441304c544d324c6a5131610d208601527f4e69307a4e5334354e7a59744d7a59754e544934624463754e5459744f433431610d408601527f4e6a674e43676b4a43516b4a43554d794f5449754d6a49734d6a59324c6a5934610d608601527f4f43777a4d446b754d4451304c4449344d5334304f5459734d7a49784c6a4d77610d808601527f4f4377794f5451754f445930656949765067304b43516b4a435477765a7a344e610da08601527f43676b4a43516b385a7a344e43676b4a43516b4a504842686447676763335235610dc08601527f62475539496d5a7062477774636e56735a54706c646d56756232526b4f324e73610de08601527f61584174636e56735a54706c646d56756232526b4f325a7062477736497a4978610e008601527f4d6a45794d54736949475139496b30304d6a6b754d4449734d6a55304c6a5179610e208601527f4e45777a4f544d754e6a6b794c4445794f5334334d6d77744d5334314d7a5974610e408601527f4e5334304e4468734c5455754e4451344c4445754e44673444516f4a43516b4a610e608601527f43516c734c5451314c6a49784e6977784d6934304d4468734c5455754e545934610e808601527f4c4445754e544d32624445754e5459734e5334314d6d77794c6a457a4e697733610ea08601527f4c6a557a4e6d4d744d6a45754e6a6b324c4445754f5459344c5451794c6a6730610ec08601527f4c5449754e6a59304c5459794c6a55324f4330324c6a6b3244516f4a43516b4a610ee08601527f43516c6a4c544d354c6a49324e4330344c6a55324f4330334d7934794f545974610f008601527f4d5455754f5467304c546b354c6a55334e6977794e5334344f545a734d437777610f208601527f597930334c6a45774e4377784d53347a4e5449744d5451754f4455324c444930610f408601527f4c6a67304c5445324c6a59314e69777a4e5334784e67304b43516b4a43516b4a610f608601527f597930794c6a51334d6977784e4334774e43777a4c6a41794e4377794d793477610f808601527f4e4377794e5334794e4467734d5467754f545a6a4d544d754e6a55324c544975610fa08601527f4e446b324c4449794c6a41344c546b754d7a59734d6a6b754f5449344c544531610fc08601527f4c6a63324f474d344c6a67344c5463754d6a51344c4445324c6a67334d693078610fe08601527f4d7934334e5449734d7a49754d7a63324c546b754d54513044516f4a43516b4a6110008601527f43516c6a4f4334784d7a59734d79347a4e6977344c6a67344c444d754e6a63796110208601527f4c4445314c6a49304c446b754d444930597a49784c6a45304e4377784e7934336110408601527f4d7a59734e7a45754e4377324d5334314d7a59734e7a49734e6a49754d4452736110608601527f4d437777624445774c6a51784e6977354c6a45324f4777794c6a6b774e4377796110808601527f4c6a55304e47777a4c6a517a4d6930784c6a63314d67304b43516b4a43516b4a6110a08601527f624449774c6a67344c5445774c6a59774f4777784c6a49334d6977304c6a51346110c08601527f4f4777314c6a51334d6930784c6a5532624451314c6a41354e6930784d6934336110e08601527f4e6a68734e5334304f5459744d5334314e6b77304d6a6b754d4449734d6a55306111008601527f4c6a51794e4577304d6a6b754d4449734d6a55304c6a51794e486f6754544d316111208601527f4d4334324d7a59734d6a59354c6a6b334e6d77744e7934314d5449744e6934326111408601527f44516f4a43516b4a43516c494d7a517a4c6a466a4c5441754d5451304c5441756111608601527f4d5449744e5445754e6a49304c5451314c5463794c6a45354d6930324d6934796111808601527f4d7a4a6a4c5463754e7a41304c5459754e4455324c5467754e5459344c5459756111a08601527f4f4445324c5445344c6a4d324c5445774c6a67334d6d77744d4334794e4330776111c08601527f4c6a41354e6d77744d4334314d6a67744d4334784f54494e43676b4a43516b4a6111e08601527f43574d744d6a45754d7a59744e6934304e5459744d7a45754e6a41344c4445756112008601527f4f5449744e4449754f5467304c4445784c6a49774f474d744e6934334e6a67736112208601527f4e5334314d6930784d7934354f5449734d5445754e4449304c5449304c6a63326112408601527f4f4377784d79347a4f544a6a4c5445774c6a41344c4445754f4451344c5445796112608601527f4c6a63324f4330784c6a417a4d6930784d5334354d6a67744e5334334f44514e6112808601527f43676b4a43516b4a43574d784c6a51344f4330344c6a51334d6977344c6a55306112a08601527f4e4330794d4334324e6a51734d5455754d4451344c544d784c6a41314e6e59746112c08601527f4d4334774d6a526a4d6a45754f5459744d7a55754d4459304c4455794c6a4d356112e08601527f4d6930794f4334304e4377344e7934304f4330794d4334334f44514e43676b4a6113008601527f43516b4a43574d794d5334784f5449734e4334324d4467734e444d754f5451306113208601527f4c446b754e5463324c4459344c6a45324c4459754f544d32624449334c6a49326113408601527f4e4377354e6934794e45777a4e5441754e6a4d324c4449324f5334354e7a5a4d6113608601527f4d7a55774c6a597a4e6977794e6a6b754f5463326569424e4d7a67794c6a4d326113808601527f4e4377794e6a45754e6a6b3254444d314d4334774e6977784e4463754e6a49316113a08601527f44516f4a43516b4a43516c734d7a51754d6930354c6a4d344e47777a4d6934796113c08601527f4d7a49734d54457a4c6a63344e45777a4f4449754d7a59304c4449324d5334326113e08601527f4f545a364969382b44516f4a43516b4a5043396e5067304b43516b4a4354786e6114008601527f5067304b43516b4a43516b38634746306143427a64486c735a5430695a6d6c736114208601527f624331796457786c4f6d56325a5735765a47513759327870634331796457786c6114408601527f4f6d56325a5735765a4751375a6d6c7362446f6a4d6a45794d5449784f7949676114608601527f5a443069545445314e5334774d544d734d5451314c6a4a734c5449754d6a67736114808601527f4f4334774d54594e43676b4a43516b4a43574d784d4334794d6a51734d4334796114a08601527f4d5459734d6a6b754e546b794c4441754d4451344c4451314c6a63794c544d756114c08601527f4e6d77794c6a51354e6977784d5334784d7a5a6a4c5445344c6a6b324c4451756114e08601527f4d6a6b324c5451784c6a67774f4377304c6a45774e4330314d5334304d4467736115008601527f4d7934334f544a734c5449314c6a51344f4377344f5334354e7a594e43676b4a6115208601527f43516b4a43574d354c6a59334d69777a4c6a41304f4377794e7934344f4467736115408601527f4d5441754f5459344c4449354c6a4d314d6977794e7934334d6d77744d5445756115608601527f4e4377774c6a6b344e474d744d4334344f4467744d5441754d5455794c54457a6115808601527f4c6a63794f4330784e5334314d4451744d6a45754d4463794c5445334c6a63326115a08601527f624330784c6a4d324f4377304c6a67794e4777744d5334314e6977314c6a51356115c08601527f4e67304b43516b4a43516b4a624330314c6a51334d6930784c6a5532624330306115e08601527f4e5334774f5459744d5449754e7a5934624330314c6a51354e6930784c6a55326116008601527f624445754e5459744e5334304e7a4a734d7a55754d7a49344c5445794e4334336116208601527f4d4452734d5334314d7a59744e5334304e4468734e5334304e4467734d5334306116408601527f4f4468734e4455754d6a45324c4445794c6a51774f4777314c6a55324f4377786116608601527f4c6a557a4e67304b43516b4a43516b4a544445314e5334774d544d734d5451316116808601527f4c6a4a4d4d5455314c6a41784d7977784e4455754d6b77784e5455754d44457a6116a08601527f4c4445304e5334796569424e4d5445774c6a45314e7977794e6a45754e6a6b326116c08601527f62444d794c6a4d774e4330784d5451754d4463796243307a4e4334794c546b756116e08601527f4d7a6730544463324c6a41794f5377794e5449754d444930544445784d4334786117008601527f4e5463734d6a59784c6a59354e6e6f694c7a344e43676b4a43516b384c32632b6117208601527f44516f4a43516b4a5047632b44516f4a43516b4a435478775958526f49484e306117408601527f6557786c50534a6d615778734c584a31624755365a585a6c626d396b5a44746a6117608601527f62476c774c584a31624755365a585a6c626d396b5a44746d615778734f694d796117808601527f4d5449784d6a45374969426b50534a4e4d6a51774c6a63324e43777a4d7a59756117a08601527f4e6a6379544449304d4334334e6a51734d7a4d324c6a59334d67304b43516b4a6117c08601527f43516b4a597930784c6a45774e4330774c6a67784e6930794c6a51304f4330786117e08601527f4c6a41344c544d754e7a51304c5441754f446734637930794c6a51354e6977776118008601527f4c6a67324e43307a4c6a4d784d6977784c6a6b304e4777744f4334344d7a49736118208601527f4d5445754f546332614441754d444930597930774c6a67784e6977784c6a45776118408601527f4e4330784c6a45774e4377794c6a51334d6930774c6a6b784d69777a4c6a63306118608601527f4e41304b43516b4a43516b4a597a41754d546b794c4445754d6a63794c4441756118808601527f4f4459304c4449754e4463794c4445754f5451304c444d754d6a6734624441756118a08601527f4d5459344c4441754d545130597a45754d4455324c4441754e7a49734d69347a6118c08601527f4e5449734d4334354e69777a4c6a55334e6977774c6a63324f474d784c6a49356118e08601527f4e6930774c6a45354d6977794c6a51354e6930774c6a67324e43777a4c6a4d786119008601527f4d6930784c6a6b304e41304b43516b4a43516b4a624467754f4455324c5445796119208601527f597a41754f4445324c5445754d5441304c4445754d4467744d6934304e4467736119408601527f4d4334344f4467744d7934334e4452444d6a51794c6a55784e69777a4d7a67756119608601527f4e6a67344c4449304d5334344e4451734d7a4d334c6a51344f4377794e4441756119808601527f4e7a59304c444d7a4e6934324e7a4a4d4d6a51774c6a63324e43777a4d7a59756119a08601527f4e6a637944516f4a43516b4a43516c4d4d6a51774c6a63324e43777a4d7a59756119c08601527f4e6a63796569424e4d5463324c6a51794d5377794e6a59754d6a686a4e4334796119e08601527f4d6a51734d7934784d6977324c6a67784e6977334c6a59344c4463754e544d32611a008601527f4c4445794c6a55774e474d774c6a4d784d6977794c6a41324e4377774c6a4934611a208601527f4f4377304c6a45334e6930774c6a41354e6977324c6a493044516f4a43516b4a611a408601527f43516c6a4d5334344f5459744d4334354e69777a4c6a6b7a4e6930784c6a5977611a608601527f4f4377324c6a41794e4330784c6a6b79597a55754d4445324c5441754e7a5130611a808601527f4c4445774c6a49354e6977774c6a4d344e4377784e4334324f4467734d793432611aa08601527f4d6a52324d4334774d6a526a4e4334304d5459734d7934794e4377334c6a4134611ac08601527f4c4463754f5459344c4463754f4449304c4445794c6a6b344e41304b43516b4a611ae08601527f43516b4a597a41754d7a45794c4445754f546b794c4441754d6a67344c445175611b008601527f4d444d794c5441754d4449304c4459754d445134597a41754e6930774c6a4530611b208601527f4e4377784c6a45334e6930774c6a49324e4377784c6a63334e6930774c6a4d32611b408601527f597a51754e544d324c5441754e6a63794c446b754d7a4d324c4441754d7a5973611b608601527f4d544d754d6a6b324c444d754d6a6734624441754d6a67344c4441754d6a514e611b808601527f43676b4a43516b4a43574d7a4c6a67784e6977794c6a6b794f4377324c6a4530611ba08601527f4e4377334c6a45794f4377324c6a67784e6977784d5334314d6d4d774c6a4978611bc08601527f4e6977784c6a4d324f4377774c6a49324e4377794c6a63324c4441754d545130611be08601527f4c4451754d545579597a41754d6a45324c5441754d4451344c4441754e444134611c008601527f4c5441754d4463794c4441754e6a49304c5441754d446b3244516f4a43516b4a611c208601527f43516c6a4e4334784d6a67744d4334324d6a51734f4334314e4451734d43347a611c408601527f4d7a59734d5449754d546b794c444d754d444930624441734d474d7a4c6a5933611c608601527f4d6977794c6a63784d6977314c6a67344c4459754e6a49304c4459754e544130611c808601527f4c4445774c6a63334e6d4d774c6a59794e4377304c6a45794f4330774c6a4d7a611ca08601527f4e6977344c6a55304e43307a4c6a41304f4377784d6934784f54494e43676b4a611cc08601527f43516b4a435777744f4334344e5459734d544a6a4c5449754e7a45794c444d75611ce08601527f4e6a63794c5459754e6a49304c4455754f4467744d5441754e7a63324c445975611d008601527f4e544130597930304c6a45794f4377774c6a59794e4330344c6a55794c544175611d208601527f4d7a4d324c5445794c6a45354d69307a4c6a41794e4859774c6a41794e41304b611d408601527f43516b4a43516b4a5979307a4c6a59304f4330794c6a59344f4330314c6a6734611d608601527f4c5459754e6a49304c5459754e5441304c5445774c6a686a4c5441754d446379611d808601527f4c5441754e4467744d4334784d6930774c6a6b324c5441754d5451304c544575611da08601527f4e44526a4c5445754d4441344c4441754d7a4d324c5449754d4451734d433432611dc08601527f4c544d754d4463794c4441754e7a513044516f4a43516b4a43516c6a4c545175611de08601527f4e5445794c4441754e6a63794c546b754d7a45794c5441754d7a59744d544d75611e008601527f4d6a6b324c544d754d7a4579624441734d474d744d7934354f4451744d693435611e208601527f4e5449744e6934304d4467744e7934794d6a51744e7934774f4330784d533433611e408601527f4d7a5a6a4c5441754d5451304c5441754f5445794c5441754d6a45324c544575611e608601527f4f4449304c5441754d546b794c5449754e7a594e43676b4a43516b4a43574d74611e808601527f4d5334314d5449734d4334324d6a51744d7934774e7a49734d5334774f433030611ea08601527f4c6a59344c4445754d7a4a6a4c5455754d4445324c4441754e7a51304c544577611ec08601527f4c6a49354e6930774c6a4d344e4330784e4334324f4467744d7934324d6a5273611ee08601527f4d437777597930304c6a4d354d69307a4c6a49304c5463754d4467744e793435611f008601527f4f5449744e7934344d6a51744d544d754d44413444516f4a43516b4a43516c6a611f208601527f4c5441754d7a67304c5449754e4463794c5441754d6a67344c5455754d444532611f408601527f4c4441754d7a45794c5463754e446734597930784c6a55344e4377774c6a6379611f608601527f4c544d754d6a59304c4445754d6930304c6a6b324f4377784c6a51324e474d74611f808601527f4e4334344d6a51734d4334334d6930354c6a6b784d6930774c6a4d344e433078611fa08601527f4e4334784d7a59744d7934304f41304b43516b4a43516b4a597930304c6a4979611fc08601527f4e43307a4c6a45794c5459754f4445324c5463754e6a67744e7934314d7a5974611fe08601527f4d5449754e544130637a41754d7a67304c546b754f5445794c444d754e4467746120008601527f4d5451754d544d32614441754d444930624445774c6a6b354d6930784e4334356120208601527f4d44526a4d7934784d6930304c6a49304f4377334c6a59344c5459754f4445326120408601527f4c4445794c6a51344c5463754e544d3244516f4a43516b4a43516c444d5459336120608601527f4c6a41344e5377794e6a49754d4455324c4445334d6934784e7a4d734d6a597a6120808601527f4c6a45324c4445334e6934304d6a45734d6a59324c6a4934544445334e6934306120a08601527f4d6a45734d6a59324c6a4934544445334e6934304d6a45734d6a59324c6a49346120c08601527f544445334e6934304d6a45734d6a59324c6a49346569424e4d5463794c6a59316120e08601527f4d7977794f4441754e44593044516f4a43516b4a43516c6a4c5441754d6a67346121008601527f4c5445754f5451304c5445754d7a49744d7934334e6a67744d6934354e7a59746121208601527f4e4334354f544a324c5441754d444930597930784c6a59344c5445754d6a49306121408601527f4c544d754e7a49744d5334324e5459744e5334324f4467744d53347a4e6a686a6121608601527f4c5445754f5459344c4441754d6a67344c544d754e7a6b794c4445754d7a49746121808601527f4e5334774d5459734d6934354e7a594e43676b4a43516b4a435777744d5441756121a08601527f4f546b794c4445304c6a6734614441754d444930597930784c6a49304f4377786121c08601527f4c6a59344c5445754e6a67734d7934334e4451744d53347a4f5449734e5334326121e08601527f4f44686a4d4334794f4467734d5334354e4451734d53347a4d69777a4c6a63326122008601527f4f4377794c6a6b334e6977304c6a6b354d67304b43516b4a43516b4a597a45756122208601527f4e6a67734d5334794e4467734d7934334e4451734d5334324f4377314c6a59346122408601527f4f4377784c6a4d354d6e4d7a4c6a63324f4330784c6a4d794c4451754f546b796122608601527f4c5449754f546332624441754d4449304c4442734d5441754f546b794c5445306122808601527f4c6a6734614330774c6a41794e41304b43516b4a43516b4a517a45334d6934306122a08601527f4f4455734d6a67304c6a51334d6977784e7a49754f5451784c4449344d6934306122c08601527f4d4467734d5463794c6a59314d7977794f4441754e445930544445334d6934326122e08601527f4e544d734d6a67774c6a51324e4577784e7a49754e6a557a4c4449344d4334306123008601527f4e6a5236494530794d4445754d446b794c444d774d5334304d54594e43676b4a6123208601527f43516b4a43574d744d43347a4d5449744d6934784d7a59744d5334304e4330306123408601527f4c6a45314d69307a4c6a49324e4330314c6a51354e6e59774c6a41794e474d746123608601527f4d5334344e4467744d53347a4e6a67744e4334784d4451744d5334344e4467746123808601527f4e6934794e4330784c6a557a4e6d4d744d6934784e6977774c6a4d7a4e6930306123a08601527f4c6a45314d6977784c6a51304c5455754e5449734d7934794e6a514e43676b4a6123c08601527f43516b4a435777744d5445754e6a45324c4445314c6a63304e474d744d53347a6123e08601527f4e4451734d5334344e4467744d5334344d6a51734e4334784d4451744d5334316124008601527f4d5449734e6934794e474d774c6a4d784d6977794c6a457a4e6977784c6a51306124208601527f4c4451754d5449344c444d754d6a59304c4455754e446b32624441734d41304b6124408601527f43516b4a43516b4a597a45754f4451344c4445754d7a59344c4451754d5441306124608601527f4c4445754f4451344c4459754d6a51734d5334314d7a5a6a4d6934784e6930776124808601527f4c6a4d784d6977304c6a45314d6930784c6a51304c4455754e5449744d7934796124a08601527f4e6a52734d437777624445784c6a59784e6930784e5334334e44514e43676b4a6124c08601527f43516b4a43554d794d4441754f5451344c444d774e5334344d7a49734d6a41786124e08601527f4c6a51794f43777a4d444d754e5463324c4449774d5334774f5449734d7a41786125008601527f4c6a51784e6b77794d4445754d446b794c444d774d5334304d545a4d4d6a41786125208601527f4c6a41354d69777a4d4445754e4445326569424e4d6a497a4c6a49304e43777a6125408601527f4d6a49754d54557944516f4a43516b4a43516c6a4c5441754d6a51744d5334326125608601527f4f4330784c6a45774e43307a4c6a49304c5449754e5449744e4334794e7a4a326125808601527f4d4334774d6a526a4c5445754e4451744d5334774e5459744d7934784f5449746125a08601527f4d5334304e4330304c6a67304f4330784c6a45334e6d4d744d5334324e5459736125c08601527f4d4334794e43307a4c6a49784e6977784c6a45774e4330304c6a49304f4377796125e08601527f4c6a55304e4777744d4334784f5449734d4334794e41304b43516b4a43516b4a6126008601527f624330354c6a67344f4377784d7934304d545a324d4334774d6a526a4c5445756126208601527f4d4455324c4445754e4445324c5445754e4445324c444d754d5459344c5445756126408601527f4d5455794c4451754f444930597a41754d6a59304c4445754e6a67734d5334786126608601527f4d6a67734d7934794e4377794c6a55304e4377304c6a49334d6d77774c44414e6126808601527f43676b4a43516b4a43574d784c6a51784e6977784c6a41314e69777a4c6a45326126a08601527f4f4377784c6a51784e6977304c6a67304f4377784c6a45314d6d4d784c6a59346126c08601527f4c5441754d6a59304c444d754d6a51744d5334784d6a67734e4334794e7a49746126e08601527f4d6934314e44524d4d6a49794c6a45304d53777a4d6a634e43676b4a43516b4a6127008601527f43554d794d6a4d754d5449304c444d794e5334314f4451734d6a497a4c6a55776127208601527f4f43777a4d6a4d754f444d794c4449794d7934794e4451734d7a49794c6a45316127408601527f4d6e6f694c7a344e43676b4a43516b384c32632b44516f4a43516b384c32632b6127608601527f44516f4a435477765a7a344e43676b384c32632b44516f384c32632b44516f386127808601526d130cd38c969e8d1390d9cf4f488b60921b6127a086015251975197988998929592918291908a015e87019060208201905f8252519283915e01602001905f8252518092825e01905f8252518092825e015f815203601f19810182526136469082613793565b604051613654819282613769565b0390f35b634e487b7160e01b5f52602160045260245ffd5b61367861011c916138a1565b9261010d565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b3461367e57602036600319011261367e5761365460206136f860256136c56004356001600160a01b0316613834565b60405164f09fa49d2d60d81b858201528151909485928291018484015e81015f838201520301601f198101835282613793565b60405191829182613769565b3461367e57602036600319011261367e5761365460206136f860286137336004356001600160a01b03166137b5565b60405193849167021b7b6b830b1ba160c51b828401528051918291018484015e81015f838201520301601f198101835282613793565b602060409281835280519182918282860152018484015e5f828201840152601f01601f1916010190565b90601f8019910116810190811067ffffffffffffffff82111761368257604052565b6001600160a01b03811615613810576137d9906306fdde0360045260045f52613d42565b908151156137e357565b90506040516137f3604082613793565b600d81526c3ab735b737bbb7103a37b5b2b760991b602082015290565b5060405161381f604082613793565b600581526422ba3432b960d91b602082015290565b8060601b1561387f57613852906395d89b4160045260045f52613d42565b9081511561385c57565b905060405161386c604082613793565b60038152623f3f3f60e81b602082015290565b5060405161388e604082613793565b600381526208aa8960eb1b602082015290565b9060405191608083016040526f30313233343536373839616263646566600f526002830190602882525f604a85015260601b60015f5b8080018601602284831a600f811651602384015360041c5191015301906014821461390557906001906138d7565b50506130786002825101915282528160228101907f8888888888888888888888888888888888888888888888888888888888888880602883201660015f5b601160f31b83821a02818001520190601482146139635790600190613943565b505060429180517f2020202020202020202020202020202020202020202020202020202020202020815f511660011c161890520180517f2020202020202020202020202020202020202020202020202020202020202020816020511660011c16189052565b600881101561365857806139ff57506040516139e5604082613793565b600a81526913db99481cd958dbdb9960b21b602082015290565b60018103613a355750604051613a16604082613793565b600f81526e4669667465656e207365636f6e647360881b602082015290565b60028103613a665750604051613a4c604082613793565b600a8152694f6e65206d696e75746560b01b602082015290565b60038103613a985750604051613a7d604082613793565b600b81526a54656e206d696e7574657360a81b602082015290565b60048103613adc5750604051613aaf604082613793565b601981527f4f6e6520686f757220616e642066697665206d696e7574657300000000000000602082015290565b60058103613b0a5750604051613af3604082613793565b60078152664f6e652064617960c81b602082015290565b60068103613b4e5750604051613b21604082613793565b601781527f536576656e206461797320616e64206f6e6520686f7572000000000000000000602082015290565b600703613b7e57604051613b63604082613793565b600b81526a546869727479206461797360a81b602082015290565b60405162461bcd60e51b8152602060048201526014602482015273155b9adb9bdddb881c995cd95d081c195c9a5bd960621b6044820152606490fd5b60028110156136585780613bf15750604051613bd7604082613793565b600a81526926bab63a34b1b430b4b760b11b602082015290565b600103613c2457604051613c06604082613793565b600e81526d436861696e2d737065636966696360901b602082015290565b60405162461bcd60e51b815260206004820152600d60248201526c556e6b6e6f776e2073636f706560981b6044820152606490fd5b90604051600a608082019360a083016040525f8552935b5f190193603082820601855304928315613c8c57600a90613c70565b809350608091030191601f1901918252565b6002613d3f91600d602094604051613cb7604082613793565b6001815260308780830193600b60fa1b8552604051998a976f3d913a3930b4ba2fba3cb832911d101160811b828a0152805191829101858a015e8701906c111610113b30b63ab2911d101160991b84830152805192839101603d83015e01019061227d60f01b84830152518092600f83015e01015f838201520301601f198101835282613793565b90565b60205f60609282825191620186a0fa15613d3f57506040518060200160403d1015613da7575b5f60203d806103e8106103e8821802188083853e840101535b80515f1a15613d9257600101613d81565b818103601f190182525f815260200160405290565b5f513d601f1901811115613dbc575b50613d68565b602081843e82513d829003601f1901811115613dd85750613db6565b90604092826020936103e8106103e88218021892839283875201903e82015f6020820152016040529056fea164736f6c634300081c000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01\xA0`@R4a\0\x85Wa\0\x12a\0\xA8V[`@Qa_\xF1\x90\x81a\x02H\x829`\x80Q\x81a\x1C\xDA\x01R`\xA0Q\x81a\x1C\xAA\x01R`\xC0Q\x81a:L\x01R`\xE0Q\x81a9\xD3\x01Ra\x01\0Q\x81a;\xAC\x01Ra\x01 Q\x81a7\xEB\x01Ra\x01@Q\x81a7\xCA\x01Ra\x01`Q\x81\x81\x81a\x15\x17\x01R\x81\x81a%.\x01Ra1P\x01Ra\x01\x80Q\x81aN\xB1\x01R\xF3[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q=_\x82>=\x90\xFD[i`\x02`\x1Ea=\\=R\xF3_R`\n`\x16_\xF0`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x028W_\x80\x80\x80\x84`\nZ\x04\xFA=\x15a\x023W=`\x01`\x01`@\x1B\x03\x81\x11a\x02\x19W`@Q\x90`\x1F\x81\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x02\x19W`@R\x81R_` =\x92\x01>[\x80\x15a\x02\x1EW`\x01`\xC0R`\x03`\xE0R`\x05a\x01\0R[`\xA0R`\x80RFa\x01 Ra\x01\xC7F`\xA0\x90`@Q\x90\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x82R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x83\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x83\x01R``\x82\x01R0`\x80\x82\x01R \x90V[a\x01@R`@Qa>*\x80\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x02\x19W\x82\x91ab9\x839\x03\x90_\xF0\x80\x15a\x02\x14Wa\x01`Rn\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3;\x15\x15a\x01\x80RV[a\0\x9DV[a\0\x89V[`\x02`\xC0R`\x04`\xE0R`\x06a\x01\0Ra\x013V[a\x01\x1CV[c*\xEAX\x87`\xE0\x1B_R`\x04_\xFD\xFE`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_5`\xE0\x1C\x90\x81b\xAD\x80\x0C\x14a1'WP\x80b\xFD\xD5\x8E\x14a0\xEBW\x80c\x01\xFF\xC9\xA7\x14a0\xA7W\x80c\x03A}r\x14a0\x90W\x80c\x06e\x9B\x7F\x14a0{W\x80c\x06\xE8\xCC\x18\x14a0fW\x80c\x06\xFD\xDE\x03\x14a0<W\x80c\x08\xE6\0\xEE\x14a0'W\x80c\t[\xCD\xB6\x14a/NW\x80c\n\x13<\xF2\x14a/9W\x80c\rW\xFE\xC9\x14a/$W\x80c\x0F^\xEA\xDF\x14a/\x0FW\x80c\x10}N\xE4\x14a.\xC8W\x80c\x10\xD8&r\x14a-\xFFW\x80c\x12\xA1\xE6\xEA\x14a-\xEAW\x80c\x12\xD4\x88\x85\x14a-zW\x80c\x12\xF9\xD2\x1E\x14a-eW\x80c\x13X\x9B\xFE\x14a-PW\x80c\x13\x8C\xD8\x19\x14a-*W\x80c\x14K\xD5\xB5\x14a,\xC8W\x80c\x14\x86Y\x07\x14a,\xB3W\x80c\x17o@Z\x14a,RW\x80c\x1B\x98\xB6?\x14a,=W\x80c\x1B\xB8\x1A\x81\x14a,(W\x80c\x1DGK\x14\x14a,\x13W\x80c\x1E.\xAE\xAF\x14a+\xF7W\x80c \x0F\x0CM\x14a+\x8FW\x80c f \xA1\x14a+?W\x80c%\xD7wk\x14a+\x15W\x80c'7\xED\xB9\x14a*\xFEW\x80c'\xC7w\xA9\x14a*\x81W\x80c*\x9CM\r\x14a)QW\x80c*\xCD]\xC3\x14a)<W\x80c,K\xBD\x17\x14a)%W\x80c.?\xF2\xF7\x14a(\xC1W\x80c.MU\xCC\x14a(\xACW\x80c1\xBB\xAE>\x14a(nW\x80c2\xE2\xA8\x03\x14a(YW\x80c4\x10V\xC5\x14a(DW\x80c6D\xE5\x15\x14a(*W\x80c9<3\xE2\x14a'/W\x80c?E\x8A\x19\x14a'\x18W\x80c?G\xE6b\x14a&\xFCW\x80c@s\xC0\xCC\x14a&\xD9W\x80c@\x9B:~\x14a&\xC4W\x80cAO\xD9\x14\x14a&\xAFW\x80cA\x8A#\xF5\x14a&\x9AW\x80cBj\x84\x93\x14a&6W\x80cD\n\x0E\xC3\x14a%\xEDW\x80cD\xB9}x\x14a%\xBAW\x80cJ\xD5 ^\x14a%\xA3W\x80cL\x10$\x16\x14a%\x8CW\x80cMX_\xBF\x14a%uW\x80cNA\xA1\xFB\x14a%\x01W\x80cNU\xA5H\x14a$\xEAW\x80cP|\xB4o\x14a$\x90W\x80cS\xE5\0g\x14a#PW\x80cT\x849\xE1\x14a#9W\x80cU\x8Ar\x97\x14a\"\xC4W\x80cW|\xDCd\x14a\"\xADW\x80cY !(\x14a\"\x96W\x80cY\x8A\xF9\xE7\x14a\"`W\x80cZ\xC2\xCC\xF1\x14a\"IW\x80c[\x15\xBF\xD9\x14a!\xDDW\x80c[`\x16\xEC\x14a!vW\x80c]v\xA3\x82\x14a!aW\x80c^l\x91\xFF\x14a!LW\x80cb\xA4 \xBB\x14a!\x15W\x80cc\xF5\xB1\xAD\x14a \xD8W\x80cd\x87\x05V\x14a \x9AW\x80cg\x1B;\xD6\x14a *W\x80cj\x9ALD\x14a\x1F\x89W\x80cj\xF2y\x1B\x14a\x1FtW\x80cp\x03\x01\x90\x14a\x1F\x12W\x80cq\x12@m\x14a\x1D\xC8W\x80cq\xF5\x01'\x14a\x1D\xB1W\x80cr\x1Fb\x92\x14a\x1DvW\x80ct#\xEB<\x14a\x1C\x91W\x80cv\xD51\xD4\x14a\x1C|W\x80c\x83@\xF5I\x14a\x1CAW\x80c\x847\x19\xF0\x14a\x1B\xF1W\x80c\x86xUY\x14a\x1B\xDCW\x80c\x88\xD2G\xC4\x14a\x1B\xC5W\x80c\x88\xDA\x84\xD4\x14a\x1B\xAEW\x80c\x89\xCE\x06a\x14a\x1BYW\x80c\x93^\xD2\xBA\x14a\x1B\x1EW\x80c\x970\xF4\xFD\x14a\x1B\x07W\x80c\x99m:\xAC\x14a\x1A\xDCW\x80c\x99\xCF\x8B\x9B\x14a\x19\xE8W\x80c\x9B\xE5\xF57\x14a\x19\xD1W\x80c\xA29AG\x14a\x19\x1CW\x80c\xA4\xC7\xBD\x93\x14a\x18\xE2W\x80c\xAAA\xC8~\x14a\x18\x95W\x80c\xAA\x8B\x84]\x14a\x18cW\x80c\xB2\n\xBCH\x14a\x18NW\x80c\xB2HI\xB7\x14a\x18$W\x80c\xB3$C\x89\x14a\x17\xEEW\x80c\xB4\x03\x9F\xC2\x14a\x17\xC1W\x80c\xB5K\xAE\xFD\x14a\x17\x8CW\x80c\xB6\x02\xAE\x02\x14a\x17JW\x80c\xB66<\xF2\x14a\x17\x05W\x80c\xB7\xAC\xE0G\x14a\x16\xC0W\x80c\xB8\xA5\xBB\xAD\x14a\x16\x82W\x80c\xBC\x95\xBDz\x14a\x167W\x80c\xC4\xD1\x95\xE8\x14a\x15\xF0W\x80c\xC8\t\x10A\x14a\x15\xB4W\x80c\xC8{V\xDD\x14a\x142W\x80c\xCAl\xC3\x9F\x14a\x13\xE5W\x80c\xD2\x04\xF1\x1E\x14a\x13\x9AW\x80c\xD2\xA1\x80_\x14a\x13yW\x80c\xD3M\xDC\x82\x14a\x13bW\x80c\xD3P\x18\x8C\x14a\x13MW\x80c\xD3\x91\x7F<\x14a\x12\xFFW\x80c\xD9!\xF3j\x14a\x12\xB8W\x80c\xDA\x15\xEE\x7F\x14a\x11/W\x80c\xDA/&\x8B\x14a\x10\xE6W\x80c\xDB\x04\xBCr\x14a\x10\xD1W\x80c\xDB\xD05\xFF\x14a\x10YW\x80c\xDDX\x9C\xFC\x14a\x0F\xDCW\x80c\xE0V\\I\x14a\x0F\x8EW\x80c\xE0\\n}\x14a\x0FAW\x80c\xE6\xC5\xB6T\x14a\x0E\xE6W\x80c\xE8g/\x93\x14a\x0E\xD1W\x80c\xEA\x14S.\x14a\x0EjW\x80c\xEA\xA6t\x83\x14a\x0E3W\x80c\xEB\x19`\x08\x14a\r\xF9W\x80c\xEB5\xA6\xD2\x14a\r\x89W\x80c\xEBC\x18!\x14a\rMW\x80c\xEB\xCB\xD7\xB5\x14a\x0C\xF6W\x80c\xEC\xAC\xA4\x0E\x14a\x0C\x8DW\x80c\xEE\xA7zx\x14a\x0C\x18W\x80c\xEE\xD64\xAD\x14a\x0C\x03W\x80c\xEE\xD95r\x14a\x0B\xB8W\x80c\xF15\xBA\xAA\x14a\x0B\x9CW\x80c\xF2=\x92=\x14a\x0B.W\x80c\xF2\xF0\xDE\xF1\x14a\n\xE9W\x80c\xF3@\xFA\x01\x14a\n\xB8W\x80c\xF4J4R\x14a\nZW\x80c\xF7E8\x1C\x14a\n$W\x80c\xF9]=\x16\x14a\t\xEAW\x80c\xFA\x1CU\0\x14a\t\x8AW\x80c\xFBu\xFBi\x14a\t$W\x80c\xFC\xFEC\x1A\x14a\x08\xC1W\x80c\xFD\xC0`\xE7\x14a\x07\xD7Wc\xFE\x99\x04\x9A\x14a\x06UW_\x80\xFD[`\x806`\x03\x19\x01\x12a\x07\xD3Wa\x06ia1\xBDV[a\x06qa1\xFFV[`D5\x91`d5a\x06\x8D`\x01`\x01`\\\x1B\x03\x85`\xA0\x1C\x16aHbV[\x92`\x01\x80`\xA0\x1B\x03\x83\x16\x92`\x01\x80`\xA0\x1B\x03\x82\x16\x94_` \x81`\xA4`@Q\x94\x82\x80R`\x1C\x86\x01\x94\x85\x91c\x1A\x80\x8F\x91\x88R3\x86\x89\x01R\x8B`@\x89\x01R\x8C``\x89\x01R\x8D`\x80\x89\x01R\x8A`\xA0\x89\x01RZ\xF1_Qc\xE5\x7Fpo`\xE0\x1B\x01a\x07\xB8WPPPg\xED\xCA\xA8\x9A\x82)9@`4R`(R3`\x14R`4`  T\x15a\x07\x7FW[\x84`\x14R`@`\x14 \x80T\x80\x84\x11a\x07rW\x83\x90\x03\x90U`(R\x83`\x14R`@`\x14 \x80T\x90\x82\x82\x01\x91\x82\x10a\x07eWU3_R` R_Q` a_e_9_Q\x90_R`@_\xA4_`4R` `@Q`\x01\x81R\xF3[c\x89V\x0C\xA1_R`\x04`\x1C\xFD[c\xF4\xD6x\xB8_R`\x04`\x1C\xFD[\x84_R`T_ \x80T`\x01\x81\x01a\x07\x98W[PPa\x07\rV[\x80\x84\x11a\x07\xABW\x83\x90\x03\x90U_\x80a\x07\x91V[c\xDE\xDA\x900_R`\x04`\x1C\xFD[=\x15\x17\x15a\x07\xCBWc\x01L\x93\x10`\xA4\x92R\xFD[=_\x80>=_\xFD[_\x80\xFD[4a\x07\xD3Wa\x07\xE56a4\x08V[`\x80\x81\x01_\x80a\x07\xF5\x83\x85a7\x7FV[\x90_\x91[\x80\x83\x10a\x08\x9CWPPPa\x08\x8AWa\x08y`5\x92\x84a\x08ta\x08\x7F\x96`\xE0`@Q_Q` a_\xA5_9_Q\x90_R\x81R3` \x82\x01R3`@\x82\x01R` \x83\x01\x97``\x89\x81\x84\x017`\xC0\x82\x01R \x95``\x82\x015\x96a\x08oa\x08g`\x01`\x01`\\\x1B\x03\x8A`\xA0\x1C\x16aHbV[\x80\x935a?\xCFV[a@\x12V[a7\x7FV[\x90aR}V[` `@Q`\x01\x81R\xF3[cNH{q_R`\x11` R`$`\x1C\xFD[\x90\x91\x92`\x01\x90` a\x08\xAF\x86\x85\x87a8\xCDV[\x015\x80\x96\x01\x95\x86\x10\x17\x93\x01\x91\x90a\x07\xF9V[4a\x07\xD3W` a\t\x1A`\x17`5a\x08\xD86a3\xD4V[a\x01\x80a\x08\xF9a\x08\xF3a\x08\xED\x83\x85\x01\x85a<#V[\x90aK\xEEV[\x83a\\\nV[\x92\x90\x91\x93a\t\x0Ba\x01`\x82\x015a<XV[\x92a\t\x14a7\xC8V[\x95aM&V[`@Q\x90\x15\x15\x81R\xF3[4a\x07\xD3W` a\t\x1A`4a\t96a2IV[a\t[a\tSa\tMa\x01\0\x84\x01\x84a8\x98V[\x90aNSV[\x82`0aVQV[\x90a\x01\0a\tk6\x15\x84\x84aS-V[\x91a\ty`\x016\x15\x17a<\xDDV[\x92a\t\x82a7\xC8V[\x94`!a^EV[4a\x07\xD3W` a\t\x1A`4a\t\x9F6a2}V[a\t\xBBa\t\xB3a\x08\xEDa\x01\0\x84\x01\x84a<#V[\x82`1aVQV[\x90a\t\xC9`\xE0\x82\x015a<XV[a\x01\0a\t\xD9`\x026\x15\x17a<\xDDV[\x92a\t\xE2a7\xC8V[\x94`&a^EV[4a\x07\xD3W` a\t\x1A`5a\t\xFF6a2\x15V[a\x01 a\n\x10`@6\x15\x17\x83a[\xC9V[\x92\x91\x93\x90a\n\x1Ca7\xC8V[\x94`$a^EV[4a\x07\xD3W` a\t\x1A`\x17`4a\n;6a3<V[a\nD\x81aUqV[\x90a\x01\0a\nPa7\xC8V[\x936\x15\x92\x80aR\xDFV[4a\x07\xD3W` a\t\x1A`5a\no6a2IV[a\n\x8Aa\n\x82a\x08\xED`\xE0\x84\x01\x84a<#V[\x82`+aVQV[\x90`\xE0a\n\x996\x15\x84\x84aS-V[\x91a\n\xA7`\x016\x15\x17a<\xDDV[\x92a\n\xB0a7\xC8V[\x94`\x1Fa^EV[` 6`\x03\x19\x01\x12a\x07\xD3W` a\n\xD6a\n\xD1a1\xBDV[aC V[a\n\xE14\x823aC|V[`@Q\x90\x81R\xF3[4a\x07\xD3W` a\t\x1A`\x17`5a\x0B\x006a3\xA0V[a\x0B\x19a\x0B\x13a\tM`\xE0\x84\x01\x84a8\x98V[\x82aX4V[\x90`\xE0a\x0B$a7\xC8V[\x936\x15\x92\x80aQ\xA7V[4a\x07\xD3W` a\t\x1A`5a\x0BC6a2\x15V[6\x15a\x01\0a\x0Bsa\x0Bk`@\x84\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84`0aVQV[\x92a\x0B\x8B`\x02a\x0B\x84\x85\x87\x85aS-V[\x94\x17a<\xDDV[\x92a\x0B\x94a7\xC8V[\x94`#a^EV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045\\_R` _\xF3[4a\x07\xD3W` a\t\x1A`5a\x0B\xCD6a2\x15V[a\x0B\xE7a\x0B\xE1a\x08\xEDa\x01@\x84\x01\x84a<#V[\x82a[\x8AV[\x90\x91a\x01@a\x0B\xFAa\x01 \x83\x015a<XV[\x91a\t\xE2a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x0B\xCD6a2\x15V[4a\x07\xD3W` a\t\x1A`5a\x0C-6a3\xD4V[6\x15\x90a\x0C[a\x0CS`\x80\x84\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x82`2aVQV[\x91a\x01@a\x0Cj\x82\x85\x85aS-V[\x92a\x0C~`\x02a\x0B\x84a\x01 \x84\x015a<XV[\x93a\x0C\x87a7\xC8V[\x95aB9V[4a\x07\xD3W`\xA06`\x03\x19\x01\x12a\x07\xD3W` a\x0C\xA8a1\xBDV[a\x0C\xD9a\x0C\xC4a\x0C\xB6a1\xFFV[a\x0C\xBF\x84aH\xDCV[aB\xE2V[\x91a\x0C\xCDa9\xD1V[\x82`D5\x913\x90aH|V[a\x0C\xE1a;\xAAV[a\n\xE1a\x02X6\x15\x17`\x845`d53aA\xB4V[4a\x07\xD3W` a\t\x1A`4a\r\x0B6a4\xD1V[a\x01\x80a\r2a\x08\xF3`\xC06\x15\x17\x84\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x92\x90\x91\x93a\rDa\x01`\x82\x015a<XV[\x92a\x0C\x87a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\rb6a2}V[a\x01 a\r}a\rwa\tM\x83\x85\x01\x85a8\x98V[\x83a[\xAAV[\x92\x91\x93\x90a\t\x82a7\xC8V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W` `\x045a\n\xE1b\xFF\xFF\xFFw'\x8D\0\tH\x90\x01Q\x80\0\x0F<\0\x02X\0\0<\0\0\x0F\0\0\x01`\x18`\x07\x85`\xFC\x1C\x16\x02\x1C\x16B\x01\x82\x81a\r\xF3\x81\x953\x91\x90`@Q\x92`\x14RcA\xD0\xE0K_R`4R`8`\x1C \x91`@RV[UaH\xF6V[4a\x07\xD3W` a\t\x1A`5a\x0E\x0E6a3<V[a\x01\0a\x0E\x1A\x82aU\xCCV[\x91\x90\x92a\x0E*`\x026\x15\x17a<\xDDV[\x92a\n\x1Ca7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x0EH6a3\xA0V[a\x0E[a\n\x82a\tM`\xE0\x84\x01\x84a8\x98V[\x90`\xE0a\tk6\x15\x84\x84aS-V[4a\x07\xD3W` a\t\x1A`\x17`4a\x0E\x816a3<V[a\x0E\x95a\x0CSa\tMa\x01@\x84\x01\x84a8\x98V[\x90a\x0E\xA26\x15\x83\x83aS-V[\x90a\x01@a\x0E\xB4a\x01 \x83\x015a<XV[\x91a\x0E\xC2`\x026\x15\x17a<\xDDV[\x93a\x0E\xCBa7\xC8V[\x95aQ\xA7V[4a\x07\xD3W` a\t\x1A`4a\t\xFF6a2\x15V[4a\x07\xD3W` a\t\x1A`4a\x0E\xFB6a2}V[a\x0F a\x0F\x18\x82`\xE0\x90`\xC0\x81\x015_R\x015` R`@_ \x90V[\x82`/aVQV[\x906\x15`\xC0a\x0F1`\x02\x83\x17a<\xDDV[\x92a\x0F:a7\xC8V[\x94\x80aB9V[4a\x07\xD3W` a\t\x1A`5a\x0FV6a3<V[a\x0F_\x81aRPV[\x90a\x0Fm`\xE0\x82\x015a<XV[a\x01\0a\x0F}`\x026\x15\x17a<\xDDV[\x92a\x0F\x86a7\xC8V[\x94`%a^EV[4a\x07\xD3W` a\t\x1A`4a\x0F\xA36a2\x15V[a\x01\x006\x15a\x0F\xD1a\x0F\xCB`@\x83\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84a[fV[\x92\x90\x93a\x0F:a7\xC8V[4a\x07\xD3W` a\t\x1Aa\x0F\xEF6a4;V[`@Q_Q` a_\xA5_9_Q\x90_R\x81R3\x84\x82\x01R3`@\x82\x01Ra\x10?\x82`\xE0\x86\x82\x01\x93`\x80\x85``\x83\x017 \x92``\x82\x015\x93a\x08oa\x08g`\x01`\x01`\\\x1B\x03\x87`\xA0\x1C\x16aHbV[`\x80a\x10M`\xA0\x84\x01a7\xB4V[\x92\x015\x913`4a\\1V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x10\x89\x906\x90`\x04\x01a3pV[`@Q\x91`@\x83` \x81R\x83` \x82\x01R\x01\x91`\x05\x1B\x83\x01\x91` \x80`@\x85\x01\x93\x92[\x835T\x81R\x01\x91\x01\x90\x84\x83\x82\x10\x15a\x10\xC8WP` \x80\x91a\x10\xACV[`@\x81\x86\x03\x01\x90\xF3[4a\x07\xD3W` a\t\x1A`4a\no6a2IV[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3W` `\x045a\x11\x04a1\xFFV[\x90`@Q\x91\x83Rc\x03\xF3{\x1A`\x0CR\x80`@R`\x01`7`( T\x91\x83`@R`\xFF\x16\x1B\x16\x15\x15\x81R\xF3[a\x01`6`\x03\x19\x01\x12a\x07\xD3Wa\x11Da1\xBDV[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x11c\x906\x90`\x04\x01a4nV[a\x11n\x92\x91\x92a1\xD3V[P`\xA45\x90`\x08\x82\x10\x15a\x07\xD3W`\x02`\xC45\x10\x15a\x07\xD3W`\xE45\x91a\x01\x045\x94`\x03\x86\x10\x15a\x07\xD3Wa\x01$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x11\xB9\x906\x90`\x04\x01a3\x0FV[\x96a\x01D5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W\x86\x95\x88\x92a\x11\xDF\x906\x90`\x04\x01a3\x0FV[a\x11\xED\x85\x84\x89\x9E\x94\x9EaI\x84V[\x96\x81\x9F\x93\x91\x83\x83\x9B\x94\x9B\x01`\x05\x1B\x90` \x01 \x95a\x12\x0B\x8B\x84aJ\x8CV[\x83\x83\x99\x92\x996\x15\x97`\x01\x89\x17\x92a\x12!\x94aC\xC6V[\x9F\x90\x91`@Q\x92_R` R`@R``_ `\x80\x89\x01R`@R`\x1F\x19\x91`\x02\x81\x14`\x06\x1B\x90`\x01\x14`\x0B\x02\x01\x90\x80\x15\x15\x01\x01`\xF3\x01\x16\x90`\x07\x1B\x01a\x01\x80\x01\x90`\xC0\x17a\x12o\x94a>rV[a\x12y\x94\x8AaK8V[`\x18\x02w'\x8D\0\tH\x90\x01Q\x80\0\x0F<\0\x02X\0\0<\0\0\x0F\0\0\x01\x90\x1Cb\xFF\xFF\xFF\x16\x91a\x12\xA6\x93aA\xB4V[`@Qa\x12\xB4\x81\x92\x82a5\xC0V[\x03\x90\xF3[4a\x07\xD3W` a\t\x1A`\x17`5a\x12\xCF6a2\xDBV[a\x01\x80a\x12\xE4a\x08\xF3a\tM\x83\x85\x01\x85a8\x98V[\x92\x90\x91\x93a\x12\xF6a\x01`\x82\x015a<XV[\x92a\x0E\xCBa7\xC8V[4a\x07\xD3W` a\t\x1A`5a\x13\x146a3\xD4V[a\x01@a\x13Aa\x13;`\x806\x15\x17\x84\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x83a[\xD9V[\x92\x91\x93\x90a\x0B\x94a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x0E\x0E6a3<V[4a\x07\xD3W` a\t\x1A`\x17`4a\x0B\x006a3\xA0V[4a\x07\xD3W` a\t\x1A`5a\x13\x8E6a2\xDBV[a\x01@a\n\x10\x82aU\xF4V[4a\x07\xD3W` a\t\x1A`\x17`4a\x13\xB16a4;V[a\x13\xC4a\n\x82a\tM`\xA0\x84\x01\x84a8\x98V[\x906\x15`\xA0a\x13\xD5`\x01\x83\x17a<\xDDV[\x92a\x13\xDEa7\xC8V[\x94\x80aQ\xA7V[4a\x07\xD3W` a\t\x1A`5a\x13\xFA6a2\x15V[a\x14\x03\x81aRPV[\x90a\x14\x11`\xE0\x82\x015a<XV[a\x01\0a\x14!`\x026\x15\x17a<\xDDV[\x92a\x14*a7\xC8V[\x94`\"a^EV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`@Q`\x045`\x80\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x15\xA0W`@\x90\x81R_` \x84\x01\x81\x81R\x91\x84\x01\x81\x81R``\x85\x01\x91\x82R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x86Ra\x14\x9C`\xA0\x86\x90\x1C`\x01`\x01`\\\x1B\x03\x16aHbV[\x16\x83R`\x07\x84`\xFC\x1C\x16`\x08\x81\x10\x15a\x15\x8CW\x81R\x83`\xFF\x1C\x90`\x02\x82\x10\x15a\x15\x8CW\x90\x82R`@Qc\xD67\xCA\x8D`\xE0\x1B\x81R\x94Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16`\x04\x87\x01R\x92Q\x90\x92\x16`$\x85\x01R\x90Qa\x15\x0B\x91\x90a\x15\0\x90`D\x86\x01\x90a5\xA6V[Q`d\x84\x01\x90a5\xB3V[`\x84\x82\x01R_\x81`\xA4\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x15\x81Wa\x12\xB4\x91_\x91a\x15_W[P`@Q\x91\x82\x91\x82a1\x93V[a\x15{\x91P=\x80_\x83>a\x15s\x81\x83a5\xF9V[\x81\x01\x90a65V[\x82a\x15RV[`@Q=_\x82>=\x90\xFD[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x15\xE2a\x08\x7F\x916\x90`\x04\x01a4nV[a\x15\xEAa1\xFFV[\x91a8\xDDV[4a\x07\xD3W` a\t\x1A`\x17`5a\x16\x076a2}V[a\x16!a\x16\x1Ba\x08\xEDa\x01\0\x84\x01\x84a<#V[\x82a[fV[\x90a\x01\0a\x16-a7\xC8V[\x936\x15\x92\x80aM&V[4a\x07\xD3W` a\t\x1A`\x17`5a\x16N6a3\xA0V[a\x16aa\x0F\x18a\x08\xED`\xC0\x84\x01\x84a<#V[\x906\x15`\xC0a\x16r`\x02\x83\x17a<\xDDV[\x92a\x16{a7\xC8V[\x94\x80aM&V[4a\x07\xD3W` a\t\x1A`\x17`4a\x16\x996a3\xA0V[a\x16\xA2\x81aU\x16V[\x906\x15`\xA0a\x16\xB0\x82a<\xDDV[\x92a\x16\xB9a7\xC8V[\x94\x80aR\xDFV[4a\x07\xD3W` a\t\x1A`\x17`4a\x16\xD76a2IV[a\x16\xF4a\x0F\x18\x82`\xE0\x90`\xC0\x81\x015_R\x015` R`@_ \x90V[\x906\x15`\xC0a\x16\xB0`\x02\x83\x17a<\xDDV[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3Wa\x17\x1Ea1\xBDV[a\x17&a1\xFFV[\x90g\xED\xCA\xA8\x9A\x82)9@` R`\x14R_R` `4`\x0C T`@Q\x90\x15\x15\x81R\xF3[4a\x07\xD3W` a\t\x1A`5a\x17_6a2IV[6\x15a\x17m\x81\x83`(aVQV[\x90a\x17w\x81a<\xDDV[\x91a\x17\x80a7\xC8V[\x93`\xA0\x83\x17\x91\x80aB9V[4a\x07\xD3W` a\t\x1A`\x17`4a\x17\xA36a2IV[a\x17\xB6a\x0B\x13a\x08\xED`\xE0\x84\x01\x84a<#V[\x90`\xE0a\x16-a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x17\xD66a2}V[`\xE0a\x17\xE1\x82aU$V[\x91\x90\x92a\x0E*6\x15a<\xDDV[4a\x07\xD3W` a\t\x1A`4a\x18\x036a2\x15V[a\x01@a\x18\x18a\x13;a\x08\xED\x83\x85\x01\x85a<#V[\x92\x91\x93\x90a\n\xB0a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x1896a3<V[a\x01 a\x18\x18a\rwa\x08\xED\x83\x85\x01\x85a<#V[4a\x07\xD3W` a\t\x1A`5a\x1896a3<V[` a\x18|a\n\xE1a\x18t6a2\xB1V[\x93\x90\x91aC V[\x92a\x18\x884\x853aC|V[a\x02X6\x15\x17\x913aA\xB4V[4a\x07\xD3W` a\t\x1A`4a\x18\xAA6a3<V[a\x18\xBEa\x0B\xE1a\tMa\x01@\x84\x01\x84a8\x98V[\x90\x91a\x01@a\x18\xD1a\x01 \x83\x015a<XV[\x91a\x18\xDAa7\xC8V[\x94`'a^EV[4a\x07\xD3W` a\t\x1A`4a\x18\xF76a2\xDBV[a\x19\0\x81aUBV[\x90\x91a\x01@a\x19\x13a\x01 \x83\x015a<XV[\x91a\x0F\x86a7\xC8V[4a\x07\xD3Wa\x19*6a4\x08V[`\x80\x81\x01_\x80a\x19:\x83\x85a7\x7FV[\x90_\x91[\x80\x83\x10a\x19\xACWPPPa\x08\x8AWa\x08y`4\x92\x84a\x08ta\x08\x7F\x96`\xE0`@Q_Q` a_\xA5_9_Q\x90_R\x81R3` \x82\x01R3`@\x82\x01R` \x83\x01\x97``\x89\x81\x84\x017`\xC0\x82\x01R \x95``\x82\x015\x96a\x08oa\x08g`\x01`\x01`\\\x1B\x03\x8A`\xA0\x1C\x16aHbV[\x90\x91\x92`\x01\x90` a\x19\xBF\x86\x85\x87a8\xCDV[\x015\x80\x96\x01\x95\x86\x10\x17\x93\x01\x91\x90a\x19>V[4a\x07\xD3W` a\t\x1A`\x17`4a\x16N6a3\xA0V[a\x01 6`\x03\x19\x01\x12a\x07\xD3Wa\x19\xFDa1\xBDV[P`$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x1A\x1D\x906\x90`\x04\x01a4nV[a\x1A%a1\xD3V[P`\x08`\xA45\x10\x15a\x07\xD3W`\x02`\xC45\x10\x15a\x07\xD3W`\xE45\x91`\x01`\x01`\xA0\x1B\x03\x83\x16\x83\x03a\x07\xD3Wa\x01\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x12\xB4\x93a\x1A\xCAa\x1A{a\x1A\xD0\x946\x90`\x04\x01a3\x0FV[\x95\x90\x93a\x1A\x89\x84\x83\x83aI\x84V[\x95\x92a\x1A\xB6`\xC0\x9B\x93\x99\x92\x9B6\x15\x92a\x1A\xA4`\x84\x85\x17a=\x1EV[a\x1A\xAE\x8D\x83aJ\x8CV[\x94\x90\x94a=\xB8V[`\x80\x84\x01R`\x07\x1Ba\x02 \x01\x92\x17\x90a>rV[\x86aK8V[`@Q\x91\x82\x91\x82a5\xC0V[4a\x07\xD3W` a\t\x1A`\x17`4a\x1A\xF36a2}V[a\x1A\xFC\x81aWtV[\x90`\xE0a\nPa7\xC8V[4a\x07\xD3W` a\t\x1A`\x17`4a\x16\x076a2}V[4a\x07\xD3W` a\t\x1A`\x17`4a\x1B56a59V[a\x1BHa\x0F\x18a\tM`\xC0\x84\x01\x84a8\x98V[\x906\x15`\xC0a\x13\xD5`\x02\x83\x17a<\xDDV[4a\x07\xD3W` a\t\x1A`5a\x1Bn6a3\xD4V[a\x1B\x92a\x0B\xE1`\x806\x15\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90\x91a\x01@a\x1B\xA5a\x01 \x83\x015a<XV[\x91a\x14*a7\xC8V[4a\x07\xD3W` a\t\x1A`\x17`5a\x0E\x816a3<V[4a\x07\xD3W` a\t\x1A`\x17`5a\x1B56a59V[4a\x07\xD3W` a\t\x1A`4a\x17_6a2IV[4a\x07\xD3W` a\t\x1A`\x17`5a\x1C\x086a2\xDBV[a\x1C\x11\x81aU\x9CV[\x90\x91a\x01@a\x1C$a\x01 \x83\x015a<XV[\x91a\x1C2`\x026\x15\x17a<\xDDV[\x93a\x1C;a7\xC8V[\x95aR\xDFV[4a\x07\xD3W` a\x1Cca\x1Cta\x1CW6a5lV[\x91\x93\x90a\x0C\xBF\x85aH\xDCV[\x80\x93a\x1Cma9\xD1V[3\x90aH|V[a\n\xE1a;\xAAV[4a\x07\xD3W` a\t\x1A`5a\x0E\xFB6a2}V[4a\x07\xD3W_6`\x03\x19\x01\x12a\x07\xD3W23\x03a\x1DgW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x15a\x1D\\W[a\x1DMW_\x80\x80\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\nZ\x04\xFA=\x15a\x1DHW=a\x1D\x0E\x81a6\x1AV[\x90a\x1D\x1C`@Q\x92\x83a5\xF9V[\x81R_` =\x92\x01>[\x15a\x1D9W_\x80T`\xFF\x19\x16`\x01\x17\x90U\0[cp\xA4\x07\x8F`\xE0\x1B_R`\x04_\xFD[a\x1D&V[c\x0FE\xB9\x8B`\xE4\x1B_R`\x04_\xFD[P`\xFF_T\x16a\x1C\xD0V[c\tfP\xC5`\xE2\x1B_R`\x04_\xFD[4a\x07\xD3W` a\t\x1A`\x17`5a\x1D\x8D6a59V[a\x1D\xA0a\n\x82a\x08\xED`\xA0\x84\x01\x84a<#V[\x906\x15`\xA0a\x16r`\x01\x83\x17a<\xDDV[4a\x07\xD3W` a\t\x1A`\x17`5a\x16\x996a3\xA0V[4a\x07\xD3Wa\x1D\xD66a4\x9EV[``\x81\x01a\x1D\xE4\x81\x83a8\x98V[\x80`\x06\x94\x92\x94\x1B\x81\x81\x04`@\x14\x82\x15\x17\x15a\x1E\xFEWa\x1E\x02\x90aK\xADV[\x93_\x91_[\x81\x81\x10a\x1E\x95WPPPa\x08\x8AWa\x1EM\x81a\x1E-\x85` a\x1ER\x97Q\x91\x01 \x82aSsV[a\x1EG`9a\x1E<\x87\x85a8\x98V[` \x86\x015\x91a@\xEDV[\x90a@\x12V[a8\x98V[_[\x81\x81\x10a\x1EfW` `@Q`\x01\x81R\xF3[\x80a\x1E\x8F`4a\x1Ey`\x01\x94\x86\x88aA\x92V[a\x1E\x86` \x82\x01\x82a7\x7FV[\x90\x915\x91aR}V[\x01a\x1ETV[a\x1E\xA0\x81\x83\x85aA\x92V[_\x90a\x1E\xAF` \x82\x01\x82a7\x7FV[\x90_\x91[\x80\x83\x10a\x1E\xD9WPPP\x90`@\x83\x92`\x01\x94`\x06\x1B\x8B\x01\x905` \x82\x01R\x01R\x01a\x1E\x07V[\x90\x91\x97`\x01\x90` a\x1E\xEC\x8B\x85\x87a8\xCDV[\x015\x80\x96\x01\x95\x86\x10\x17\x98\x01\x91\x90a\x1E\xB3V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045a\x1FI\x813\x91\x90`@Q\x92`\x14RcA\xD0\xE0K_R`4R`8`\x1C \x91`@RV[\x80T\x15a\x1F_W\x90_a\x08\x7F\x92U6\x15\x90aH\xF6V[Pc\xE62\xDB\xAD_R3` R`@R`D`\x1C\xFD[4a\x07\xD3W` a\t\x1A`4a\x0C-6a3\xD4V[4a\x07\xD3W`\x80a\x1F\x996a4\x08V[a\x1F\xEDa\x1F\xE4``\x83\x01a\x1F\xDE\x84a\x1F\xC6a\x1F\xB4\x84\x83a7\x7FV[`@Q\x90`\x06\x1B\x80\x92\x827 \x82aSsV[a\x1EGa\x1F\xD3\x85\x84a7\x7FV[` \x85\x015\x91a@oV[\x83a7\x7FV[\x93\x90\x92\x01a7\xB4V[\x90_[\x83\x81\x10a \x02W` `@Q`\x01\x81R\xF3[\x80a #a \x13`\x01\x93\x87\x86a8\xCDV[` \x81\x015\x905\x863`5a\\1V[P\x01a\x1F\xF0V[4a\x07\xD3W`\xC06`\x03\x19\x01\x12a\x07\xD3Wa Ca1\xBDV[a Ka1\xFFV[\x90`D5\x91`\x08\x83\x10\x15a\x07\xD3W`d5\x91`\x02\x83\x10\x15a\x07\xD3Wa \x87a\x1Ct\x92` \x95a xa1\xE9V[\x95a \x82\x85aH\xDCV[aCKV[\x80\x93a \x91a9\xD1V[`\x845\x92aH|V[4a\x07\xD3W` a\t\x1A`\x17`5a \xB16a5\x05V[a\x01\x80a \xBD\x82aV&V[\x92\x90\x91\x93a \xCFa\x01`\x82\x015a<XV[\x92a\x1C;a7\xC8V[4a\x07\xD3W` a\t\x1A`4a \xED6a3<V[6\x15`\xE0a!\0`@\x83\x17\x84`(aVQV[\x92a\x0B\x8Ba!\x0F\x84\x86\x84aS-V[\x93a<\xDDV[4a\x07\xD3W` a\t\x1A`\x17`5a!,6a2IV[a!@a\x16\x1Ba\tMa\x01\0\x84\x01\x84a8\x98V[\x90a\x01\0a\x0B$a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x1Bn6a3\xD4V[4a\x07\xD3W` a\t\x1A`5a\x18\xAA6a3<V[``6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa!\xA1\x906\x90`\x04\x01a4nV[`$5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W` \x92a!\xD4a!\xCAa\t\x1A\x946\x90`\x04\x01a4nV[\x92\x90\x933\x91a8\xDDV[`D5\x91aAYV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x80`\x045a\"Ga\"\x0B`\x01`\x01`\\\x1B\x03\x83`\xA0\x1C\x16aHbV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x86\x16\x82R\x90\x92\x16` \x83\x01R\x90\x92\x90a\":\x90\x84\x01`\xFC\x83\x90\x1C`\x07\x16a5\xA6V[``\x83\x01\x90`\xFF\x1Ca5\xB3V[\xF3[4a\x07\xD3W` a\t\x1A`\x17`4a\x08\xD86a3\xD4V[4a\x07\xD3Wa\"n6a5lV[\x91g\xED\xCA\xA8\x9A\x82)9@`4R`(R`\x14R_R` `T_ T_`4R`@Q\x90\x81R\xF3[4a\x07\xD3W` a\t\x1A`\x17`4a\x1D\x8D6a59V[4a\x07\xD3W` a\t\x1A`\x17`4a!,6a2IV[`@6`\x03\x19\x01\x12a\x07\xD3Wa\"\xD8a1\xBDV[`$5\x90\x81\x15\x15\x80\x92\x03a\x07\xD3Wg\xED\xCA\xA8\x9A\x82)9@` R3`\x14R_R\x80`4`\x0C U` R`\x0CQ``\x1C3\x7F\xCE\xB5v\xD9\xF1^N \x0F\xDBP\x96\xD6M]\xFDf~\x16\xDE\xF2\x0C\x1E\xEF\xD1BV\xD8\xE3\xFA\xA2g` \x80\xA3` `@Q`\x01\x81R\xF3[4a\x07\xD3W` a\t\x1A`\x17`5a\x13\xB16a4;V[4a\x07\xD3Wa\x01\x806`\x03\x19\x01\x12a\x07\xD3Wa#ja1\xBDV[a#ra1\xD3V[\x90a#{a1\xE9V[P`\xC45`\x08\x81\x10\x15a\x07\xD3W`\x02`\xE45\x10\x15a\x07\xD3Wa\x01\x045\x90a\x01$5\x90`\x03\x82\x10\x15a\x07\xD3Wa\x01D5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa#\xC6\x906\x90`\x04\x01a3\x0FV[\x94\x90\x92a\x01d5\x95`\x01`\x01`@\x1B\x03\x87\x11a\x07\xD3W\x87\x96a#\xEC\x906\x90`\x04\x01a3\x0FV[\x98\x90\x91a#\xF8\x85a=SV[\x83\x9D\x93\x96\x92\x97\x91\x946\x15\x9Ba$\x0E\x93\x8D\x93aC\xC6V[\x99\x90`@Q\x90_R\x86` R\x8B`@R``_ a\x01\0\x86\x01R`@R`\x1F\x19a\x01`\x85\x01Qa\x01\x7F\x01\x16\x90a\x01@\x17a$G\x94a>rV[a$P\x93a>\xCAV[`\x18\x02w'\x8D\0\tH\x90\x01Q\x80\0\x0F<\0\x02X\0\0<\0\0\x0F\0\0\x01\x90\x1Cb\xFF\xFF\xFF\x16\x91a$}\x93aA\xB4V[a$\x85a;\xAAV[`@Q\x90\x81R` \x90\xF3[`\x806`\x03\x19\x01\x12a\x07\xD3Wa$\xA4a1\xBDV[`$5`\x08\x81\x10\x15a\x07\xD3W`D5\x90`\x02\x82\x10\x15a\x07\xD3W`d5\x91`\x01`\x01`\xA0\x1B\x03\x83\x16\x83\x03a\x07\xD3W` \x93a\n\xE1\x92a$\xE1\x92aB\xB1V[\x91\x824\x91aC|V[4a\x07\xD3W` a\t\x1A`\x17`5a\x17\xA36a2IV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`@QcNA\xA1\xFB`\xE0\x1B\x81R`\x04\x805\x90\x82\x01R_\x81`$\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x15\x81Wa\x12\xB4\x91_\x91a\x15_WP`@Q\x91\x82\x91\x82a1\x93V[4a\x07\xD3W` a\t\x1A`\x17`4a \xB16a5\x05V[4a\x07\xD3W` a\t\x1A`\x17`4a\x1C\x086a2\xDBV[4a\x07\xD3W` a\t\x1A`\x17`5a\x1A\xF36a2}V[4a\x07\xD3W` a\t\x1A`4a%\xCF6a3<V[a%\xD8\x81aWtV[\x90`\xE0a%\xE3a7\xC8V[\x936\x15\x92\x80aB9V[4a\x07\xD3W`@a&'a&\x006a2\xB1V[\x91`X\x92`\x1C\x92`@Q\x92`\x14\x84\x01Rch\xA3\r\xD0\x83R`4\x83\x01R`T\x82\x01R\x01 T\x90V[\x81Q\x90B\x81\x11\x82R` \x82\x01R\xF3[a&?6a2\xB1V[\x90\x91g\xED\xCA\xA8\x9A\x82)9@`4R3`(R`\x14R\x81_R\x80`T_ U_R` Q``\x1C3\x7F\xB3\xFDPq\x83X\x87Vz\x06q\x15\x11!\x89M\xDC\xCC(B\xF1\xD1\x0B\xED\xAD\x13\xE0\xD1|\xAC\xE9\xA7` _\xA4_`4R` `@Q`\x01\x81R\xF3[4a\x07\xD3W` a\t\x1A`5a\r\x0B6a4\xD1V[4a\x07\xD3W` a\t\x1A`4a\x13\x8E6a2\xDBV[4a\x07\xD3W` a\t\x1A`4a\x0FV6a3<V[4a\x07\xD3W``6`\x03\x19\x01\x12a\x07\xD3Wa\x08\x7F`D5`$5`\x0453aA\xB4V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W` `@Q`\x12\x81R\xF3[4a\x07\xD3W` a\t\x1A`\x17`5a\n;6a3<V[4a\x07\xD3Wa'=6a4\x9EV[``\x81\x01a'K\x81\x83a8\x98V[\x80`\x06\x94\x92\x94\x1B\x81\x81\x04`@\x14\x82\x15\x17\x15a\x1E\xFEWa'i\x90aK\xADV[\x93_\x91_[\x81\x81\x10a'\xC1WPPPa\x08\x8AWa\x1EM\x81a\x1E-\x85` a'\x94\x97Q\x91\x01 \x82aSsV[_[\x81\x81\x10a'\xA8W` `@Q`\x01\x81R\xF3[\x80a'\xBB`5a\x1Ey`\x01\x94\x86\x88aA\x92V[\x01a'\x96V[a'\xCC\x81\x83\x85aA\x92V[_\x90a'\xDB` \x82\x01\x82a7\x7FV[\x90_\x91[\x80\x83\x10a(\x05WPPP\x90`@\x83\x92`\x01\x94`\x06\x1B\x8B\x01\x905` \x82\x01R\x01R\x01a'nV[\x90\x91\x97`\x01\x90` a(\x18\x8B\x85\x87a8\xCDV[\x015\x80\x96\x01\x95\x86\x10\x17\x98\x01\x91\x90a'\xDFV[4a\x07\xD3W_6`\x03\x19\x01\x12a\x07\xD3W` a\n\xE1a7\xC8V[4a\x07\xD3W` a\t\x1A`5a\x18\xF76a2\xDBV[4a\x07\xD3W` a\t\x1A`4a\x13\xFA6a2\x15V[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\t\x1Aa(\xA3` \x926\x90`\x04\x01a4nV[`$5\x91aAYV[4a\x07\xD3W` a\t\x1A`5a%\xCF6a3<V[4a\x07\xD3W``6`\x03\x19\x01\x12a\x07\xD3W`\x045a(\xDDa1\xFFV[`@\x80Q3`\x14RcA\xD0\xE0K_R`4\x84\x90R`8`\x1C \x91RTB\x81\x11\x90\x15\x17a)\x14Wa\t\x1A\x90` \x92`D5\x913a6\x97V[Pc\x92\x87\xBC\xB0_R` R`$`\x1C\xFD[4a\x07\xD3W` a\t\x1A`\x17`4a\x12\xCF6a2\xDBV[4a\x07\xD3W` a\t\x1A`5a\t\x9F6a2}V[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3Wa)ja1\xBDV[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa)\x89\x906\x90`\x04\x01a3\x0FV[`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91`U\x81\x14\x913\x84\x14\x84;\x15\x15\x17\x91\x83a*5W[PP\x17\x15a*%Wa)\xBA\x81a>\xF9V[\x80gD\x03o\xC7}\xEA\xED#`\\\x1B\x17\x91\x82T\x80a*\x11WP\x80` \x93U\x81_R\x82R\x7F\xC5M\xCA\xA6z\x8F\xD7\xB4\xA9\xAAo\xD5sQ\x93Ly&\x13\xD5\xEC\x1A\xCB\xD6Rt'\x0Em\xE8\xF7\xE4`@_\xA1`\x01`\x01``\x1B\x03`@Q\x91\x16\x81R\xF3[\x82c\xC1\x8B\x0E\x97_R` R`@R`D`\x1C\xFD[cN\x7FI+_R` R`$`\x1C\xFD[\x80\x91\x92\x93P\x15a*mW\x80\x82`@Q7`@Q `\x01`\x01`\xA0\x1B\x03\x16\x83\x14`\x01`\x01`\xF8\x1B\x03\x19\x915\x82\x16\x90\x91\x14\x16\x90\x83\x80a)\xA9V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[4a\x07\xD3W` a\t\x1Aa*\x946a4;V[`@Q_Q` a_\xA5_9_Q\x90_R\x81R3\x84\x82\x01R3`@\x82\x01Ra*\xE4\x82`\xE0\x86\x82\x01\x93`\x80\x85``\x83\x017 \x92``\x82\x015\x93a\x08oa\x08g`\x01`\x01`\\\x1B\x03\x87`\xA0\x1C\x16aHbV[`\x80a*\xF2`\xA0\x84\x01a7\xB4V[\x92\x015\x913`5a\\1V[4a\x07\xD3W` a\t\x1A`\x17`5a\x16\xD76a2IV[4a\x07\xD3W` a\t\x1A`5a+*6a3<V[a\x01@a\r}a\x13;a\tM\x83\x85\x01\x85a8\x98V[4a\x07\xD3W` a\t\x1A`5a+T6a2IV[a+ha\t\xB3a\tMa\x01\0\x84\x01\x84a8\x98V[\x90a+v`\xE0\x82\x015a<XV[a\x01\0a+\x86`\x026\x15\x17a<\xDDV[\x92a\x18\xDAa7\xC8V[4a\x07\xD3W`\x80a+\x9F6a4\x08V[a+\xBAa\x1F\xE4``\x83\x01a\x1F\xDE\x84a\x1F\xC6a\x1F\xB4\x84\x83a7\x7FV[\x90_[\x83\x81\x10a+\xCFW` `@Q`\x01\x81R\xF3[\x80a+\xF0a+\xE0`\x01\x93\x87\x86a8\xCDV[` \x81\x015\x905\x863`4a\\1V[P\x01a+\xBDV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045T_R` _\xF3[4a\x07\xD3W` a\t\x1A`4a\x13\x146a3\xD4V[4a\x07\xD3W` a\t\x1A`5a \xED6a3<V[4a\x07\xD3W` a\t\x1A`5a\x0F\xA36a2\x15V[4a\x07\xD3W` a\t\x1A`\x17`4a,i6a2\x15V[a,}a\x0CSa\x08\xEDa\x01@\x84\x01\x84a<#V[\x90a,\x8A6\x15\x83\x83aS-V[\x90a\x01@a,\x9Ca\x01 \x83\x015a<XV[\x91a,\xAA`\x026\x15\x17a<\xDDV[\x93a\t\x14a7\xC8V[4a\x07\xD3W` a\t\x1A`5a\x18\x036a2\x15V[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3Wa-\x06a,\xE4a1\xBDV[`$5\x90\x91\x90`@Q\x92`\x14RcA\xD0\xE0K_R`4R`8`\x1C \x91`@RV[T`@Q\x81\x15\x15B\x83\x11`\x02\x03\x02\x91`\x03\x83\x10\x15a\x15\x8CW`@\x92\x82R` \x82\x01R\xF3[4a\x07\xD3W` a\t\x1A`5a-?6a2\xDBV[a\x01 a\x13A`@6\x15\x17\x83a[\xC9V[4a\x07\xD3W` a\t\x1A`5a\x0EH6a3\xA0V[4a\x07\xD3W` a\t\x1A`4a\x0BC6a2\x15V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa-\xAA\x906\x90`\x04\x01a3pV[\x90a-\xBCa-\xB73a>\xF9V[a?\xA8V[\x80\x91`\x05\x1B\x01\x90[\x81\x81\x10a-\xD6W` `@Q`\x01\x81R\xF3[` \x90a-\xE43\x825a?\xCFV[\x01a-\xC4V[4a\x07\xD3W` a\t\x1A`4a+*6a3<V[4a\x07\xD3Wa\x01@6`\x03\x19\x01\x12a\x07\xD3Wa.\x19a1\xBDV[a.!a1\xD3V[Pa.*a1\xE9V[P`\x08`\xC45\x10\x15a\x07\xD3W`\x02`\xE45\x10\x15a\x07\xD3Wa\x01\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3Wa\x01$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3W` \x92a.\xAD\x92a.\x80a\x1Ct\x936\x90`\x04\x01a3\x0FV[\x92\x90\x91a.\xC36\x15\x94a.\x95`\xA4\x87\x17a=\x1EV[\x94a.\x9F\x84a=SV[\x9B\x83\x9C\x9A\x93\x99\x91\x92\x9Aa=\xB8V[a\x01\0\x82\x01Ra\x01@a\x02\0\x83\x17\x92\x17\x90a>rV[a>\xCAV[4a\x07\xD3W` a\t\x1A`4a.\xDD6a2}V[a.\xF1a\tSa\x08\xEDa\x01\0\x84\x01\x84a<#V[\x90a\x01\0a/\x016\x15\x84\x84aS-V[\x91a\n\xA7`\x026\x15\x17a<\xDDV[4a\x07\xD3W` a\t\x1A`5a.\xDD6a2}V[4a\x07\xD3W` a\t\x1A`4a-?6a2\xDBV[4a\x07\xD3W` a\t\x1A`5a\t96a2IV[a/W6a2\xB1V[a/o`\x01`\x01`\\\x1B\x03\x83`\xA0\x95\x94\x95\x1C\x16aHbV[\x91`\x01\x80`\xA0\x1B\x03\x81\x16\x92_` \x81`\xA4`@Q\x94\x82\x80R`\x1C\x86\x01\x94\x85\x91c\x1A\x80\x8F\x91\x88R3\x86\x89\x01R3`@\x89\x01R\x8A``\x89\x01R\x8B`\x80\x89\x01R\x89`\xA0\x89\x01RZ\xF1_Qc\xE5\x7Fpo`\xE0\x1B\x01a\x07\xB8WPPPg\xED\xCA\xA8\x9A\x82)9@` R3`\x14R\x83_R`@_ \x80T\x80\x84\x11a\x07rW\x83\x90\x03\x90U`\x14R\x82_R`@_ \x80T\x90\x82\x82\x01\x91\x82\x10a\x07eWU3_R` R3_Q` a_e_9_Q\x90_R`@_\xA4` `@Q`\x01\x81R\xF3[4a\x07\xD3W` a\t\x1A`5a\rb6a2}V[4a\x07\xD3W_6`\x03\x19\x01\x12a\x07\xD3W` \x80Rk\x0BThe Compact`KR``` \xF3[4a\x07\xD3W` a\t\x1A`5a\x17\xD66a2}V[4a\x07\xD3W` a\t\x1A`4a+T6a2IV[4a\x07\xD3W` a\t\x1A`\x17`5a,i6a2\x15V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x03a\x07\xD3W` \x90`\xE0\x1C`@Q\x90c\x01\xFF\xC9\xA7c\x0Fc/\xB3\x82\x14\x91\x14\x17\x15\x15\x81R\xF3[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3Wa1\x04a1\xBDV[g\xED\xCA\xA8\x9A\x82)9@` R`\x14R`$5_R` `@_ T`@Q\x90\x81R\xF3[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3Wb+`\x03`\xE2\x1B\x81R`\x04\x805\x90\x82\x01R_\x81`$\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x15\x81Wa\x12\xB4\x91_\x91a\x15_WP`@Q\x91\x82\x91\x82[` `@\x92\x81\x83R\x80Q\x91\x82\x91\x82\x82\x86\x01R\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[`\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3WV[`\x845\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3WV[`\xA45\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3WV[`$5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3WV[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\x80\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01 \x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01@\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[``\x90`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x07\xD3W\x90`$5\x90`D5\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\xA0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[\x91\x81`\x1F\x84\x01\x12\x15a\x07\xD3W\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x07\xD3W` \x83\x81\x86\x01\x95\x01\x01\x11a\x07\xD3WV[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01`\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[\x91\x81`\x1F\x84\x01\x12\x15a\x07\xD3W\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x07\xD3W` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x07\xD3WV[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\xC0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W`\xA0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W`\xC0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[\x91\x81`\x1F\x84\x01\x12\x15a\x07\xD3W\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x07\xD3W` \x80\x85\x01\x94\x84`\x06\x1B\x01\x01\x11a\x07\xD3WV[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W`\x80\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x02\0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\xE0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W`\xE0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[``\x90`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x07\xD3W\x90`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x07\xD3W\x90`D5\x90V[\x90`\x08\x82\x10\x15a\x15\x8CWRV[\x90`\x02\x82\x10\x15a\x15\x8CWRV[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90_[\x81\x81\x10a5\xE3WPPP\x90V[\x82Q\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a5\xD6V[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x15\xA0W`@RV[`\x01`\x01`@\x1B\x03\x81\x11a\x15\xA0W`\x1F\x01`\x1F\x19\x16` \x01\x90V[` \x81\x83\x03\x12a\x07\xD3W\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W\x01\x81`\x1F\x82\x01\x12\x15a\x07\xD3W\x80Q\x90a6h\x82a6\x1AV[\x92a6v`@Q\x94\x85a5\xF9V[\x82\x84R` \x83\x83\x01\x01\x11a\x07\xD3W\x81_\x92` \x80\x93\x01\x83\x86\x01^\x83\x01\x01R\x90V[\x90\x92\x91\x92a6\xA3a9\xD1V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x80a7$WP_\x90\x81\x80\x858\x93Z\xF1\x15a7\x17W[g\xED\xCA\xA8\x9A\x82)9@` R\x80`\x14R\x82_R`@_ \x91\x82T\x92\x83\x82\x11a\x07rW\x81_\x94\x03\x90U3\x83R` R`\x01\x80`\xA0\x1B\x03\x16_Q` a_e_9_Q\x90_R`@\x83\xA4a7\x12a;\xAAV[`\x01\x90V[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x90\x91\x92a710\x83a;\x85V[\x92`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10\x82\x85Z\xF1=\x15`\x01_Q\x14\x17\x16\x15a7rWa7j\x90_`4R0\x90a;\x85V[\x90\x03\x90a6\xC2V[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W` \x01\x91\x81`\x06\x1B6\x03\x83\x13a\x07\xD3WV[5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x07\xD3W\x90V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\x18a8\x13W\x90V[P`\xA0`@Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x82\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x82\x01RF``\x82\x01R0`\x80\x82\x01R \x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W` \x01\x91\x81`\x05\x1B6\x03\x83\x13a\x07\xD3WV[\x91\x90\x81\x10\x15a*mW`\x06\x1B\x01\x90V[\x91\x90a8\xE7a9\xD1V[\x825\x90`\x01\x80`\xA0\x1B\x03\x82\x16\x15\x91` \x85\x0154\x14\x15\x83\x164\x15\x84\x14\x17\x82\x15\x17a9\xC4W\x80`\x01`\x01`\\\x1B\x03\x84\x92`\xA0\x1C\x16a9#\x81a?\xA8V[\x93a9\xB2W[P[\x81\x81\x10a9AWPPPPPa9?a;\xAAV[V[a9L\x81\x83\x87a8\xCDV[\x805\x90`\x01`\x01`\\\x1B\x03\x82`\xA0\x1C\x16`\x01`\x01``\x1B\x03\x86\x16\x81\x03a9\x91W[P`\x01\x92\x91a9\x8B\x91` \x015\x90\x87`\x01`\x01`\xA0\x1B\x03\x82\x16aH|V[\x01a9+V[a9\x8B\x91\x95P\x91` \x83a9\xA7`\x01\x96\x95a?\xA8V[\x96\x92PP\x91\x92a9mV[a9\xBE\x904\x90\x86aC|V[_a9)V[c\xCA\x0F\xC0\x8E_R`\x04`\x1C\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x04\x14a;YW\x80`\x03\x14a;GW\x80`\t\x14a;\x10W\x80`\n\x14a:\xD3W`\x08\x14a:-WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a:C6\x15h\x92\x9E\xEE\x14\x9BK\xD2\x12h`(aVQV[\x80[a:\xC3WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x02\x14a:\x9CW`\x01\x14a:\x8EWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[3h\x92\x9E\xEE\x14\x9BK\xD2\x12h]V[P_T`\xFF\x16\x15a:\xB5W3h\x92\x9E\xEE\x14\x9BK\xD2\x12h]V[3h\x92\x9E\xEE\x14\x9BK\xD2\x12hUV[c\xF5|D\x8B_R` R`$`\x1C\xFD[P`\xE0`@6\x15\x17h\x92\x9E\xEE\x14\x9BK\xD2\x12h\x01`\xC0\x81\x015_R\x015` Ra;\n`@_ h\x92\x9E\xEE\x14\x9BK\xD2\x12h`1aVQV[\x80a:EV[Ph\x92\x9E\xEE\x14\x9BK\xD2\x13(5_\x90\x81Rh\x92\x9E\xEE\x14\x9BK\xD2\x13H5` R`@\x90 a;\n\x90h\x92\x9E\xEE\x14\x9BK\xD2\x12h`/aVQV[Ph\x92\x9E\xEE\x14\x9BK\xD2\x12h\\\x80a:EV[P_T`\xFF\x16\x15a;uWh\x92\x9E\xEE\x14\x9BK\xD2\x12h\\\x80a:EV[h\x92\x9E\xEE\x14\x9BK\xD2\x12hTa;\nV[`$`\x10` \x93\x92\x84\x93`\x14Rcp\xA0\x821``\x1B_RZ\xFA`\x1F=\x11\x16` Q\x02\x90V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x06\x14a;\xFCW`\x05\x14a;\xEEWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[_h\x92\x9E\xEE\x14\x9BK\xD2\x12h]V[P_T`\xFF\x16\x15a<\x15W_h\x92\x9E\xEE\x14\x9BK\xD2\x12h]V[_h\x92\x9E\xEE\x14\x9BK\xD2\x12hUV[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W` \x01\x91``\x82\x026\x03\x83\x13a\x07\xD3WV[`\xA0\x90`@Q\x90\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x82R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x83\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x83\x01R``\x82\x01R0`\x80\x82\x01R \x90V[\x90`@Q\x91_Q` a_\xA5_9_Q\x90_R_R_Q` a_\xC5_9_Q\x90_R` R_Q` a_\x85_9_Q\x90_R`@R`\x05\x1BQ\x91`@RV[`\xA0\x90`\x80`@Q\x91\x7F\xE0UI5c8\\\xC5\x88\xFF\xFA\xCB\xFF\xE2\xDA\xB0#\xFE\xF8\x07\xBA\xA4IS\x041\x16\x9B\x0E\xEB[i\x83R` \x83\x017 \x90V[\x90a=\\a9\xD1V[a=|a=t`\xA45`\xC45`\xE45a \x82\x87aH\xDCV[\x920\x90a;\x85V[\x90`@Q\x90c\x13|)\xFE\x82R`\x80`\x04` \x84\x0170`\xA0\x83\x01R`$5`\xC0\x83\x01R`\x845`\xE0\x83\x01Ra\x01@a\x01 \x83\x01Ra\x01`\x82\x01\x90V[`\x80\x7Fcipient)TokenPermissions(address\x91`\x96\x81R\x7FCompactDeposit witness)CompactDe` \x82\x01R\x7Fposit(address allocator,uint8 re`@\x82\x01R\x7FsetPeriod,uint8 scope,address re``\x82\x01Ru token,uint256 amount)`\x96\x82\x01R\x01RV[\x90\x93\x80_\x94\x93`\x1C\x92\x86\x95\x82a>\x86aN\xAFV[\x99\x87\x01R`@\x83\x87\x01\x83` \x82\x01R\x017\x01`$\x01\x91\x01\x82n\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3Z\xF1\x16\x15a>\xB8WV[=a\x07\xCBWc\x7F(\xC6\x1E_R`\x04`\x1C\xFD[a>\xD8\x90\x92\x91\x920\x90a;\x85V[\x92\x83\x81\x10\x15a>\xECWa9?\x93\x03\x91aC|V[cBm\x8D\xCF_R`\x04`\x1C\xFD[j\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFj\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`I\x1C\x16\x81\x83`H\x1C\x16\x17\x80`\x02\x1C\x17\x80`\x04\x1C\x17\x80`\x08\x1C\x17\x80`\x10\x1C\x17\x80` \x1C\x17gUUUUUUUU\x81`\x01\x1C\x16\x90\x03g33333333\x80\x82`\x02\x1C\x16\x91\x16\x01\x80`\x04\x1C\x01g\x0F\x0F\x0F\x0F\x0F\x0F\x0F\x0Ff\x0F\x0F\x0F\x0F\x0F\x0F\x0F\x82`\x08\x1C\x16\x91\x16\x01\x80`\x10\x1C\x01\x91\x16\x90i\x0F\xED\xCB\xA9\x87eC!\0\0`\x0F`X\x1B\x91`\x7F`\x03\x19\x91\x80` \x1C\x01\x16`H\x03\x16\x1C`X\x1B\x16\x17\x90V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x15a?\xBFWPV[c\xCF\x90\xC3\xA8_R` R`$`\x1C\xFD[`@Q\x91` Rc\x03\xF3{\x1A`\x0CR\x80`@R`7`( \x90`\x01\x82T\x91`\xFF\x16\x1B\x90\x80\x82\x16a@\x01W\x17\x90U`@RV[c\xDB\xC2\x05\xB1``\x1B`\x0CR`D`\x1C\xFD[\x91a@ `@\x82\x015aOQV[\x805\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x91\x825\x92`\x01`\x01`@\x1B\x03\x84\x11a\x07\xD3W` \x01\x92\x806\x03\x84\x13a\x07\xD3Wa9?\x93a@i\x91a@aa7\xC8V[\x91\x85\x85aOlV[3aP\xBCV[\x90\x92\x91\x83\x15\x91a@\x81\x85\x82`8aZ\xA0V[\x91a@\x95a@\x8E\x84aHbV[\x80\x92a?\xCFV[\x94`\x01`\x01``\x1B\x03`\x01\x93\x16\x90[\x80\x84\x10a@\xC2WPPPPa@\xB5WV[c:\x03\xD3\xBB_R`\x04`\x1C\xFD[\x90\x91\x92\x93`\x01\x90\x83`\x01`\x01``\x1B\x03a@\xDF\x88\x86\x89`8a[\nV[\x16\x14\x15\x17\x94\x01\x92\x91\x90a@\xA4V[\x91\x90\x93\x92\x84\x15\x92a@\xFF\x86\x82\x84aZ\xA0V[\x92aA\x0Ca@\x8E\x85aHbV[\x95`\x01`\x01``\x1B\x03`\x01\x94\x16\x91[\x81\x85\x10aA-WPPPPPa@\xB5WV[\x90\x91\x92\x93\x94`\x01\x90\x84`\x01`\x01``\x1B\x03aAJ\x89\x87\x87\x8Ba[\nV[\x16\x14\x15\x17\x95\x01\x93\x92\x91\x90aA\x1BV[\x91\x90_[\x81\x81\x10aAmWPPPP`\x01\x90V[\x80aA\x8C\x84aA\x7F`\x01\x94\x86\x89a8\xCDV[` \x81\x015\x9053aA\xB4V[\x01aA]V[\x91\x90\x81\x10\x15a*mW`\x05\x1B\x81\x015\x90`>\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x90V[\x91\x92\x90\x92`@Q\x90\x83`\x14\x83\x01Rch\xA3\r\xD0\x82R`4\x82\x01\x94\x85R`T\x82\x01R`X`\x1C\x82\x01 \x82B\x01\x92b'\x8D\0\x81\x11\x82T\x85\x10\x17aB)WP\x82\x90U`t\x01R`\x01`\x01`\xA0\x1B\x03\x16\x90\x7F\xF7\x8A/3\xFF\x80\xEFC\x91\xF7D\x9Ct\x8D\xC2\xD5w\xA6,\xD6E\x10\x8FO@i\xF4\xA7\xE0c[j\x90``\x90\xA2V[c\x1F\x9A\x96\xF4_R` R`$`\x1C\xFD[\x93\x91\x95\x90\x94\x97\x96\x92\x86\x01\x95\x865\x95` \x88\x015\x97``\x81\x015\x98aB]\x89\x87aR\xBFV[\x89\x81\x10aB\x9CWP\x91aB\x99\x99\x9A\x93\x91aB\x93\x95\x93`@`\x01\x80`\xA0\x1B\x03\x91\x015\x16\x97`\x01`\x01`\\\x1B\x03\x8A`\xA0\x1C\x16\x90aLJV[\x90a\\1V[\x90V[\x89\x90c0x\xB2\xF6_R` R`@R`D`\x1C\xFD[\x90\x91aB\xBC\x81a>\xF9V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x90\x91\x18a?\xBFW`\xA0\x1B\x91`\xFC\x1B\x90`\xFF\x1B\x17\x17\x90V[aB\xEB\x82a>\xF9V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x90\x92\x18aC\x0FW`\x03`\xFC\x1B\x91`\xA0\x1B\x17\x17\x90V[Pc\xCF\x90\xC3\xA8_R` R`$`\x1C\xFD[aC)\x81a>\xF9V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x90\x91\x18a?\xBFW`\xA0\x1B`\x03`\xFC\x1B\x17\x90V[\x92aCU\x81a>\xF9V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x90\x91\x18a?\xBFW`\xA0\x1B\x91`\xFC\x1B\x90`\xFF\x1B\x17\x17\x17\x90V[\x90\x91g\xED\xCA\xA8\x9A\x82)9@` R\x81`\x14R\x82_R`@_ \x80T\x90\x82\x82\x01\x91\x82\x10a\x07eWU3_R` R`\x01\x80`\xA0\x1B\x03\x16__Q` a_e_9_Q\x90_R`@\x82\xA4V[\x93\x91\x94\x92_\x91` \x86\x01\x92_\x93_\x95\x15\x90\x81aH\x1FW[\x85\x15aG\xCEW[P_\x92\x80\x15aG:W[_\x19\x81\x01\x15aF\x9BW[\x83\x15aE\xE1W[\x84\x15aD`WPPP\x81\x84\x95\x96\x97\x827\x01\x94nuint256 amount)`\x0E\x87\x01R\x7F)TokenPermissions(address token,_\x19\x87\x01R`\x0E\x81\x87\x03\x01\x90R\x80\x85\x03\x90 \x93\x03\x90 \x90V[\x91\x98P\x96\x93P\x83\x91\x94P`\x0E\x92P`\x05\x1B\x93nuint256 amount)\x83\x82\x01R\x7F)TokenPermissions(address token,_\x19\x82\x01R\x03\x01\x90R`@Q\x92aEmW[\x83\x15aD\xF9W[_Q` a_\xA5_9_Q\x90_R_R_Q` a_\xC5_9_Q\x90_R` R_Q` a_\x85_9_Q\x90_R`@RQ\x91`@RV[\x7FE\x01-B\xFA\xD8\xC9\xE97\xCF\xF5\xA2\xD7P\xEE\x18q=\xD4Z\xAD\xCDq\x86`\xD5R0Va\x8D\x99_R\x7F\xC2\xE1j\x82;\x8C\xDD\xDF\xDF\x88\x99\x91\xD7\xA4a\xF0\xA1\x9F\xAF\x1F\x8E`\x8F\x1C\x16D\x95\xA5!Q\xCC>` R\x7F\xD2\xF6\xAD9\x13(\x93o\x11\x82P\xF21\xE6<~c\x9F\x97V\xA9\xEB\xF9r\xD8\x17c\x87\nw-\x87`@R\x80Q\x93PaD\xC0V[\x7F+\xF9\x81\xC4,\x7FB;\x06\xFAI\xBA\x99m)0\x88~/\x1FS\xD9\xA2k\x8Ct#\xAC\x1C\xF8>a_R\x7F\xD1DE\xD7\x82\x13\xA5\xAC\xDD\xFA\x89\x17\x1B\x01\x99\xDER\x1C;6s\x8B\x83Rd\xCA\xE1\x8FZS\xDB\xF3` R\x7F2\x9B<Rz<t\xB8\xCA\xBCQ\xC3\x04f\x9D\x18f\xB8sR\xCA\xFD\xF4@\xEF+\xEC\xD6\xDC&\x1D\x1E`@R\x80Q\x93PaD\xB9V[\x7FMultichainCompact compact)Multic\x87R\x7FhainCompact(address sponsor,uint` \x88\x01R\x7F256 nonce,uint256 expires,Segmen`@\x88\x01Ro] idsAndAmounts,`p\x88\x01R\x7Fiter,uint256 chainId,uint256[2][``\x88\x01R`\x1A\x87\x01\x96`\x90\x01\x93PaC\xFFV[\x7FBatchCompact compact)BatchCompac\x87R\x7Ft(address arbiter,address sponso` \x88\x01Rzuint256[2][] idsAndAmounts,`[\x88\x01R\x7Fr,uint256 nonce,uint256 expires,`@\x88\x01R`\x15\x87\x01\x96`{\x01\x93PaC\xF8V[\x7FCompact compact)Compact(address \x87R\x7Farbiter,address sponsor,uint256 ` \x88\x01Ro,uint256 amount,`P\x88\x01R\x7Fnonce,uint256 expires,uint256 id`@\x88\x01R`\x10\x87\x01\x96`p\x01\x93PaC\xEEV[uivation(uint256[] ids,`6\x8A\x01R\x7FBatchActivation witness)BatchAct\x90R`V\x88\x01\x95P`8\x88\x01\x94P_aC\xE4V[hnt256 id,`)\x8A\x01R\x7FActivation witness)Activation(ui\x81R`I\x89\x01\x96P`3\x89\x01\x95PaC\xDDV[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x91\x90\x82\x15a?\xBFWPV[\x91\x90aH\x880\x84a;\x85V[\x92`@Q\x94``R0`@R3``\x1B`,Rc#\xB8r\xDD``\x1B`\x0CR` _`d`\x1C\x82\x85Z\xF1=\x15`\x01_Q\x14\x17\x16\x15aH\xCFWa9?\x94_``R`@Ra>\xCAV[cy9\xF4$_R`\x04`\x1C\xFD[\x80``\x1B\x15aH\xE8W\x90V[c\x96\x1C\x9AO`@R`$`\\\xFD[\x90\x80\x15\x15_R` R3\x7F\xE2\x7F^\x03\x82\xCFSG\x96_\xC8\x1D\\\x81\xCD\x14\x18\x97\xFE\x9C\xE4\x02\xD2,Ik|-\xDC\x84\xE5\xFD`@_\xA3V[`\x01`\x01`@\x1B\x03\x81\x11a\x15\xA0W`\x05\x1B` \x01\x90V[\x90aIH\x82aI'V[aIU`@Q\x91\x82a5\xF9V[\x82\x81R\x80\x92aIf`\x1F\x19\x91aI'V[\x01\x90` 6\x91\x017V[\x80Q\x82\x10\x15a*mW` \x91`\x05\x1B\x01\x01\x90V[\x91\x92aI\x8Ea9\xD1V[`\x01`\x01`\xA0\x1B\x03\x835\x16\x15\x92` \x81\x0154\x90\x81\x14\x15\x85\x16\x90\x15\x85\x14\x17\x83\x15\x17a9\xC4W\x83\x92aI\xC6`\x845`\xA45`\xC45aB\xB1V[\x95aI\xD0\x82aI>V[\x94aJmW[P\x84\x81\x03\x95aI\xE4\x87aI>V[\x92_\x92_[\x89\x81\x10aJ\x08WPPPPaI\xFBW\x90V[c\x0F/\x1EQ_R`\x04`\x1C\xFD[\x80aJY\x8A`\x01\x93\x97\x95\x96\x97\x01\x94aJ)aJ$\x87\x87\x8Aa8\xCDV[a7\xB4V[\x90\x84\x80`\xA0\x1B\x03\x82\x16`\x01`\x01``\x1B\x03`\xA0\x1B\x8A\x16\x17\x98\x89\x11\x15\x17\x97aJQ\x81\x97\x8DaIpV[R0\x90a;\x85V[aJc\x82\x89aIpV[R\x01\x92\x91\x92aI\xE9V[aJy\x90\x874\x91aC|V[\x83Q\x15a*mW\x85` \x85\x01R_aI\xD6V[\x91`@Q\x91\x83`\x06\x1B\x84`\x07\x1B\x91`\x06\x1B`$5\x01c\xFE\x8E\xC1\xA7\x85R`\xC0` \x86\x01R\x81a\x01@\x01`@\x86\x01R`\x045``\x86\x01R\x82a\x01`\x01`\xA0\x86\x01R```\xE0\x86\x01R`D5a\x01\0\x86\x01R`d5a\x01 \x86\x01R\x85a\x01@\x86\x01R\x81`$\x82\x01a\x01`\x87\x017\x81\x85\x01\x95a\x01`\x87\x01R_[\x82\x81\x10aK\x18WP\x93\x94PP\x83\x01a\x01\x80\x01\x91PV[\x80`@\x91\x88\x010a\x01\x80\x82\x01Ra\x01\xA0`D\x83\x86\x01\x015\x91\x01R\x01aK\x02V[\x83Q_\x96\x90\x95\x94\x93\x92\x90\x87[\x87\x81\x10aK_WPPPPPPPPa>\xECWa9?a;\xAAV[\x80aK\xA7\x83`\x01\x93\x01\x9AaK\x81\x8CaK|aJ$0\x92\x8C\x8Ba8\xCDV[a;\x85V[\x90aK\x9DaK\x8F\x85\x8CaIpV[Q\x91\x83\x83\x10\x15\x17\x9D\x89aIpV[Q\x91\x03\x90\x8AaC|V[\x01aKDV[\x90aK\xB7\x82a6\x1AV[aK\xC4`@Q\x91\x82a5\xF9V[\x82\x81R\x80\x92aIf`\x1F\x19\x91a6\x1AV[\x90\x15a*mW\x90V[\x91\x90\x81\x10\x15a*mW``\x02\x01\x90V[\x81`\x06\x1B\x82\x81\x04`@\x14\x83\x15\x17\x15a\x1E\xFEWaL\t\x90aK\xADV[\x91_[\x81\x81\x10aL WPPP` \x81Q\x91\x01 \x90V[\x80aL.`\x01\x92\x84\x86aK\xDEV[`@` \x83`\x06\x1B\x88\x01\x92\x805\x82\x85\x01R\x015\x91\x01R\x01aL\x0CV[`@\x84\x015`\x01`\x01`\xA0\x1B\x03\x16\x97\x96\x90\x95\x93\x94\x86\x94\x89\x94\x91\x93\x875\x88\x01\x93` \x89\x015\x89\x01\x92\x90\x91\x835\x91\x90aL\x84`\x80\x8C\x015aOQV[aL\x8D\x90aHbV[``\x81\x9B\x015\x90aL\x9D\x91a?\xCFV[\x86\x81\x15\x02\x01\x91\x81\x15\x15\x87\x84\x14\x15\x17\x90\x81\x15\x9BaL\xD4\x99a9?\x9DaL\xF0W[PPPaL\xDAW[PPP\x85\x825\x92` \x01\x91aOlV[\x84aP\xBCV[aL\xE8\x92` \x01\x8C\x89aOlV[_\x80\x80aL\xC4V[aM\x1B\x93P`X\x92`\x1C\x92`@Q\x92`\x14\x84\x01Rch\xA3\r\xD0\x83R`4\x83\x01R`T\x82\x01R\x01 T\x90V[B\x10\x15_\x89\x8EaL\xBCV[\x98\x97\x93\x80\x95\x91\x96aMk\x93\x98\x94\x89\x01\x98\x895\x81\x01\x98` \x8A\x81\x01\x9A5\x9B\x015\x97aMcaMS\x8D\x8DaK\xD5V[5`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x90V[\x9D\x8E\x91a^EV[\x90aMv\x86\x86aK\xD5V[\x95aM\x9F` aM\x93\x87\x8A5\x80\x9B`@\x81\x015\x94\x85\x91\x015aS\\V[\x83\x15\x17\x98\x86\x86\x86a\\1V[P`\x01`\x01``\x1B\x03`\x01\x99\x16\x98[\x81\x81\x10aM\xC7WPPPPPPPa7\x12\x91\x92PaSmV[aM\xD2\x81\x83\x89aK\xDEV[\x805\x98\x89\x91\x88`@\x82\x015\x9B\x8C\x92` \x015\x92aM\xEE\x93aS\\V[\x8C\x83`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x14\x15\x17\x17\x98aN\r\x91\x87\x87\x87a\\1V[P`\x01\x01aM\xAEV[\x90\x15a*mW\x805\x90`^\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x90V[\x91\x90\x81\x10\x15a*mW`\x05\x1B\x81\x015\x90`^\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x90V[\x81`\x06\x1B\x82\x81\x04`@\x14\x83\x15\x17\x15a\x1E\xFEWaNn\x90aK\xADV[\x91_[\x81\x81\x10aN\x85WPPP` \x81Q\x91\x01 \x90V[\x80aN\x93`\x01\x92\x84\x86aN1V[`@` \x83`\x06\x1B\x88\x01\x92\x805\x82\x85\x01R\x015\x91\x01R\x01aNqV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a7\x12Wn\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3;\x15\x15\x90V[`\xA0\x92\x91`@``\x92\x81Q\x94\x84\x86\x01R_Q` a_E_9_Q\x90_R\x85R\x85` \x86\x01\x933\x85RF\x84\x88\x01R`\x80\x87 \x87R\x82\x01\x015\x81\x01\x805`\x05\x1B\x80\x91` \x01\x857` \x01\x85 `\x80\x86\x01R_Q` a_\x85_9_Q\x90_R\x85R\x01\x907 \x90V[B\x81\x11\x15aO\\WPV[c\xF8\r\xBA\xEA_R` R`$`\x1C\xFD[`@\x80Qa\x19\x01_\x90\x81R` \x97\x90\x97R\x91\x81R`B`\x1E \x91\x81R\x91\x93\x90\x92\x90\x91`d\x83\x01\x90\x83\x14`\x01`\x01`\xA0\x1B\x03\x86\x16`A\x85\x14\x81aO\xC7W[PPPPPPP3\x14\x17\x15aO\xBAWV[c\x8B\xAAW\x9F_R`\x04`\x1C\xFD[\x90\x91\x92\x93\x94\x95\x97P`@Q\x92\x88_RaPlW[aP-W[` \x94\x95\x96_``R\x82`@Rc\x0B\x13]?`\xE1\x1B\x83R`\x04\x83\x01R`$\x82\x01\x95\x86\x94`@\x86R\x81`D\x85\x01R`d\x84\x017Z\xFA\x90Qc\x0B\x13]?`\xE1\x1B\x14\x16\x90_\x80\x80\x80\x80\x80\x80aO\xA9V[`@\x84\x015_\x1A` R`@\x84\x817` `\x01`\x80_\x82Z\xFAQ\x81\x18=\x15\x17aO\xE0WP\x94PPPP`\x01\x91_``R`@R_\x80\x80\x80\x80\x80\x80aO\xA9V[` \x85\x81\x015`\xFF\x81\x90\x1C`\x1B\x01\x82R\x865`@R`\x01`\x01`\xFF\x1B\x03\x16``R`\x01`\x80_\x82Z\xFAQ\x82\x18=\x15\x17aO\xDBWPP\x94PPPP`\x01\x91_``R`@R_\x80\x80\x80\x80\x80\x80aO\xA9V[_\x91\x82R3\x92`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x91\x16\x90\x7Fw\x0C2\xA21Kp\rb9\xEE5\xBA#\xA9i\x0F/\xCE\xB9:U\xD8\xC7S\xE9S\x05\x9B;\x18\xD4\x90` \x90\xA4V[`@Q\x92``\x84\x01R_Q` a_E_9_Q\x90_R\x83R` \x83\x01\x913\x83RF`@\x85\x01R`\x80\x84 \x90\x82\x01\x90`\xA0\x82\x015\x83\x01\x90`\xC0\x825`\x05\x1B\x93\x015`\x05\x1B_\x90_[\x85\x81\x10aQxWPPPPP\x91`@``\x92`\xA0\x95\x94` \x01\x85 `\x80\x86\x01R_Q` a_\x85_9_Q\x90_R\x85R\x01\x907 \x90V[\x80\x89\x01` \x84\x83\x01\x87\x01\x015\x81R\x82\x82\x14aQ\x97W[P` \x01aQAV[` \x90\x81\x01\x85\x90R\x92P\x82aQ\x8EV[\x94\x91\x95\x84\x91\x97\x96aQ\xD4\x94\x81\x015\x81\x01\x98\x89` \x01\x995\x9AaQ\xCCaMS\x8D\x8DaN\x16V[\x98\x89\x91a^EV[\x85\x15\x95`\x01`\x01``\x1B\x03_\x94\x16\x93[\x81\x81\x10aQ\xFBWPPPPPPPa7\x12\x90aSmV[\x80aRI\x87aR\r`\x01\x94\x86\x8CaN1V[\x805\x9B\x8C\x8A`\x01`\x01`\\\x1B\x03aR$\x8C\x84aS\xB0V[\x92`\xA0\x1C\x16\x14\x15\x17\x17\x9B\x87` aR>`@\x85\x01\x85a7\x7FV[\x91\x90\x94\x015\x93aS\xC6V[P\x01aQ\xE4V[aB\x99\x90aRu`@6\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90`1aVQV[\x92\x91\x90_[\x81\x81\x10aR\x90WPPPPPV[\x80aR\xB8aR\xA1`\x01\x93\x85\x89a8\xCDV[\x85` aR\xAD\x83a7\xB4V[\x92\x015\x913\x89a\\1V[P\x01aR\x82V[\x81`\xFF\x1C\x15\x90\x15\x17\x15aR\xCFWPV[c\xA0cV\xF5_R` R`$`\x1C\xFD[\x95\x84\x90aS\x0E\x93\x99\x94\x96\x92\x96\x8A\x01\x99\x8A5\x97\x88\x96`@\x8D\x015\x83\x01\x9A`\x01`\x01`\\\x1B\x03\x89`\xA0\x1C\x16\x91a^EV[\x95aS\x1F` \x92aB\x99\x98\x94aR\xBFV[\x015\x92\x805\x90` \x01aS\xC6V[`\xA0\x91`@Q\x93\x82\x01\x91`\xC0\x83\x015\x01\x90\x815\x93\x84\x93\x015\x85R` \x85\x01R` \x01`@\x84\x017`@\x01\x90 \x90V[\x92aSg\x91\x92aS\xB0V[\x91\x10\x17\x90V[a@\xB5WV[`\xC0\x91`@\x80Q\x92_Q` a_\xC5_9_Q\x90_R\x84R3` \x85\x01R3\x82\x85\x01R` \x81\x015``\x85\x01R\x015`\x80\x83\x01R`\xA0\x82\x01R \x90V[`\xFF\x1C`\x02\x81\x10\x15a\x15\x8CW`\x01\x14\x90\x15\x15\x16\x90V[\x91\x94\x92\x90\x92_\x95\x84\x15\x94_[\x81\x81\x10aT\x01WPPPPPP\x82\x82\x10\x17aS\xEEWPP`\x01\x90V[c0x\xB2\xF6_R` R`@R`D`\x1C\xFD[\x80aT4` \x9A\x98\x87aT-aT\x1A`\x01\x96\x88\x8Da8\xCDV[\x9D\x8E\x015\x92\x8C\x84\x01\x9C\x8D\x10\x17\x9B\x9Da7\xB4V[\x87\x89a\\1V[P\x01aS\xD2V[\x90`@Q\x91`\xC0\x81\x015\x01\x91\x825\x80\x93\x7FMultichainCompact(address sponso\x83R\x7Fr,uint256 nonce,uint256 expires,` \x84\x01R\x7FSegment[] segments)Segment(addre`@\x84\x01Ru56[2][] idsAndAmounts,`v\x84\x01R\x7Fss arbiter,uint256 chainId,uint2``\x84\x01R` \x01`\x96\x83\x017\x82`C\x01`S\x82\x01 \x92`\x96\x01\x90 \x90V[aB\x99\x906\x15\x90`(aVQV[\x90aB\x99aU8`@6\x15\x17\x84`(aVQV[\x92\x836\x15\x91aS-V[aUm\x90aUg`\x806\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a[\x8AV[\x90\x91V[aUm\x90aU\x96`@6\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a[fV[\x90aB\x99aU8aU\xC4`\x806\x15\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84`2aVQV[\x90aB\x99aU8a\x0Bk`@6\x15\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[aV\x1F\x90aV\x19`\x806\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a[\xD9V[\x91\x92\x90\x91\x90V[aV\x1F\x90aVK`\xC06\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a\\\nV[\x91\x90\x91\x80`2\x14aWdW\x80`1\x14aWWW\x80`0\x14aWGW\x80`+\x14aW\x16W\x80`/\x14aW\tW\x80`(\x14aV\xC8W\x80`3\x14aV\xB0W`*\x14aV\xA7WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x91aSsV[P`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[P`\xC0`\xE0\x92```@\x80Q\x94\x83\x01\x92_Q` a_\xA5_9_Q\x90_R\x86R3` \x87\x01R\x01`@\x85\x017`\xA0\x81\x015`\xA0\x84\x01R\x015`\xC0\x82\x01R \x90V[PaB\x99\x916\x15\x90aN\xEAV[P\x90`\xC0\x91```@\x80Q\x93_Q` a_\xC5_9_Q\x90_R\x85R3` \x86\x01R\x01`@\x84\x017`\xA0\x82\x01R \x90V[PaB\x99\x91`@6\x15\x17\x90aN\xEAV[PaB\x99\x916\x15\x90aP\xF9V[PaB\x99\x91`@6\x15\x17\x90aP\xF9V[\x90a\x01\0`@Q`\xA0`\xC0\x85\x015\x85\x01\x94``\x865\x96\x7FCompact(address arbiter,address \x85R` \x85\x01\x97\x7Fsponsor,uint256 nonce,uint256 ex\x89R\x80`@\x87\x01\x92\x7Fpires,uint256 id,uint256 amount,\x84R` \x01\x84\x88\x017\x82\x01\x85 \x97\x88\x86R3\x90R`@\x83\x01\x907`\xE0\x81\x015\x82\x84\x01R\x83\x81\x015`\xC0\x84\x01R\x015`\xE0\x82\x01R \x91\x90V[`\xE0\x90\x92\x91\x92`\xA0`@Q\x91`\xC0\x81\x015\x81\x01\x95``\x875\x97\x7FBatchCompact(address arbiter,add\x86R` \x86\x01\x98\x7Fress sponsor,uint256 nonce,uint2\x8AReounts,`F\x88\x01R\x80`@\x88\x01\x92\x7F56 expires,uint256[2][] idsAndAm\x84R` \x01`f\x89\x017`f\x01\x86 \x98\x89\x87R3\x90R`@\x84\x01\x907\x82\x84\x01R\x015`\xC0\x82\x01R \x91\x90V[\x92\x91\x92\x80`,\x14aY\xDFW`)\x14aY\x1DWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a\x01\0\x90`\xA0`@Q\x91\x83`\xC0\x82\x015\x82\x01\x96``\x885\x98\x7FCompact(address arbiter,address \x87R` \x87\x01\x99\x7Fsponsor,uint256 nonce,uint256 ex\x8BR\x80`@\x89\x01\x92\x7Fpires,uint256 id,uint256 amount,\x84R` \x01\x84\x8A\x017\x82\x01\x87 \x99\x8A\x88R3\x90R`@\x85\x01\x907\x82\x01`\xE0\x81\x015\x84\x86\x01R\x015`\xC0\x84\x01R\x015`\xE0\x82\x01R \x91\x90V[P`\xE0\x90`\xA0`@Q\x91`\xC0\x81\x015\x81\x01\x95``\x875\x97\x7FBatchCompact(address arbiter,add\x86R` \x86\x01\x98\x7Fress sponsor,uint256 nonce,uint2\x8AReounts,`F\x88\x01R\x80`@\x88\x01\x92\x7F56 expires,uint256[2][] idsAndAm\x84R` \x01`f\x89\x017`f\x01\x86 \x98\x89\x87R3\x90R`@\x84\x01\x907\x82\x84\x01R\x015`\xC0\x82\x01R \x91\x90V[\x91\x90\x91\x80`8\x14aZ\xF4W\x80`9\x14aZ\xD8W`\x07\x14aZ\xCEWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x91_aVQV[P_aZ\xEC\x91`\x01`\x01`\\\x1B\x03\x93aA\x92V[5`\xA0\x1C\x16\x90V[P\x15a*mW5`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x90V[\x80`8\x14a[RW\x80`9\x14a[>W`\x07\x14a[5WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x92aVQV[P\x91aZ\xEC\x91`\x01`\x01`\\\x1B\x03\x93aA\x92V[P\x91aZ\xEC\x91`\x01`\x01`\\\x1B\x03\x93a8\xCDV[\x91\x90a[\x86\x90a[u\x84aT;V[\x94\x90\x85\x91`@6\x15\x17\x90`-a\\\xE7V[\x91\x90V[\x91\x90a[\x86\x90a[\x99\x84aT;V[\x94\x90\x85\x91`@6\x15\x17\x90`.a\\\xE7V[\x91a[\xBAa[\x86\x92\x84`,aX\xF7V[\x92\x90\x93\x84`@6\x15\x17\x91aS-V[\x91a[\xBAa[\x86\x92\x84`)aX\xF7V[\x91a[\x86`@\x93a\\\0\x93a[\xED\x82aT;V[\x95\x90\x91\x866\x15\x93`\x80\x85\x17\x86`-a\\\xE7V[\x95\x86\x91\x17\x91aS-V[\x91a[\x86`@\x93a\\\0\x93a\\\x1E\x82aT;V[\x95\x90\x91\x866\x15\x93`\x80\x85\x17\x86`.a\\\xE7V[\x93\x92\x91\x90\x93\x80`5\x14a\\\xDDW\x80`4\x14a\\jW`7\x14a\\aWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x93a@\xEDV[P\x90\x92\x91g\xED\xCA\xA8\x9A\x82)9@` R\x82`\x14R\x83_R`@_ \x80T\x80\x83\x11\x83\x15\x17a\x07rW\x82\x90\x03\x90U\x81`\x14R\x83_R`@_ \x80T\x90\x82\x82\x01\x91\x82\x10a\x07eWU3_R` R`\x01\x80`\xA0\x1B\x03\x16\x90`\x01\x80`\xA0\x1B\x03\x16_Q` a_e_9_Q\x90_R`@_\xA4`\x01\x90V[PaB\x99\x93a6\x97V[\x95\x94\x93\x91\x90\x92\x95\x80`-\x14a]\xCEW`.\x14a]\x11WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[`@Q\x93``\x85\x01R\x85\x84R_Q` a_E_9_Q\x90_R` \x85\x01\x963\x88RF`@\x87\x01R\x14\x15\x80a]\xBFW[`\x05\x1B`\x80\x01\x84 \x90\x83\x01\x90`\xA0\x82\x015\x84\x01\x90`\xC0\x825`\x05\x1B\x93\x015`\x05\x1B_\x90_[\x85\x81\x10a]\x90WPPPPP``\x92`\xA0\x95\x96\x92`@\x92` \x01\x86 `\x80\x87\x01R\x85R\x01\x907 \x90V[\x80\x89\x01` \x84\x83\x01\x87\x01\x015\x81R\x82\x82\x14a]\xAFW[P` \x01a]fV[` \x90\x81\x01\x85\x90R\x92P\x82a]\xA6V[`\xA0\x84\x015`\x80\x86\x01Ra]AV[P``\x92`\xA0\x95\x96\x92\x86`@\x93\x84Q\x97\x87\x89\x01R\x85\x88R_Q` a_E_9_Q\x90_R` \x89\x01\x963\x88RF\x87\x8B\x01R\x14\x15\x80a^7W[`\x05\x1B`\x80\x01\x88 \x88R\x83\x01\x015\x82\x01\x805`\x05\x1B\x80\x91` \x01\x867` \x01\x86 `\x80\x87\x01R\x85R\x01\x907 \x90V[\x82\x85\x015`\x80\x8A\x01Ra^\x08V[\x96\x95\x94\x93\x92\x91\x90\x96\x80`'\x14a_1W\x80`$\x14a_\x1CW\x80`!\x14a_\x07W\x80`#\x14a^\xF7W\x80`\x1F\x14a^\xE2W\x80`&\x14a^\xCFW\x80`\"\x14a^\xC4W\x80`%\x14a^\xB1W`\x17\x14a^\xA8WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x96aLJV[P\x90`\x17\x95\x94\x93\x92\x91\x87aB\x99\x98aR\xDFV[P\x86aB\x99\x97aB9V[P\x90`\x17\x95\x94\x93\x92\x91\x87aB\x99\x98aM&V[P\x91aB\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93aM&V[P\x90aB\x99\x96\x92\x916\x15\x93aB9V[P\x91aB\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93aQ\xA7V[P\x91aB\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93aR\xDFV[P\x90`\x17\x95\x94\x93\x92\x91\x87aB\x99\x98aQ\xA7V\xFE)_\xEB\tWg\xCCg\xD7\xE7F\x95\xDA\n\xDA\xDD\xED\xE5M{q\x94\xA8\xA5Bo\xE8\xF05\x1E\x037\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y\\\xA9\xA6k\x8B\xBF\r#\x16\xE9\r\xFA=\xF4e\xF0y\x0B'{%9:>\xF4\xD6~\x1FP\x86PW\xCD\xCA\x95\x0B\x17\xB5\xEF\xC0\x16\xB7K\x91-\x85'\xDF\xBA^@Jh\x8C\xBC=\xAB\x16\xCB\x942\x87\xFE\xC2Z\x7F\xEE\x80\0\xA27\x92\x9E\xF9\xBE\x08\xF2\x93<KO2\x0B\0\xB3\x88\t\xF3\xC7\xAA\x10MT!\x04\x9F\xA1dsolcC\0\x08\x1C\0\n`\x80\x80`@R4`\x15Wa>\x10\x90\x81a\0\x1A\x829\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80b\xAD\x80\x0C\x14a7\x04W\x80cNA\xA1\xFB\x14a6\x96Wc\xD67\xCA\x8D\x14a\09W_\x80\xFD[4a6~W6`\x03\x19\x01`\xA0\x81\x12a6~W`\x80\x13a6~W`@Q`\x80\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a6\x82W`@R`\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x81\x83\x03a6~W\x82\x81R`$5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a6~W` \x81\x01\x91\x82R`D5\x92`\x08\x84\x10\x15a6~W`@\x82\x01\x93\x84R`d5\x94`\x02\x86\x10\x15a6~W``\x83\x81\x01\x96\x87R\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16a6lWPa\x01\x1C`@Qa\0\xF2`@\x82a7\x93V[`\x0C\x81Rk'0\xBA4\xBB2\x90*7\xB5\xB2\xB7`\xA1\x1B` \x82\x01R\x92[Q`\x01`\x01`\xA0\x1B\x03\x16a8\xA1V[\x92Q`\x08\x81\x10\x15a6XWa\x010\x90a9\xC8V[\x93Q`\x02\x81\x10\x15a6XWa\x01D\x90a;\xBAV[\x81Qa\x01X\x90`\x01`\x01`\xA0\x1B\x03\x16a7\xB5V[\x82Q\x90\x91\x90a\x01o\x90`\x01`\x01`\xA0\x1B\x03\x16a84V[\x92Qc1<\xE5g`\x04\x90\x81R_\x81\x90R` \x91\x82\x91\x90\x82\x90`\x01`\x01`\xA0\x1B\x03\x16b\x01\x86\xA0\xFA=`\x1F\x10\x16` Q\x02`\xFF\x16a\x01\xAA\x90a<YV[\x91`@Q\x95` \x87\x01\x97q\x03\xD9\x13s\x0Bk)\x11\xD1\x01\x12\x1B{k\x83\x0B\x1B\xA1`u\x1B\x89R\x87\x86Q\x80` \x89\x01`2\x84\x01^\x81\x01a\x08\x8B`\xF2\x1B`2\x82\x01R\x03`2\x01`\x1D\x19\x81\x01\x89R`\x02\x01a\x01\xFE\x90\x89a7\x93V[`@Q\x94` \x86\x01\x94\x7F\"description\": \"Compact \0\0\0\0\0\0\0\0\x86R\x84Q\x80` \x87\x01`8\x8A\x01^\x87\x01`8\x81\x01a\x04\x05`\xF3\x1B\x90R\x89Q\x90\x81` \x8C\x01`:\x83\x01^\x01`8\x01`\x02\x81\x01\x7F) resource lock with allocator \0\x90R\x84Q\x90\x81` \x87\x01`!\x83\x01^\x01`\x02\x01\x93`\x1F\x85\x01t\x01\x03\x0Bs!\x03\x93+\x9B+\xA1\x03\x83+\x93K{!\x03{1`]\x1B\x90R\x87\x84Q` \x86\x01\x96\x81\x88`4\x83\x01^\x01`\x1F\x01a\x08\x8B`\xF2\x1B`\x15\x82\x01R\x03`\x15\x01`\x1D\x19\x81\x01\x89R`\x02\x01a\x02\xE3\x90\x89a7\x93V[a\x02\xEE`\x845a<YV[`@Q\x90a\x02\xFD`@\x83a7\x93V[`\x02\x82Ra\x12Q`\xF2\x1B` \x83\x01Ra\x03\x15\x91a<\x9EV[\x99`@Q\x90a\x03%`@\x83a7\x93V[`\r\x82RlToken Address`\x98\x1B` \x83\x01Ra\x03H\x91a<\x9EV[\x95`@Q\x90a\x03X`@\x83a7\x93V[`\n\x82RiToken Name`\xB0\x1B` \x83\x01Ra\x03x\x91a<\x9EV[\x98`@Q\x90a\x03\x88`@\x83a7\x93V[`\x0C\x82Rk\x15\x1B\xDA\xD9[\x88\x14\xDE[X\x9B\xDB`\xA2\x1B` \x83\x01Ra\x03\xAA\x91a<\x9EV[\x92`@Q\x90a\x03\xBA`@\x83a7\x93V[`\x0E\x82RmToken Decimals`\x90\x1B` \x83\x01Ra\x03\xDE\x91a<\x9EV[\x90`@Q\x90a\x03\xEE`@\x83a7\x93V[`\t\x82Rh \xB667\xB1\xB0\xBA7\xB9`\xB9\x1B` \x83\x01Ra\x04\r\x91a<\x9EV[\x91`@Q\x90a\x04\x1D`@\x83a7\x93V[`\x05\x82RdScope`\xD8\x1B` \x83\x01Ra\x048\x91a<\x9EV[\x92`@Q\x95a\x04H`@\x88a7\x93V[`\x0C\x87R` \x87\x01\x90k\x14\x99\\\xD9]\x08\x14\x19\\\x9A[\xD9`\xA2\x1B\x82R`@Q\x90a\x04r` \x83a7\x93V[_\x82R`@Q\x97\x88\x93` \x85\x01\x9Ao=\x91:90\xB4\xBA/\xBA<\xB82\x91\x1D\x10\x11`\x81\x1B\x8CRQ\x80\x91`0\x87\x01^\x84\x01\x90l\x11\x16\x10\x11;0\xB6:\xB2\x91\x1D\x10\x11`\x99\x1B`0\x83\x01RQ\x80\x92`=\x83\x01^\x01`0\x01a\"}`\xF0\x1B`\r\x82\x01R\x81Q` \x81\x93\x01`\x0F\x83\x01^\x01`\r\x01`\x02\x81\x01_\x90R\x03`\x02\x01`\x1F\x19\x81\x01\x86Ra\x04\xFA\x90\x86a7\x93V[`@Q\x99\x8A\x97` \x89\x01\x9C\x8Dn\"attributes\": [`\x88\x1B\x90R\x80Q` \x81\x92\x01`/\x8C\x01^\x89\x01`/\x81\x01\x91_\x83R\x80Q\x92` \x84\x92\x01\x90^\x01`/\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01_\x81R\x81Q` \x81\x93\x01\x82^\x01\x90_\x82RQ\x80\x92\x82^\x01a]}`\xF0\x1B\x81R\x03`\x1D\x19\x81\x01\x84R`\x02\x01a\x05\xA7\x90\x84a7\x93V[`@Q\x90a\x05\xB7a'\xC0\x83a7\x93V[a'\x8E\x82R\x7F\"image\": \"data:image/svg+xml;bas` \x80\x84\x01\x91\x82R\x7Fe64,PD94bWwgdmVyc2lvbj0iMS4wIiBl`@\x80\x86\x01\x91\x90\x91R\x7FbmNvZGluZz0iaXNvLTg4NTktMSI/Pg0K``\x86\x01R\x7FPCEtLSBHZW5lcmF0b3I6IEFkb2JlIEls`\x80\x86\x01R\x7FbHVzdHJhdG9yIDIzLjAuNSwgU1ZHIEV4`\xA0\x86\x01R\x7FcG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNp`\xC0\x86\x01R\x7Fb246IDYuMDAgQnVpbGQgMCkgIC0tPg0K`\xE0\x86\x01R\x7FPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5za\x01\0\x86\x01R\x7FPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwa\x01 \x86\x01R\x7FL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6a\x01@\x86\x01R\x7FLy93d3cudzMub3JnLzE5OTkveGxpbmsia\x01`\x86\x01R\x7FIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3a\x01\x80\x86\x01R\x7FQm94PSIwIDAgNDkyIDQ5MiIgc3R5bGU9a\x01\xA0\x86\x01R\x7FImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwa\x01\xC0\x86\x01R\x7FIDAgNDkyIDQ5MjsiIHhtbDpzcGFjZT0ia\x01\xE0\x86\x01R\x7FcHJlc2VydmUiPg0KPGcgaWQ9Ik1hc3Rla\x02\0\x86\x01R\x7Fcl9MYXllcl8yIj4NCjwvZz4NCjxnIGlka\x02 \x86\x01R\x7FPSJMYXllcl8xIj4NCgk8Zz4NCgkJPGc+a\x02@\x86\x01R\x7FDQoJCQk8Zz4NCgkJCQk8Zz4NCgkJCQkJa\x02`\x86\x01R\x7FPHBhdGggc3R5bGU9ImZpbGwtcnVsZTpla\x02\x80\x86\x01R\x7FdmVub2RkO2NsaXAtcnVsZTpldmVub2Rka\x02\xA0\x86\x01R\x7FO2ZpbGw6IzIxMjEyMTsiIGQ9Ik0zMjEua\x02\xC0\x86\x01R\x7FMzA4LDI5NC44NjRjNS4zNTIsNS4zMjgsa\x02\xE0\x86\x01R\x7FOS40NTYsMTIuMTQ0LDE1Ljc5Miw4Ljgza\x03\0\x86\x01R\x7FMg0KCQkJCQkJYzIuNDQ4LTEuMjcyLDUua\x03 \x86\x01R\x7FMDY0LTMuMDk2LDcuMzItNS4yNTZjMy43a\x03@\x86\x01R\x7FNDQtMy41NzYsOC4yNTYtOS41MjgsNC42a\x03`\x86\x01R\x7FNTYtMTQuMjhjLTEyLjQ1Ni0xMS45NzYta\x03\x80\x86\x01R\x7FMzYuMzg0LTMyLjExMi0zNi40NTYtMzIua\x03\xA0\x86\x01R\x7FMTYNCgkJCQkJCWw3LjU2LTguNTY4YzAua\x03\xC0\x86\x01R\x7FMDI0LDAuMDI0LDUuMTYsNC41MzYsMTEua\x03\xE0\x86\x01R\x7FODMyLDEwLjgyNGM4LjY4OCw4LjIwOCwya\x04\0\x86\x01R\x7FMC44NTYsMTYuMiwyNi43MzYsMjQuNDA4a\x04 \x86\x01R\x7FDQoJCQkJCQljMy4zMTIsNC42MDgsMi42a\x04@\x86\x01R\x7FMTYsMTIuNzQ0LDAuODY0LDE3LjUyYy0xa\x04`\x86\x01R\x7FLjM5MiwzLjg0LTQuMTA0LDcuNDY0LTcua\x04\x80\x86\x01R\x7FMzIsMTAuNTM2Yy0zLjAyNCwyLjkwNC02a\x04\xA0\x86\x01R\x7FLjYsNS40LTkuOTYsNy4xMjgNCgkJCQkJa\x04\xC0\x86\x01R\x7FCWMtMy4zODQsMS43NTItNi43OTIsMi43a\x04\xE0\x86\x01R\x7FNi05LjY5NiwyLjc4NGMtMC4wOTYsMC40a\x05\0\x86\x01R\x7FNTYtMC4yMTYsMC45MzYtMC4zMzYsMS4za\x05 \x86\x01R\x7FOTJjLTAuOTYsMy4yNC0zLjAyNCw2LjA3a\x05@\x86\x01R\x7FMi01LjYxNiw4LjQNCgkJCQkJCWMtMi4za\x05`\x86\x01R\x7FMjgsMi4wODgtNS4xMzYsMy44MTYtNy45a\x05\x80\x86\x01R\x7FNDQsNS4wNjRjLTMuMDcyLDEuMzQ0LTYua\x05\xA0\x86\x01R\x7FMjg4LDIuMTEyLTkuMTY4LDIuMTZjLTAua\x05\xC0\x86\x01R\x7FMDk2LDAuOTM2LTAuMjg4LDEuODQ4LTAua\x05\xE0\x86\x01R\x7FNTUyLDIuNzYNCgkJCQkJCWMtMC45Niwza\x06\0\x86\x01R\x7FLjI0LTMuMDI0LDYuMDcyLTUuNjE2LDgua\x06 \x86\x01R\x7FNGMtMi4zMjgsMi4wODgtNS4xMzYsMy44a\x06@\x86\x01R\x7FMTYtNy45NDQsNS4wNjRjLTQuMTI4LDEua\x06`\x86\x01R\x7FODI0LTguNTQ0LDIuNTY4LTEyLDEuOTY4a\x06\x80\x86\x01R\x7FDQoJCQkJCQljLTAuMTIsMS4yMjQtMC4za\x06\xA0\x86\x01R\x7FNiwyLjQtMC42OTYsMy41MDR2MC4wMjRja\x06\xC0\x86\x01R\x7FLTEuMDMyLDMuMzg0LTMsNi4yNC01LjUya\x06\xE0\x86\x01R\x7FLDguMzUyYy0yLjUyLDIuMTEyLTUuNTkya\x07\0\x86\x01R\x7FLDMuNDgtOC44NTYsMy45MzYNCgkJCQkJa\x07 \x86\x01R\x7FCWMtMy45NiwwLjU1Mi04LjE2LTAuMjQta\x07@\x86\x01R\x7FMTEuOTA0LTIuNjg4Yy0xLjAzMi0wLjY3a\x07`\x86\x01R\x7FMi0yLjE2LTEuNTM2LTMuNDgtMi41OTJsa\x07\x80\x86\x01R\x7FLTAuNzQ0LTAuNTc2bC0xMS4xNi04LjYxa\x07\xA0\x86\x01R\x7FNmw2Ljk2LTkuMDI0bDExLjE2LDguNjE2a\x07\xC0\x86\x01R\x7FDQoJCQkJCQlsMC43NDQsMC41NzZjMS4wa\x07\xE0\x86\x01R\x7FMzIsMC43OTIsMS44OTYsMS40ODgsMi43a\x08\0\x86\x01R\x7FODQsMi4wNGMxLjI5NiwwLjg2NCwyLjcza\x08 \x86\x01R\x7FNiwxLjEyOCw0LjA4LDAuOTZjMS4xMjgta\x08@\x86\x01R\x7FMC4xNjgsMi4xODQtMC42NDgsMy4wNzIta\x08`\x86\x01R\x7FMS4zOTINCgkJCQkJCWMwLjg2NC0wLjcya\x08\x80\x86\x01R\x7FLDEuNTYtMS43MjgsMS45Mi0yLjkwNGwwa\x08\xA0\x86\x01R\x7FLDBjMC40NTYtMS41NiwwLjM4NC0zLjUwa\x08\xC0\x86\x01R\x7FNC0wLjQ1Ni01Ljc2Yy05LjUyOC0xMy4ya\x08\xE0\x86\x01R\x7FOTYtMjkuNDQ4LTI5LjQyNC0yOS40OTYta\t\0\x86\x01R\x7FMjkuNDcyDQoJCQkJCQlsNy4yLTguODU2a\t \x86\x01R\x7FYzAuMDQ4LDAuMDI0LDguMTEyLDYuNTc2a\t@\x86\x01R\x7FLDE2Ljc1MiwxNS4wMjRjMi4zMDQsMi4ya\t`\x86\x01R\x7FNTYsNC44NDgsNC43NTIsNy41MTIsNy4xa\t\x80\x86\x01R\x7FMjhjMC40OCwwLjQzMiwwLjk4NCwwLjg2a\t\xA0\x86\x01R\x7FNCwxLjQ2NCwxLjI5Ng0KCQkJCQkJbDAsa\t\xC0\x86\x01R\x7FMGwwLDBjMC4wOTYsMC4wOTYsMC4yMTYsa\t\xE0\x86\x01R\x7FMC4xOTIsMC4zMTIsMC4yODhjMC42MjQsa\n\0\x86\x01R\x7FMC41NTIsMS4yNDgsMS4xMjgsMS44NzIsa\n \x86\x01R\x7FMS43MDRjMi4xMTIsMS44OTYsNC4yLDMua\n@\x86\x01R\x7FODE2LDYuMzg0LDUuNDk2DQoJCQkJCQlja\n`\x86\x01R\x7FMi41OTIsMS44NDgsMi41NDQsMi4yMzIsa\n\x80\x86\x01R\x7FNS40OTYsMS4zNDRjMC42MjQtMC4xOTIsa\n\xA0\x86\x01R\x7FMS4yOTYtMC41MjgsMi4wMTYtMC44NGMxa\n\xC0\x86\x01R\x7FLjc3Ni0wLjc2OCwzLjUwNC0xLjg0OCw0a\n\xE0\x86\x01R\x7FLjg5Ni0zLjA5Ng0KCQkJCQkJYzEuMTI4a\x0B\0\x86\x01R\x7FLTEuMDMyLDEuOTkyLTIuMTEyLDIuMzA0a\x0B \x86\x01R\x7FLTMuMTY4YzAuMjQtMC44NCwwLjA3Mi0xa\x0B@\x86\x01R\x7FLjg0OC0wLjc0NC0yLjk3NmMtOS41NzYta\x0B`\x86\x01R\x7FMTMuMzItMzUuOTA0LTM2LjQ1Ni0zNS45a\x0B\x80\x86\x01R\x7FNzYtMzYuNTI4bDcuNTYtOC41NjgNCgkJa\x0B\xA0\x86\x01R\x7FCQkJCWMwLjA0OCwwLjA0OCwxNC42ODgsa\x0B\xC0\x86\x01R\x7FMTIuOTEyLDI2LjYxNiwyNS40ODhjMy4ya\x0B\xE0\x86\x01R\x7FNCwzLjE5Miw4LjA2NCw3LjU2LDExLjU0a\x0C\0\x86\x01R\x7FNCwxMC4yNzJjMS4yNzIsMC45MTIsMi4xa\x0C \x86\x01R\x7FNiwyLjA4OCw0LjA4LDEuNDE2DQoJCQkJa\x0C@\x86\x01R\x7FCQljMC44MTYtMC4yODgsMS44NDgtMC42a\x0C`\x86\x01R\x7FOTYsMy0xLjJjMS43NzYtMC43NjgsMy41a\x0C\x80\x86\x01R\x7FMDQtMS44NDgsNC44OTYtMy4wOTZjMS4xa\x0C\xA0\x86\x01R\x7FMjgtMS4wMDgsMS45OTItMi4xMTIsMi4za\x0C\xC0\x86\x01R\x7FMDQtMy4xNjgNCgkJCQkJCWMwLjI0LTAua\x0C\xE0\x86\x01R\x7FODQsMC4wNzItMS44NDgtMC43NDQtM2Mta\r\0\x86\x01R\x7FOS41NzYtMTMuMzItMzUuOTA0LTM2LjQ1a\r \x86\x01R\x7FNi0zNS45NzYtMzYuNTI4bDcuNTYtOC41a\r@\x86\x01R\x7FNjgNCgkJCQkJCUMyOTIuMjIsMjY2LjY4a\r`\x86\x01R\x7FOCwzMDkuMDQ0LDI4MS40OTYsMzIxLjMwa\r\x80\x86\x01R\x7FOCwyOTQuODY0eiIvPg0KCQkJCTwvZz4Na\r\xA0\x86\x01R\x7FCgkJCQk8Zz4NCgkJCQkJPHBhdGggc3R5a\r\xC0\x86\x01R\x7FbGU9ImZpbGwtcnVsZTpldmVub2RkO2Nsa\r\xE0\x86\x01R\x7FaXAtcnVsZTpldmVub2RkO2ZpbGw6IzIxa\x0E\0\x86\x01R\x7FMjEyMTsiIGQ9Ik00MjkuMDIsMjU0LjQya\x0E \x86\x01R\x7FNEwzOTMuNjkyLDEyOS43MmwtMS41MzYta\x0E@\x86\x01R\x7FNS40NDhsLTUuNDQ4LDEuNDg4DQoJCQkJa\x0E`\x86\x01R\x7FCQlsLTQ1LjIxNiwxMi40MDhsLTUuNTY4a\x0E\x80\x86\x01R\x7FLDEuNTM2bDEuNTYsNS41MmwyLjEzNiw3a\x0E\xA0\x86\x01R\x7FLjUzNmMtMjEuNjk2LDEuOTY4LTQyLjg0a\x0E\xC0\x86\x01R\x7FLTIuNjY0LTYyLjU2OC02Ljk2DQoJCQkJa\x0E\xE0\x86\x01R\x7FCQljLTM5LjI2NC04LjU2OC03My4yOTYta\x0F\0\x86\x01R\x7FMTUuOTg0LTk5LjU3NiwyNS44OTZsMCwwa\x0F \x86\x01R\x7FYy03LjEwNCwxMS4zNTItMTQuODU2LDI0a\x0F@\x86\x01R\x7FLjg0LTE2LjY1NiwzNS4xNg0KCQkJCQkJa\x0F`\x86\x01R\x7FYy0yLjQ3MiwxNC4wNCwzLjAyNCwyMy4wa\x0F\x80\x86\x01R\x7FNCwyNS4yNDgsMTguOTZjMTMuNjU2LTIua\x0F\xA0\x86\x01R\x7FNDk2LDIyLjA4LTkuMzYsMjkuOTI4LTE1a\x0F\xC0\x86\x01R\x7FLjc2OGM4Ljg4LTcuMjQ4LDE2Ljg3Mi0xa\x0F\xE0\x86\x01R\x7FMy43NTIsMzIuMzc2LTkuMTQ0DQoJCQkJa\x10\0\x86\x01R\x7FCQljOC4xMzYsMy4zNiw4Ljg4LDMuNjcya\x10 \x86\x01R\x7FLDE1LjI0LDkuMDI0YzIxLjE0NCwxNy43a\x10@\x86\x01R\x7FMzYsNzEuNCw2MS41MzYsNzIsNjIuMDRsa\x10`\x86\x01R\x7FMCwwbDEwLjQxNiw5LjE2OGwyLjkwNCwya\x10\x80\x86\x01R\x7FLjU0NGwzLjQzMi0xLjc1Mg0KCQkJCQkJa\x10\xA0\x86\x01R\x7FbDIwLjg4LTEwLjYwOGwxLjI3Miw0LjQ4a\x10\xC0\x86\x01R\x7FOGw1LjQ3Mi0xLjU2bDQ1LjA5Ni0xMi43a\x10\xE0\x86\x01R\x7FNjhsNS40OTYtMS41Nkw0MjkuMDIsMjU0a\x11\0\x86\x01R\x7FLjQyNEw0MjkuMDIsMjU0LjQyNHogTTM1a\x11 \x86\x01R\x7FMC42MzYsMjY5Ljk3NmwtNy41MTItNi42a\x11@\x86\x01R\x7FDQoJCQkJCQlIMzQzLjFjLTAuMTQ0LTAua\x11`\x86\x01R\x7FMTItNTEuNjI0LTQ1LTcyLjE5Mi02Mi4ya\x11\x80\x86\x01R\x7FMzJjLTcuNzA0LTYuNDU2LTguNTY4LTYua\x11\xA0\x86\x01R\x7FODE2LTE4LjM2LTEwLjg3MmwtMC4yNC0wa\x11\xC0\x86\x01R\x7FLjA5NmwtMC41MjgtMC4xOTINCgkJCQkJa\x11\xE0\x86\x01R\x7FCWMtMjEuMzYtNi40NTYtMzEuNjA4LDEua\x12\0\x86\x01R\x7FOTItNDIuOTg0LDExLjIwOGMtNi43Njgsa\x12 \x86\x01R\x7FNS41Mi0xMy45OTIsMTEuNDI0LTI0Ljc2a\x12@\x86\x01R\x7FOCwxMy4zOTJjLTEwLjA4LDEuODQ4LTEya\x12`\x86\x01R\x7FLjc2OC0xLjAzMi0xMS45MjgtNS43ODQNa\x12\x80\x86\x01R\x7FCgkJCQkJCWMxLjQ4OC04LjQ3Miw4LjU0a\x12\xA0\x86\x01R\x7FNC0yMC42NjQsMTUuMDQ4LTMxLjA1NnYta\x12\xC0\x86\x01R\x7FMC4wMjRjMjEuOTYtMzUuMDY0LDUyLjM5a\x12\xE0\x86\x01R\x7FMi0yOC40NCw4Ny40OC0yMC43ODQNCgkJa\x13\0\x86\x01R\x7FCQkJCWMyMS4xOTIsNC42MDgsNDMuOTQ0a\x13 \x86\x01R\x7FLDkuNTc2LDY4LjE2LDYuOTM2bDI3LjI2a\x13@\x86\x01R\x7FNCw5Ni4yNEwzNTAuNjM2LDI2OS45NzZMa\x13`\x86\x01R\x7FMzUwLjYzNiwyNjkuOTc2eiBNMzgyLjM2a\x13\x80\x86\x01R\x7FNCwyNjEuNjk2TDM1MC4wNiwxNDcuNjI1a\x13\xA0\x86\x01R\x7FDQoJCQkJCQlsMzQuMi05LjM4NGwzMi4ya\x13\xC0\x86\x01R\x7FMzIsMTEzLjc4NEwzODIuMzY0LDI2MS42a\x13\xE0\x86\x01R\x7FOTZ6Ii8+DQoJCQkJPC9nPg0KCQkJCTxna\x14\0\x86\x01R\x7FPg0KCQkJCQk8cGF0aCBzdHlsZT0iZmlsa\x14 \x86\x01R\x7FbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxla\x14@\x86\x01R\x7FOmV2ZW5vZGQ7ZmlsbDojMjEyMTIxOyIga\x14`\x86\x01R\x7FZD0iTTE1NS4wMTMsMTQ1LjJsLTIuMjgsa\x14\x80\x86\x01R\x7FOC4wMTYNCgkJCQkJCWMxMC4yMjQsMC4ya\x14\xA0\x86\x01R\x7FMTYsMjkuNTkyLDAuMDQ4LDQ1LjcyLTMua\x14\xC0\x86\x01R\x7FNmwyLjQ5NiwxMS4xMzZjLTE4Ljk2LDQua\x14\xE0\x86\x01R\x7FMjk2LTQxLjgwOCw0LjEwNC01MS40MDgsa\x15\0\x86\x01R\x7FMy43OTJsLTI1LjQ4OCw4OS45NzYNCgkJa\x15 \x86\x01R\x7FCQkJCWM5LjY3MiwzLjA0OCwyNy44ODgsa\x15@\x86\x01R\x7FMTAuOTY4LDI5LjM1MiwyNy43MmwtMTEua\x15`\x86\x01R\x7FNCwwLjk4NGMtMC44ODgtMTAuMTUyLTEza\x15\x80\x86\x01R\x7FLjcyOC0xNS41MDQtMjEuMDcyLTE3Ljc2a\x15\xA0\x86\x01R\x7FbC0xLjM2OCw0LjgyNGwtMS41Niw1LjQ5a\x15\xC0\x86\x01R\x7FNg0KCQkJCQkJbC01LjQ3Mi0xLjU2bC00a\x15\xE0\x86\x01R\x7FNS4wOTYtMTIuNzY4bC01LjQ5Ni0xLjU2a\x16\0\x86\x01R\x7FbDEuNTYtNS40NzJsMzUuMzI4LTEyNC43a\x16 \x86\x01R\x7FMDRsMS41MzYtNS40NDhsNS40NDgsMS40a\x16@\x86\x01R\x7FODhsNDUuMjE2LDEyLjQwOGw1LjU2OCwxa\x16`\x86\x01R\x7FLjUzNg0KCQkJCQkJTDE1NS4wMTMsMTQ1a\x16\x80\x86\x01R\x7FLjJMMTU1LjAxMywxNDUuMkwxNTUuMDEza\x16\xA0\x86\x01R\x7FLDE0NS4yeiBNMTEwLjE1NywyNjEuNjk2a\x16\xC0\x86\x01R\x7FbDMyLjMwNC0xMTQuMDcybC0zNC4yLTkua\x16\xE0\x86\x01R\x7FMzg0TDc2LjAyOSwyNTIuMDI0TDExMC4xa\x17\0\x86\x01R\x7FNTcsMjYxLjY5NnoiLz4NCgkJCQk8L2c+a\x17 \x86\x01R\x7FDQoJCQkJPGc+DQoJCQkJCTxwYXRoIHN0a\x17@\x86\x01R\x7FeWxlPSJmaWxsLXJ1bGU6ZXZlbm9kZDtja\x17`\x86\x01R\x7FbGlwLXJ1bGU6ZXZlbm9kZDtmaWxsOiMya\x17\x80\x86\x01R\x7FMTIxMjE7IiBkPSJNMjQwLjc2NCwzMzYua\x17\xA0\x86\x01R\x7FNjcyTDI0MC43NjQsMzM2LjY3Mg0KCQkJa\x17\xC0\x86\x01R\x7FCQkJYy0xLjEwNC0wLjgxNi0yLjQ0OC0xa\x17\xE0\x86\x01R\x7FLjA4LTMuNzQ0LTAuODg4cy0yLjQ5Niwwa\x18\0\x86\x01R\x7FLjg2NC0zLjMxMiwxLjk0NGwtOC44MzIsa\x18 \x86\x01R\x7FMTEuOTc2aDAuMDI0Yy0wLjgxNiwxLjEwa\x18@\x86\x01R\x7FNC0xLjEwNCwyLjQ3Mi0wLjkxMiwzLjc0a\x18`\x86\x01R\x7FNA0KCQkJCQkJYzAuMTkyLDEuMjcyLDAua\x18\x80\x86\x01R\x7FODY0LDIuNDcyLDEuOTQ0LDMuMjg4bDAua\x18\xA0\x86\x01R\x7FMTY4LDAuMTQ0YzEuMDU2LDAuNzIsMi4za\x18\xC0\x86\x01R\x7FNTIsMC45NiwzLjU3NiwwLjc2OGMxLjI5a\x18\xE0\x86\x01R\x7FNi0wLjE5MiwyLjQ5Ni0wLjg2NCwzLjMxa\x19\0\x86\x01R\x7FMi0xLjk0NA0KCQkJCQkJbDguODU2LTEya\x19 \x86\x01R\x7FYzAuODE2LTEuMTA0LDEuMDgtMi40NDgsa\x19@\x86\x01R\x7FMC44ODgtMy43NDRDMjQyLjUxNiwzMzgua\x19`\x86\x01R\x7FNjg4LDI0MS44NDQsMzM3LjQ4OCwyNDAua\x19\x80\x86\x01R\x7FNzY0LDMzNi42NzJMMjQwLjc2NCwzMzYua\x19\xA0\x86\x01R\x7FNjcyDQoJCQkJCQlMMjQwLjc2NCwzMzYua\x19\xC0\x86\x01R\x7FNjcyeiBNMTc2LjQyMSwyNjYuMjhjNC4ya\x19\xE0\x86\x01R\x7FMjQsMy4xMiw2LjgxNiw3LjY4LDcuNTM2a\x1A\0\x86\x01R\x7FLDEyLjUwNGMwLjMxMiwyLjA2NCwwLjI4a\x1A \x86\x01R\x7FOCw0LjE3Ni0wLjA5Niw2LjI0DQoJCQkJa\x1A@\x86\x01R\x7FCQljMS44OTYtMC45NiwzLjkzNi0xLjYwa\x1A`\x86\x01R\x7FOCw2LjAyNC0xLjkyYzUuMDE2LTAuNzQ0a\x1A\x80\x86\x01R\x7FLDEwLjI5NiwwLjM4NCwxNC42ODgsMy42a\x1A\xA0\x86\x01R\x7FMjR2MC4wMjRjNC40MTYsMy4yNCw3LjA4a\x1A\xC0\x86\x01R\x7FLDcuOTY4LDcuODI0LDEyLjk4NA0KCQkJa\x1A\xE0\x86\x01R\x7FCQkJYzAuMzEyLDEuOTkyLDAuMjg4LDQua\x1B\0\x86\x01R\x7FMDMyLTAuMDI0LDYuMDQ4YzAuNi0wLjE0a\x1B \x86\x01R\x7FNCwxLjE3Ni0wLjI2NCwxLjc3Ni0wLjM2a\x1B@\x86\x01R\x7FYzQuNTM2LTAuNjcyLDkuMzM2LDAuMzYsa\x1B`\x86\x01R\x7FMTMuMjk2LDMuMjg4bDAuMjg4LDAuMjQNa\x1B\x80\x86\x01R\x7FCgkJCQkJCWMzLjgxNiwyLjkyOCw2LjE0a\x1B\xA0\x86\x01R\x7FNCw3LjEyOCw2LjgxNiwxMS41MmMwLjIxa\x1B\xC0\x86\x01R\x7FNiwxLjM2OCwwLjI2NCwyLjc2LDAuMTQ0a\x1B\xE0\x86\x01R\x7FLDQuMTUyYzAuMjE2LTAuMDQ4LDAuNDA4a\x1C\0\x86\x01R\x7FLTAuMDcyLDAuNjI0LTAuMDk2DQoJCQkJa\x1C \x86\x01R\x7FCQljNC4xMjgtMC42MjQsOC41NDQsMC4za\x1C@\x86\x01R\x7FMzYsMTIuMTkyLDMuMDI0bDAsMGMzLjY3a\x1C`\x86\x01R\x7FMiwyLjcxMiw1Ljg4LDYuNjI0LDYuNTA0a\x1C\x80\x86\x01R\x7FLDEwLjc3NmMwLjYyNCw0LjEyOC0wLjMza\x1C\xA0\x86\x01R\x7FNiw4LjU0NC0zLjA0OCwxMi4xOTINCgkJa\x1C\xC0\x86\x01R\x7FCQkJCWwtOC44NTYsMTJjLTIuNzEyLDMua\x1C\xE0\x86\x01R\x7FNjcyLTYuNjI0LDUuODgtMTAuNzc2LDYua\x1D\0\x86\x01R\x7FNTA0Yy00LjEyOCwwLjYyNC04LjUyLTAua\x1D \x86\x01R\x7FMzM2LTEyLjE5Mi0zLjAyNHYwLjAyNA0Ka\x1D@\x86\x01R\x7FCQkJCQkJYy0zLjY0OC0yLjY4OC01Ljg4a\x1D`\x86\x01R\x7FLTYuNjI0LTYuNTA0LTEwLjhjLTAuMDcya\x1D\x80\x86\x01R\x7FLTAuNDgtMC4xMi0wLjk2LTAuMTQ0LTEua\x1D\xA0\x86\x01R\x7FNDRjLTEuMDA4LDAuMzM2LTIuMDQsMC42a\x1D\xC0\x86\x01R\x7FLTMuMDcyLDAuNzQ0DQoJCQkJCQljLTQua\x1D\xE0\x86\x01R\x7FNTEyLDAuNjcyLTkuMzEyLTAuMzYtMTMua\x1E\0\x86\x01R\x7FMjk2LTMuMzEybDAsMGMtMy45ODQtMi45a\x1E \x86\x01R\x7FNTItNi40MDgtNy4yMjQtNy4wOC0xMS43a\x1E@\x86\x01R\x7FMzZjLTAuMTQ0LTAuOTEyLTAuMjE2LTEua\x1E`\x86\x01R\x7FODI0LTAuMTkyLTIuNzYNCgkJCQkJCWMta\x1E\x80\x86\x01R\x7FMS41MTIsMC42MjQtMy4wNzIsMS4wOC00a\x1E\xA0\x86\x01R\x7FLjY4LDEuMzJjLTUuMDE2LDAuNzQ0LTEwa\x1E\xC0\x86\x01R\x7FLjI5Ni0wLjM4NC0xNC42ODgtMy42MjRsa\x1E\xE0\x86\x01R\x7FMCwwYy00LjM5Mi0zLjI0LTcuMDgtNy45a\x1F\0\x86\x01R\x7FOTItNy44MjQtMTMuMDA4DQoJCQkJCQlja\x1F \x86\x01R\x7FLTAuMzg0LTIuNDcyLTAuMjg4LTUuMDE2a\x1F@\x86\x01R\x7FLDAuMzEyLTcuNDg4Yy0xLjU4NCwwLjcya\x1F`\x86\x01R\x7FLTMuMjY0LDEuMi00Ljk2OCwxLjQ2NGMta\x1F\x80\x86\x01R\x7FNC44MjQsMC43Mi05LjkxMi0wLjM4NC0xa\x1F\xA0\x86\x01R\x7FNC4xMzYtMy40OA0KCQkJCQkJYy00LjIya\x1F\xC0\x86\x01R\x7FNC0zLjEyLTYuODE2LTcuNjgtNy41MzYta\x1F\xE0\x86\x01R\x7FMTIuNTA0czAuMzg0LTkuOTEyLDMuNDgta \0\x86\x01R\x7FMTQuMTM2aDAuMDI0bDEwLjk5Mi0xNC45a  \x86\x01R\x7FMDRjMy4xMi00LjI0OCw3LjY4LTYuODE2a @\x86\x01R\x7FLDEyLjQ4LTcuNTM2DQoJCQkJCQlDMTY3a `\x86\x01R\x7FLjA4NSwyNjIuMDU2LDE3Mi4xNzMsMjYza \x80\x86\x01R\x7FLjE2LDE3Ni40MjEsMjY2LjI4TDE3Ni40a \xA0\x86\x01R\x7FMjEsMjY2LjI4TDE3Ni40MjEsMjY2LjI4a \xC0\x86\x01R\x7FTDE3Ni40MjEsMjY2LjI4eiBNMTcyLjY1a \xE0\x86\x01R\x7FMywyODAuNDY0DQoJCQkJCQljLTAuMjg4a!\0\x86\x01R\x7FLTEuOTQ0LTEuMzItMy43NjgtMi45NzYta! \x86\x01R\x7FNC45OTJ2LTAuMDI0Yy0xLjY4LTEuMjI0a!@\x86\x01R\x7FLTMuNzItMS42NTYtNS42ODgtMS4zNjhja!`\x86\x01R\x7FLTEuOTY4LDAuMjg4LTMuNzkyLDEuMzIta!\x80\x86\x01R\x7FNS4wMTYsMi45NzYNCgkJCQkJCWwtMTAua!\xA0\x86\x01R\x7FOTkyLDE0Ljg4aDAuMDI0Yy0xLjI0OCwxa!\xC0\x86\x01R\x7FLjY4LTEuNjgsMy43NDQtMS4zOTIsNS42a!\xE0\x86\x01R\x7FODhjMC4yODgsMS45NDQsMS4zMiwzLjc2a\"\0\x86\x01R\x7FOCwyLjk3Niw0Ljk5Mg0KCQkJCQkJYzEua\" \x86\x01R\x7FNjgsMS4yNDgsMy43NDQsMS42OCw1LjY4a\"@\x86\x01R\x7FOCwxLjM5MnMzLjc2OC0xLjMyLDQuOTkya\"`\x86\x01R\x7FLTIuOTc2bDAuMDI0LDBsMTAuOTkyLTE0a\"\x80\x86\x01R\x7FLjg4aC0wLjAyNA0KCQkJCQkJQzE3Mi40a\"\xA0\x86\x01R\x7FODUsMjg0LjQ3MiwxNzIuOTQxLDI4Mi40a\"\xC0\x86\x01R\x7FMDgsMTcyLjY1MywyODAuNDY0TDE3Mi42a\"\xE0\x86\x01R\x7FNTMsMjgwLjQ2NEwxNzIuNjUzLDI4MC40a#\0\x86\x01R\x7FNjR6IE0yMDEuMDkyLDMwMS40MTYNCgkJa# \x86\x01R\x7FCQkJCWMtMC4zMTItMi4xMzYtMS40NC00a#@\x86\x01R\x7FLjE1Mi0zLjI2NC01LjQ5NnYwLjAyNGMta#`\x86\x01R\x7FMS44NDgtMS4zNjgtNC4xMDQtMS44NDgta#\x80\x86\x01R\x7FNi4yNC0xLjUzNmMtMi4xNiwwLjMzNi00a#\xA0\x86\x01R\x7FLjE1MiwxLjQ0LTUuNTIsMy4yNjQNCgkJa#\xC0\x86\x01R\x7FCQkJCWwtMTEuNjE2LDE1Ljc0NGMtMS4za#\xE0\x86\x01R\x7FNDQsMS44NDgtMS44MjQsNC4xMDQtMS41a$\0\x86\x01R\x7FMTIsNi4yNGMwLjMxMiwyLjEzNiwxLjQ0a$ \x86\x01R\x7FLDQuMTI4LDMuMjY0LDUuNDk2bDAsMA0Ka$@\x86\x01R\x7FCQkJCQkJYzEuODQ4LDEuMzY4LDQuMTA0a$`\x86\x01R\x7FLDEuODQ4LDYuMjQsMS41MzZjMi4xNi0wa$\x80\x86\x01R\x7FLjMxMiw0LjE1Mi0xLjQ0LDUuNTItMy4ya$\xA0\x86\x01R\x7FNjRsMCwwbDExLjYxNi0xNS43NDQNCgkJa$\xC0\x86\x01R\x7FCQkJCUMyMDAuOTQ4LDMwNS44MzIsMjAxa$\xE0\x86\x01R\x7FLjQyOCwzMDMuNTc2LDIwMS4wOTIsMzAxa%\0\x86\x01R\x7FLjQxNkwyMDEuMDkyLDMwMS40MTZMMjAxa% \x86\x01R\x7FLjA5MiwzMDEuNDE2eiBNMjIzLjI0NCwza%@\x86\x01R\x7FMjIuMTUyDQoJCQkJCQljLTAuMjQtMS42a%`\x86\x01R\x7FOC0xLjEwNC0zLjI0LTIuNTItNC4yNzJ2a%\x80\x86\x01R\x7FMC4wMjRjLTEuNDQtMS4wNTYtMy4xOTIta%\xA0\x86\x01R\x7FMS40NC00Ljg0OC0xLjE3NmMtMS42NTYsa%\xC0\x86\x01R\x7FMC4yNC0zLjIxNiwxLjEwNC00LjI0OCwya%\xE0\x86\x01R\x7FLjU0NGwtMC4xOTIsMC4yNA0KCQkJCQkJa&\0\x86\x01R\x7FbC05Ljg4OCwxMy40MTZ2MC4wMjRjLTEua& \x86\x01R\x7FMDU2LDEuNDE2LTEuNDE2LDMuMTY4LTEua&@\x86\x01R\x7FMTUyLDQuODI0YzAuMjY0LDEuNjgsMS4xa&`\x86\x01R\x7FMjgsMy4yNCwyLjU0NCw0LjI3MmwwLDANa&\x80\x86\x01R\x7FCgkJCQkJCWMxLjQxNiwxLjA1NiwzLjE2a&\xA0\x86\x01R\x7FOCwxLjQxNiw0Ljg0OCwxLjE1MmMxLjY4a&\xC0\x86\x01R\x7FLTAuMjY0LDMuMjQtMS4xMjgsNC4yNzIta&\xE0\x86\x01R\x7FMi41NDRMMjIyLjE0MSwzMjcNCgkJCQkJa'\0\x86\x01R\x7FCUMyMjMuMTI0LDMyNS41ODQsMjIzLjUwa' \x86\x01R\x7FOCwzMjMuODMyLDIyMy4yNDQsMzIyLjE1a'@\x86\x01R\x7FMnoiLz4NCgkJCQk8L2c+DQoJCQk8L2c+a'`\x86\x01R\x7FDQoJCTwvZz4NCgk8L2c+DQo8L2c+DQo8a'\x80\x86\x01Rm\x13\x0C\xD3\x8C\x96\x9E\x8D\x13\x90\xD9\xCFOH\x8B`\x92\x1Ba'\xA0\x86\x01RQ\x97Q\x97\x98\x89\x98\x92\x95\x92\x91\x82\x91\x90\x8A\x01^\x87\x01\x90` \x82\x01\x90_\x82RQ\x92\x83\x91^\x01` \x01\x90_\x82RQ\x80\x92\x82^\x01\x90_\x82RQ\x80\x92\x82^\x01_\x81R\x03`\x1F\x19\x81\x01\x82Ra6F\x90\x82a7\x93V[`@Qa6T\x81\x92\x82a7iV[\x03\x90\xF3[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[a6xa\x01\x1C\x91a8\xA1V[\x92a\x01\rV[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[4a6~W` 6`\x03\x19\x01\x12a6~Wa6T` a6\xF8`%a6\xC5`\x045`\x01`\x01`\xA0\x1B\x03\x16a84V[`@Qd\xF0\x9F\xA4\x9D-`\xD8\x1B\x85\x82\x01R\x81Q\x90\x94\x85\x92\x82\x91\x01\x84\x84\x01^\x81\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a7\x93V[`@Q\x91\x82\x91\x82a7iV[4a6~W` 6`\x03\x19\x01\x12a6~Wa6T` a6\xF8`(a73`\x045`\x01`\x01`\xA0\x1B\x03\x16a7\xB5V[`@Q\x93\x84\x91g\x02\x1B{k\x83\x0B\x1B\xA1`\xC5\x1B\x82\x84\x01R\x80Q\x91\x82\x91\x01\x84\x84\x01^\x81\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a7\x93V[` `@\x92\x81\x83R\x80Q\x91\x82\x91\x82\x82\x86\x01R\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a6\x82W`@RV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a8\x10Wa7\xD9\x90c\x06\xFD\xDE\x03`\x04R`\x04_Ra=BV[\x90\x81Q\x15a7\xE3WV[\x90P`@Qa7\xF3`@\x82a7\x93V[`\r\x81Rl:\xB75\xB77\xBB\xB7\x10:7\xB5\xB2\xB7`\x99\x1B` \x82\x01R\x90V[P`@Qa8\x1F`@\x82a7\x93V[`\x05\x81Rd\"\xBA42\xB9`\xD9\x1B` \x82\x01R\x90V[\x80``\x1B\x15a8\x7FWa8R\x90c\x95\xD8\x9BA`\x04R`\x04_Ra=BV[\x90\x81Q\x15a8\\WV[\x90P`@Qa8l`@\x82a7\x93V[`\x03\x81Rb???`\xE8\x1B` \x82\x01R\x90V[P`@Qa8\x8E`@\x82a7\x93V[`\x03\x81Rb\x08\xAA\x89`\xEB\x1B` \x82\x01R\x90V[\x90`@Q\x91`\x80\x83\x01`@Ro0123456789abcdef`\x0FR`\x02\x83\x01\x90`(\x82R_`J\x85\x01R``\x1B`\x01_[\x80\x80\x01\x86\x01`\"\x84\x83\x1A`\x0F\x81\x16Q`#\x84\x01S`\x04\x1CQ\x91\x01S\x01\x90`\x14\x82\x14a9\x05W\x90`\x01\x90a8\xD7V[PPa0x`\x02\x82Q\x01\x91R\x82R\x81`\"\x81\x01\x90\x7F\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x80`(\x83 \x16`\x01_[`\x11`\xF3\x1B\x83\x82\x1A\x02\x81\x80\x01R\x01\x90`\x14\x82\x14a9cW\x90`\x01\x90a9CV[PP`B\x91\x80Q\x7F                                \x81_Q\x16`\x01\x1C\x16\x18\x90R\x01\x80Q\x7F                                \x81` Q\x16`\x01\x1C\x16\x18\x90RV[`\x08\x81\x10\x15a6XW\x80a9\xFFWP`@Qa9\xE5`@\x82a7\x93V[`\n\x81Ri\x13\xDB\x99H\x1C\xD9X\xDB\xDB\x99`\xB2\x1B` \x82\x01R\x90V[`\x01\x81\x03a:5WP`@Qa:\x16`@\x82a7\x93V[`\x0F\x81RnFifteen seconds`\x88\x1B` \x82\x01R\x90V[`\x02\x81\x03a:fWP`@Qa:L`@\x82a7\x93V[`\n\x81RiOne minute`\xB0\x1B` \x82\x01R\x90V[`\x03\x81\x03a:\x98WP`@Qa:}`@\x82a7\x93V[`\x0B\x81RjTen minutes`\xA8\x1B` \x82\x01R\x90V[`\x04\x81\x03a:\xDCWP`@Qa:\xAF`@\x82a7\x93V[`\x19\x81R\x7FOne hour and five minutes\0\0\0\0\0\0\0` \x82\x01R\x90V[`\x05\x81\x03a;\nWP`@Qa:\xF3`@\x82a7\x93V[`\x07\x81RfOne day`\xC8\x1B` \x82\x01R\x90V[`\x06\x81\x03a;NWP`@Qa;!`@\x82a7\x93V[`\x17\x81R\x7FSeven days and one hour\0\0\0\0\0\0\0\0\0` \x82\x01R\x90V[`\x07\x03a;~W`@Qa;c`@\x82a7\x93V[`\x0B\x81RjThirty days`\xA8\x1B` \x82\x01R\x90V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01Rs\x15[\x9A\xDB\x9B\xDD\xDB\x88\x1C\x99\\\xD9]\x08\x1C\x19\\\x9A[\xD9`b\x1B`D\x82\x01R`d\x90\xFD[`\x02\x81\x10\x15a6XW\x80a;\xF1WP`@Qa;\xD7`@\x82a7\x93V[`\n\x81Ri&\xBA\xB6:4\xB1\xB40\xB4\xB7`\xB1\x1B` \x82\x01R\x90V[`\x01\x03a<$W`@Qa<\x06`@\x82a7\x93V[`\x0E\x81RmChain-specific`\x90\x1B` \x82\x01R\x90V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01RlUnknown scope`\x98\x1B`D\x82\x01R`d\x90\xFD[\x90`@Q`\n`\x80\x82\x01\x93`\xA0\x83\x01`@R_\x85R\x93[_\x19\x01\x93`0\x82\x82\x06\x01\x85S\x04\x92\x83\x15a<\x8CW`\n\x90a<pV[\x80\x93P`\x80\x91\x03\x01\x91`\x1F\x19\x01\x91\x82RV[`\x02a=?\x91`\r` \x94`@Qa<\xB7`@\x82a7\x93V[`\x01\x81R`0\x87\x80\x83\x01\x93`\x0B`\xFA\x1B\x85R`@Q\x99\x8A\x97o=\x91:90\xB4\xBA/\xBA<\xB82\x91\x1D\x10\x11`\x81\x1B\x82\x8A\x01R\x80Q\x91\x82\x91\x01\x85\x8A\x01^\x87\x01\x90l\x11\x16\x10\x11;0\xB6:\xB2\x91\x1D\x10\x11`\x99\x1B\x84\x83\x01R\x80Q\x92\x83\x91\x01`=\x83\x01^\x01\x01\x90a\"}`\xF0\x1B\x84\x83\x01RQ\x80\x92`\x0F\x83\x01^\x01\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a7\x93V[\x90V[` _``\x92\x82\x82Q\x91b\x01\x86\xA0\xFA\x15a=?WP`@Q\x80` \x01`@=\x10\x15a=\xA7W[_` =\x80a\x03\xE8\x10a\x03\xE8\x82\x18\x02\x18\x80\x83\x85>\x84\x01\x01S[\x80Q_\x1A\x15a=\x92W`\x01\x01a=\x81V[\x81\x81\x03`\x1F\x19\x01\x82R_\x81R` \x01`@R\x90V[_Q=`\x1F\x19\x01\x81\x11\x15a=\xBCW[Pa=hV[` \x81\x84>\x82Q=\x82\x90\x03`\x1F\x19\x01\x81\x11\x15a=\xD8WPa=\xB6V[\x90`@\x92\x82` \x93a\x03\xE8\x10a\x03\xE8\x82\x18\x02\x18\x92\x83\x92\x83\x87R\x01\x90>\x82\x01_` \x82\x01R\x01`@R\x90V\xFE\xA1dsolcC\0\x08\x1C\0\n",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080806040526004361015610012575f80fd5b5f3560e01c908162ad800c1461312757508062fdd58e146130eb57806301ffc9a7146130a757806303417d721461309057806306659b7f1461307b57806306e8cc181461306657806306fdde031461303c57806308e600ee14613027578063095bcdb614612f4e5780630a133cf214612f395780630d57fec914612f245780630f5eeadf14612f0f578063107d4ee414612ec857806310d8267214612dff57806312a1e6ea14612dea57806312d4888514612d7a57806312f9d21e14612d6557806313589bfe14612d50578063138cd81914612d2a578063144bd5b514612cc85780631486590714612cb3578063176f405a14612c525780631b98b63f14612c3d5780631bb81a8114612c285780631d474b1414612c135780631e2eaeaf14612bf7578063200f0c4d14612b8f578063206620a114612b3f57806325d7776b14612b155780632737edb914612afe57806327c777a914612a815780632a9c4d0d146129515780632acd5dc31461293c5780632c4bbd17146129255780632e3ff2f7146128c15780632e4d55cc146128ac57806331bbae3e1461286e57806332e2a80314612859578063341056c5146128445780633644e5151461282a578063393c33e21461272f5780633f458a19146127185780633f47e662146126fc5780634073c0cc146126d9578063409b3a7e146126c4578063414fd914146126af578063418a23f51461269a578063426a849314612636578063440a0ec3146125ed57806344b97d78146125ba5780634ad5205e146125a35780634c1024161461258c5780634d585fbf146125755780634e41a1fb146125015780634e55a548146124ea578063507cb46f1461249057806353e5006714612350578063548439e114612339578063558a7297146122c4578063577cdc64146122ad5780635920212814612296578063598af9e7146122605780635ac2ccf1146122495780635b15bfd9146121dd5780635b6016ec146121765780635d76a382146121615780635e6c91ff1461214c57806362a420bb1461211557806363f5b1ad146120d8578063648705561461209a578063671b3bd61461202a5780636a9a4c4414611f895780636af2791b14611f745780637003019014611f125780637112406d14611dc857806371f5012714611db1578063721f629214611d765780637423eb3c14611c9157806376d531d414611c7c5780638340f54914611c41578063843719f014611bf15780638678555914611bdc57806388d247c414611bc557806388da84d414611bae57806389ce066114611b59578063935ed2ba14611b1e5780639730f4fd14611b07578063996d3aac14611adc57806399cf8b9b146119e85780639be5f537146119d1578063a23941471461191c578063a4c7bd93146118e2578063aa41c87e14611895578063aa8b845d14611863578063b20abc481461184e578063b24849b714611824578063b3244389146117ee578063b4039fc2146117c1578063b54baefd1461178c578063b602ae021461174a578063b6363cf214611705578063b7ace047146116c0578063b8a5bbad14611682578063bc95bd7a14611637578063c4d195e8146115f0578063c8091041146115b4578063c87b56dd14611432578063ca6cc39f146113e5578063d204f11e1461139a578063d2a1805f14611379578063d34ddc8214611362578063d350188c1461134d578063d3917f3c146112ff578063d921f36a146112b8578063da15ee7f1461112f578063da2f268b146110e6578063db04bc72146110d1578063dbd035ff14611059578063dd589cfc14610fdc578063e0565c4914610f8e578063e05c6e7d14610f41578063e6c5b65414610ee6578063e8672f9314610ed1578063ea14532e14610e6a578063eaa6748314610e33578063eb19600814610df9578063eb35a6d214610d89578063eb43182114610d4d578063ebcbd7b514610cf6578063ecaca40e14610c8d578063eea77a7814610c18578063eed634ad14610c03578063eed9357214610bb8578063f135baaa14610b9c578063f23d923d14610b2e578063f2f0def114610ae9578063f340fa0114610ab8578063f44a345214610a5a578063f745381c14610a24578063f95d3d16146109ea578063fa1c55001461098a578063fb75fb6914610924578063fcfe431a146108c1578063fdc060e7146107d75763fe99049a14610655575f80fd5b60803660031901126107d3576106696131bd565b6106716131ff565b6044359160643561068d60016001605c1b038560a01c16614862565b9260018060a01b0383169260018060a01b038216945f60208160a460405194828052601c8601948591631a808f91885233868901528b60408901528c60608901528d60808901528a60a08901525af15f5163e57f706f60e01b016107b85750505067edcaa89a82293940603452602852336014526034602020541561077f575b84601452604060142080548084116107725783900390556028528360145260406014208054908282019182106107655755335f526020525f516020615f655f395f51905f5260405fa45f603452602060405160018152f35b6389560ca15f526004601cfd5b63f4d678b85f526004601cfd5b845f5260545f20805460018101610798575b505061070d565b8084116107ab5783900390555f80610791565b63deda90305f526004601cfd5b3d1517156107cb5763014c931060a49252fd5b3d5f803e3d5ffd5b5f80fd5b346107d3576107e536613408565b608081015f806107f5838561377f565b905f915b80831061089c5750505061088a576108796035928461087461087f9660e06040515f516020615fa55f395f51905f52815233602082015233604082015260208301976060898184013760c0820152209560608201359661086f61086760016001605c1b038a60a01c16614862565b809335613fcf565b614012565b61377f565b9061527d565b602060405160018152f35b634e487b715f5260116020526024601cfd5b90919260019060206108af8685876138cd565b013580960195861017930191906107f9565b346107d357602061091a601760356108d8366133d4565b6101806108f96108f36108ed83850185613c23565b90614bee565b83615c0a565b9290919361090b610160820135613c58565b926109146137c8565b95614d26565b6040519015158152f35b346107d357602061091a603461093936613249565b61095b61095361094d610100840184613898565b90614e53565b826030615651565b9061010061096b3615848461532d565b916109796001361517613cdd565b926109826137c8565b946021615e45565b346107d357602061091a603461099f3661327d565b6109bb6109b36108ed610100840184613c23565b826031615651565b906109c960e0820135613c58565b6101006109d96002361517613cdd565b926109e26137c8565b946026615e45565b346107d357602061091a60356109ff36613215565b610120610a10604036151783615bc9565b92919390610a1c6137c8565b946024615e45565b346107d357602061091a60176034610a3b3661333c565b610a4481615571565b90610100610a506137c8565b93361592806152df565b346107d357602061091a6035610a6f36613249565b610a8a610a826108ed60e0840184613c23565b82602b615651565b9060e0610a993615848461532d565b91610aa76001361517613cdd565b92610ab06137c8565b94601f615e45565b60203660031901126107d3576020610ad6610ad16131bd565b614320565b610ae134823361437c565b604051908152f35b346107d357602061091a60176035610b00366133a0565b610b19610b1361094d60e0840184613898565b82615834565b9060e0610b246137c8565b93361592806151a7565b346107d357602061091a6035610b4336613215565b3615610100610b73610b6b60408417859060e0910160c08101355f52013560205260405f2090565b846030615651565b92610b8b6002610b8485878561532d565b9417613cdd565b92610b946137c8565b946023615e45565b346107d35760203660031901126107d3576004355c5f5260205ff35b346107d357602061091a6035610bcd36613215565b610be7610be16108ed610140840184613c23565b82615b8a565b9091610140610bfa610120830135613c58565b916109e26137c8565b346107d357602061091a6034610bcd36613215565b346107d357602061091a6035610c2d366133d4565b361590610c5b610c5360808417839060e0910160c08101355f52013560205260405f2090565b826032615651565b91610140610c6a82858561532d565b92610c7e6002610b84610120840135613c58565b93610c876137c8565b95614239565b346107d35760a03660031901126107d3576020610ca86131bd565b610cd9610cc4610cb66131ff565b610cbf846148dc565b6142e2565b91610ccd6139d1565b8260443591339061487c565b610ce1613baa565b610ae1610258361517608435606435336141b4565b346107d357602061091a6034610d0b366134d1565b610180610d326108f360c0361517849060e0910160c08101355f52013560205260405f2090565b92909193610d44610160820135613c58565b92610c876137c8565b346107d357602061091a6034610d623661327d565b610120610d7d610d7761094d83850185613898565b83615baa565b929193906109826137c8565b346107d35760203660031901126107d3576020600435610ae162ffffff77278d00094890015180000f3c00025800003c00000f000001601860078560fc1c16021c1642018281610df38195339190604051926014526341d0e04b5f526034526038601c2091604052565b556148f6565b346107d357602061091a6035610e0e3661333c565b610100610e1a826155cc565b919092610e2a6002361517613cdd565b92610a1c6137c8565b346107d357602061091a6034610e48366133a0565b610e5b610a8261094d60e0840184613898565b9060e061096b3615848461532d565b346107d357602061091a60176034610e813661333c565b610e95610c5361094d610140840184613898565b90610ea23615838361532d565b90610140610eb4610120830135613c58565b91610ec26002361517613cdd565b93610ecb6137c8565b956151a7565b346107d357602061091a60346109ff36613215565b346107d357602061091a6034610efb3661327d565b610f20610f188260e09060c08101355f52013560205260405f2090565b82602f615651565b90361560c0610f3160028317613cdd565b92610f3a6137c8565b9480614239565b346107d357602061091a6035610f563661333c565b610f5f81615250565b90610f6d60e0820135613c58565b610100610f7d6002361517613cdd565b92610f866137c8565b946025615e45565b346107d357602061091a6034610fa336613215565b6101003615610fd1610fcb60408317859060e0910160c08101355f52013560205260405f2090565b84615b66565b929093610f3a6137c8565b346107d357602061091a610fef3661343b565b6040515f516020615fa55f395f51905f528152338482015233604082015261103f8260e0868201936080856060830137209260608201359361086f61086760016001605c1b038760a01c16614862565b608061104d60a084016137b4565b92013591336034615c31565b346107d35760203660031901126107d3576004356001600160401b0381116107d357611089903690600401613370565b6040519160408360208152836020820152019160051b8301916020806040850193925b83355481520191019084838210156110c85750602080916110ac565b60408186030190f35b346107d357602061091a6034610a6f36613249565b346107d35760403660031901126107d35760206004356111046131ff565b906040519183526303f37b1a600c52806040526001603760282054918360405260ff161b1615158152f35b6101603660031901126107d3576111446131bd565b6024356001600160401b0381116107d35761116390369060040161346e565b61116e9291926131d3565b5060a4359060088210156107d357600260c43510156107d35760e43591610104359460038610156107d357610124356001600160401b0381116107d3576111b990369060040161330f565b9661014435906001600160401b0382116107d357869588926111df90369060040161330f565b6111ed8584899e949e614984565b96819f939183839b949b0160051b90602001209561120b8b84614a8c565b83839992993615976001891792611221946143c6565b9f9091604051925f5260205260405260605f206080890152604052601f19916002811460061b90600114600b020190801515010160f301169060071b01610180019060c01761126f94613e72565b611279948a614b38565b60180277278d00094890015180000f3c00025800003c00000f000001901c62ffffff16916112a6936141b4565b6040516112b48192826135c0565b0390f35b346107d357602061091a601760356112cf366132db565b6101806112e46108f361094d83850185613898565b929091936112f6610160820135613c58565b92610ecb6137c8565b346107d357602061091a6035611314366133d4565b61014061134161133b6080361517849060e0910160c08101355f52013560205260405f2090565b83615bd9565b92919390610b946137c8565b346107d357602061091a6034610e0e3661333c565b346107d357602061091a60176034610b00366133a0565b346107d357602061091a603561138e366132db565b610140610a10826155f4565b346107d357602061091a601760346113b13661343b565b6113c4610a8261094d60a0840184613898565b90361560a06113d560018317613cdd565b926113de6137c8565b94806151a7565b346107d357602061091a60356113fa36613215565b61140381615250565b9061141160e0820135613c58565b6101006114216002361517613cdd565b9261142a6137c8565b946022615e45565b346107d35760203660031901126107d357604051600435608082016001600160401b038111838210176115a05760409081525f60208401818152918401818152606085019182526001600160a01b03848116865261149c60a086901c60016001605c1b0316614862565b16835260078460fc1c16600881101561158c5781528360ff1c90600282101561158c5790825260405163d637ca8d60e01b815294516001600160a01b03908116600487015292519092166024850152905161150b91906115009060448601906135a6565b5160648401906135b3565b60848201525f8160a4817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015611581576112b4915f9161155f575b5060405191829182613193565b61157b91503d805f833e61157381836135f9565b810190613635565b82611552565b6040513d5f823e3d90fd5b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b60403660031901126107d3576004356001600160401b0381116107d3576115e261087f91369060040161346e565b6115ea6131ff565b916138dd565b346107d357602061091a601760356116073661327d565b61162161161b6108ed610100840184613c23565b82615b66565b9061010061162d6137c8565b9336159280614d26565b346107d357602061091a6017603561164e366133a0565b611661610f186108ed60c0840184613c23565b90361560c061167260028317613cdd565b9261167b6137c8565b9480614d26565b346107d357602061091a60176034611699366133a0565b6116a281615516565b90361560a06116b082613cdd565b926116b96137c8565b94806152df565b346107d357602061091a601760346116d736613249565b6116f4610f188260e09060c08101355f52013560205260405f2090565b90361560c06116b060028317613cdd565b346107d35760403660031901126107d35761171e6131bd565b6117266131ff565b9067edcaa89a822939406020526014525f5260206034600c20546040519015158152f35b346107d357602061091a603561175f36613249565b361561176d81836028615651565b9061177781613cdd565b916117806137c8565b9360a083179180614239565b346107d357602061091a601760346117a336613249565b6117b6610b136108ed60e0840184613c23565b9060e061162d6137c8565b346107d357602061091a60346117d63661327d565b60e06117e182615524565b919092610e2a3615613cdd565b346107d357602061091a603461180336613215565b61014061181861133b6108ed83850185613c23565b92919390610ab06137c8565b346107d357602061091a60346118393661333c565b610120611818610d776108ed83850185613c23565b346107d357602061091a60356118393661333c565b602061187c610ae1611874366132b1565b939091614320565b9261188834853361437c565b61025836151791336141b4565b346107d357602061091a60346118aa3661333c565b6118be610be161094d610140840184613898565b90916101406118d1610120830135613c58565b916118da6137c8565b946027615e45565b346107d357602061091a60346118f7366132db565b61190081615542565b9091610140611913610120830135613c58565b91610f866137c8565b346107d35761192a36613408565b608081015f8061193a838561377f565b905f915b8083106119ac5750505061088a576108796034928461087461087f9660e06040515f516020615fa55f395f51905f52815233602082015233604082015260208301976060898184013760c0820152209560608201359661086f61086760016001605c1b038a60a01c16614862565b90919260019060206119bf8685876138cd565b0135809601958610179301919061193e565b346107d357602061091a6017603461164e366133a0565b6101203660031901126107d3576119fd6131bd565b506024356001600160401b0381116107d357611a1d90369060040161346e565b611a256131d3565b50600860a43510156107d357600260c43510156107d35760e435916001600160a01b03831683036107d35761010435906001600160401b0382116107d3576112b493611aca611a7b611ad094369060040161330f565b959093611a89848383614984565b9592611ab660c09b9399929b361592611aa460848517613d1e565b611aae8d83614a8c565b949094613db8565b608084015260071b61022001921790613e72565b86614b38565b604051918291826135c0565b346107d357602061091a60176034611af33661327d565b611afc81615774565b9060e0610a506137c8565b346107d357602061091a601760346116073661327d565b346107d357602061091a60176034611b3536613539565b611b48610f1861094d60c0840184613898565b90361560c06113d560028317613cdd565b346107d357602061091a6035611b6e366133d4565b611b92610be16080361517839060e0910160c08101355f52013560205260405f2090565b9091610140611ba5610120830135613c58565b9161142a6137c8565b346107d357602061091a60176035610e813661333c565b346107d357602061091a60176035611b3536613539565b346107d357602061091a603461175f36613249565b346107d357602061091a60176035611c08366132db565b611c118161559c565b9091610140611c24610120830135613c58565b91611c326002361517613cdd565b93611c3b6137c8565b956152df565b346107d3576020611c63611c74611c573661356c565b919390610cbf856148dc565b8093611c6d6139d1565b339061487c565b610ae1613baa565b346107d357602061091a6035610efb3661327d565b346107d3575f3660031901126107d357323303611d67577f00000000000000000000000000000000000000000000000000000000000000008015611d5c575b611d4d575f8080807f0000000000000000000000000000000000000000000000000000000000000000600a5a04fa3d15611d48573d611d0e8161361a565b90611d1c60405192836135f9565b81525f60203d92013e5b15611d39575f805460ff19166001179055005b6370a4078f60e01b5f5260045ffd5b611d26565b630f45b98b60e41b5f5260045ffd5b5060ff5f5416611cd0565b63096650c560e21b5f5260045ffd5b346107d357602061091a60176035611d8d36613539565b611da0610a826108ed60a0840184613c23565b90361560a061167260018317613cdd565b346107d357602061091a60176035611699366133a0565b346107d357611dd63661349e565b60608101611de48183613898565b8060069492941b81810460401482151715611efe57611e0290614bad565b935f915f5b818110611e955750505061088a57611e4d81611e2d856020611e52975191012082615373565b611e476039611e3c8785613898565b6020860135916140ed565b90614012565b613898565b5f5b818110611e6657602060405160018152f35b80611e8f6034611e796001948688614192565b611e86602082018261377f565b9091359161527d565b01611e54565b611ea0818385614192565b5f90611eaf602082018261377f565b905f915b808310611ed957505050906040839260019460061b8b0190356020820152015201611e07565b9091976001906020611eec8b85876138cd565b01358096019586101798019190611eb3565b634e487b7160e01b5f52601160045260245ffd5b346107d35760203660031901126107d357600435611f4981339190604051926014526341d0e04b5f526034526038601c2091604052565b805415611f5f57905f61087f92553615906148f6565b5063e632dbad5f52336020526040526044601cfd5b346107d357602061091a6034610c2d366133d4565b346107d3576080611f9936613408565b611fed611fe460608301611fde84611fc6611fb4848361377f565b6040519060061b809282372082615373565b611e47611fd3858461377f565b60208501359161406f565b8361377f565b939092016137b4565b905f5b83811061200257602060405160018152f35b8061202361201360019387866138cd565b6020810135903586336035615c31565b5001611ff0565b346107d35760c03660031901126107d3576120436131bd565b61204b6131ff565b906044359160088310156107d3576064359160028310156107d357612087611c74926020956120786131e9565b95612082856148dc565b61434b565b80936120916139d1565b6084359261487c565b346107d357602061091a601760356120b136613505565b6101806120bd82615626565b929091936120cf610160820135613c58565b92611c3b6137c8565b346107d357602061091a60346120ed3661333c565b361560e061210060408317846028615651565b92610b8b61210f84868461532d565b93613cdd565b346107d357602061091a6017603561212c36613249565b61214061161b61094d610100840184613898565b90610100610b246137c8565b346107d357602061091a6034611b6e366133d4565b346107d357602061091a60356118aa3661333c565b60603660031901126107d3576004356001600160401b0381116107d3576121a190369060040161346e565b602435906001600160401b0382116107d3576020926121d46121ca61091a94369060040161346e565b92909333916138dd565b60443591614159565b346107d35760203660031901126107d357608060043561224761220b60016001605c1b038360a01c16614862565b604080516001600160a01b038086168252909216602083015290929061223a90840160fc83901c6007166135a6565b606083019060ff1c6135b3565bf35b346107d357602061091a601760346108d8366133d4565b346107d35761226e3661356c565b9167edcaa89a822939406034526028526014525f52602060545f20545f603452604051908152f35b346107d357602061091a60176034611d8d36613539565b346107d357602061091a6017603461212c36613249565b60403660031901126107d3576122d86131bd565b602435908115158092036107d35767edcaa89a82293940602052336014525f52806034600c2055602052600c5160601c337fceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa267602080a3602060405160018152f35b346107d357602061091a601760356113b13661343b565b346107d3576101803660031901126107d35761236a6131bd565b6123726131d3565b9061237b6131e9565b5060c43560088110156107d357600260e43510156107d3576101043590610124359060038210156107d357610144356001600160401b0381116107d3576123c690369060040161330f565b94909261016435956001600160401b0387116107d35787966123ec90369060040161330f565b9890916123f885613d53565b839d93969297919436159b61240e938d936143c6565b9990604051905f52866020528b60405260605f20610100860152604052601f1961016085015161017f0116906101401761244794613e72565b61245093613eca565b60180277278d00094890015180000f3c00025800003c00000f000001901c62ffffff169161247d936141b4565b612485613baa565b604051908152602090f35b60803660031901126107d3576124a46131bd565b60243560088110156107d3576044359060028210156107d357606435916001600160a01b03831683036107d357602093610ae1926124e1926142b1565b9182349161437c565b346107d357602061091a601760356117a336613249565b346107d35760203660031901126107d357604051634e41a1fb60e01b815260048035908201525f816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015611581576112b4915f9161155f575060405191829182613193565b346107d357602061091a601760346120b136613505565b346107d357602061091a60176034611c08366132db565b346107d357602061091a60176035611af33661327d565b346107d357602061091a60346125cf3661333c565b6125d881615774565b9060e06125e36137c8565b9336159280614239565b346107d3576040612627612600366132b1565b91605892601c926040519260148401526368a30dd083526034830152605482015201205490565b81519042811182526020820152f35b61263f366132b1565b909167edcaa89a8229394060345233602852601452815f528060545f20555f5260205160601c337fb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a760205fa45f603452602060405160018152f35b346107d357602061091a6035610d0b366134d1565b346107d357602061091a603461138e366132db565b346107d357602061091a6034610f563661333c565b346107d35760603660031901126107d35761087f604435602435600435336141b4565b346107d35760203660031901126107d357602060405160128152f35b346107d357602061091a60176035610a3b3661333c565b346107d35761273d3661349e565b6060810161274b8183613898565b8060069492941b81810460401482151715611efe5761276990614bad565b935f915f5b8181106127c15750505061088a57611e4d81611e2d856020612794975191012082615373565b5f5b8181106127a857602060405160018152f35b806127bb6035611e796001948688614192565b01612796565b6127cc818385614192565b5f906127db602082018261377f565b905f915b80831061280557505050906040839260019460061b8b019035602082015201520161276e565b90919760019060206128188b85876138cd565b013580960195861017980191906127df565b346107d3575f3660031901126107d3576020610ae16137c8565b346107d357602061091a60356118f7366132db565b346107d357602061091a60346113fa36613215565b346107d35760403660031901126107d3576004356001600160401b0381116107d35761091a6128a3602092369060040161346e565b60243591614159565b346107d357602061091a60356125cf3661333c565b346107d35760603660031901126107d3576004356128dd6131ff565b60408051336014526341d0e04b5f5260348490526038601c209152544281119015176129145761091a906020926044359133613697565b50639287bcb05f526020526024601cfd5b346107d357602061091a601760346112cf366132db565b346107d357602061091a603561099f3661327d565b346107d35760403660031901126107d35761296a6131bd565b6024356001600160401b0381116107d35761298990369060040161330f565b6001600160a01b03909216916055811491338414843b1515179183612a35575b50501715612a25576129ba81613ef9565b806744036fc77deaed23605c1b1791825480612a1157508060209355815f5282527fc54dcaa67a8fd7b4a9aa6fd57351934c792613d5ec1acbd65274270e6de8f7e460405fa16001600160601b0360405191168152f35b8263c18b0e975f526020526040526044601cfd5b634e7f492b5f526020526024601cfd5b809192935015612a6d57808260405137604051206001600160a01b031683146001600160f81b031991358216909114169083806129a9565b634e487b7160e01b5f52603260045260245ffd5b346107d357602061091a612a943661343b565b6040515f516020615fa55f395f51905f5281523384820152336040820152612ae48260e0868201936080856060830137209260608201359361086f61086760016001605c1b038760a01c16614862565b6080612af260a084016137b4565b92013591336035615c31565b346107d357602061091a601760356116d736613249565b346107d357602061091a6035612b2a3661333c565b610140610d7d61133b61094d83850185613898565b346107d357602061091a6035612b5436613249565b612b686109b361094d610100840184613898565b90612b7660e0820135613c58565b610100612b866002361517613cdd565b926118da6137c8565b346107d3576080612b9f36613408565b612bba611fe460608301611fde84611fc6611fb4848361377f565b905f5b838110612bcf57602060405160018152f35b80612bf0612be060019387866138cd565b6020810135903586336034615c31565b5001612bbd565b346107d35760203660031901126107d357600435545f5260205ff35b346107d357602061091a6034611314366133d4565b346107d357602061091a60356120ed3661333c565b346107d357602061091a6035610fa336613215565b346107d357602061091a60176034612c6936613215565b612c7d610c536108ed610140840184613c23565b90612c8a3615838361532d565b90610140612c9c610120830135613c58565b91612caa6002361517613cdd565b936109146137c8565b346107d357602061091a603561180336613215565b346107d35760403660031901126107d357612d06612ce46131bd565b602435909190604051926014526341d0e04b5f526034526038601c2091604052565b546040518115154283116002030291600383101561158c5760409282526020820152f35b346107d357602061091a6035612d3f366132db565b610120611341604036151783615bc9565b346107d357602061091a6035610e48366133a0565b346107d357602061091a6034610b4336613215565b346107d35760203660031901126107d3576004356001600160401b0381116107d357612daa903690600401613370565b90612dbc612db733613ef9565b613fa8565b809160051b01905b818110612dd657602060405160018152f35b602090612de4338235613fcf565b01612dc4565b346107d357602061091a6034612b2a3661333c565b346107d3576101403660031901126107d357612e196131bd565b612e216131d3565b50612e2a6131e9565b50600860c43510156107d357600260e43510156107d35761010435906001600160a01b03821682036107d357610124356001600160401b0381116107d357602092612ead92612e80611c7493369060040161330f565b929091612ec3361594612e9560a48717613d1e565b94612e9f84613d53565b9b839c9a939991929a613db8565b6101008201526101406102008317921790613e72565b613eca565b346107d357602061091a6034612edd3661327d565b612ef16109536108ed610100840184613c23565b90610100612f013615848461532d565b91610aa76002361517613cdd565b346107d357602061091a6035612edd3661327d565b346107d357602061091a6034612d3f366132db565b346107d357602061091a603561093936613249565b612f57366132b1565b612f6f60016001605c1b038360a09594951c16614862565b9160018060a01b038116925f60208160a460405194828052601c8601948591631a808f91885233868901523360408901528a60608901528b60808901528960a08901525af15f5163e57f706f60e01b016107b85750505067edcaa89a8229394060205233601452835f5260405f208054808411610772578390039055601452825f5260405f208054908282019182106107655755335f52602052335f516020615f655f395f51905f5260405fa4602060405160018152f35b346107d357602061091a6035610d623661327d565b346107d3575f3660031901126107d357602080526b0b54686520436f6d70616374604b5260606020f35b346107d357602061091a60356117d63661327d565b346107d357602061091a6034612b5436613249565b346107d357602061091a60176035612c6936613215565b346107d35760203660031901126107d3576004356001600160e01b0319811681036107d35760209060e01c604051906301ffc9a7630f632fb3821491141715158152f35b346107d35760403660031901126107d3576131046131bd565b67edcaa89a822939406020526014526024355f52602060405f2054604051908152f35b346107d35760203660031901126107d357622b600360e21b815260048035908201525f816024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa8015611581576112b4915f9161155f5750604051918291825b602060409281835280519182918282860152018484015e5f828201840152601f01601f1916010190565b600435906001600160a01b03821682036107d357565b608435906001600160a01b03821682036107d357565b60a435906001600160a01b03821682036107d357565b602435906001600160a01b03821682036107d357565b60206003198201126107d357600435906001600160401b0382116107d3576101809082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576101209082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576101409082900360031901126107d35760040190565b60609060031901126107d3576004356001600160a01b03811681036107d357906024359060443590565b60206003198201126107d357600435906001600160401b0382116107d3576101a09082900360031901126107d35760040190565b9181601f840112156107d3578235916001600160401b0383116107d357602083818601950101116107d357565b60206003198201126107d357600435906001600160401b0382116107d3576101609082900360031901126107d35760040190565b9181601f840112156107d3578235916001600160401b0383116107d3576020808501948460051b0101116107d357565b60206003198201126107d357600435906001600160401b0382116107d3576101009082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576101c09082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d35760a09082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d35760c09082900360031901126107d35760040190565b9181601f840112156107d3578235916001600160401b0383116107d3576020808501948460061b0101116107d357565b60206003198201126107d357600435906001600160401b0382116107d35760809082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576102009082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d3576101e09082900360031901126107d35760040190565b60206003198201126107d357600435906001600160401b0382116107d35760e09082900360031901126107d35760040190565b60609060031901126107d3576004356001600160a01b03811681036107d357906024356001600160a01b03811681036107d3579060443590565b90600882101561158c5752565b90600282101561158c5752565b60206040818301928281528451809452019201905f5b8181106135e35750505090565b82518452602093840193909201916001016135d6565b90601f801991011681019081106001600160401b038211176115a057604052565b6001600160401b0381116115a057601f01601f191660200190565b6020818303126107d3578051906001600160401b0382116107d3570181601f820112156107d3578051906136688261361a565b9261367660405194856135f9565b828452602083830101116107d357815f9260208093018386015e8301015290565b909291926136a36139d1565b6001600160a01b0384168061372457505f9081808538935af115613717575b67edcaa89a8229394060205280601452825f5260405f209182549283821161077257815f9403905533835260205260018060a01b03165f516020615f655f395f51905f52604083a4613712613baa565b600190565b63b12d13eb5f526004601cfd5b9091926137313083613b85565b9260145260345263a9059cbb60601b5f5260205f6044601082855af13d1560015f51141716156137725761376a905f6034523090613b85565b9003906136c2565b6390b8ec185f526004601cfd5b903590601e19813603018212156107d357018035906001600160401b0382116107d357602001918160061b360383136107d357565b356001600160a01b03811681036107d35790565b7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000046186138135790565b5060a06040517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208201527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d60408201524660608201523060808201522090565b903590601e19813603018212156107d357018035906001600160401b0382116107d357602001918160051b360383136107d357565b9190811015612a6d5760061b0190565b91906138e76139d1565b82359060018060a01b03821615916020850135341415831634158414178215176139c4578060016001605c1b03849260a01c1661392381613fa8565b936139b2575b505b81811061394157505050505061393f613baa565b565b61394c8183876138cd565b80359060016001605c1b038260a01c166001600160601b0386168103613991575b506001929161398b916020013590876001600160a01b03821661487c565b0161392b565b61398b919550916020836139a760019695613fa8565b96925050919261396d565b6139be9034908661437c565b5f613929565b63ca0fc08e5f526004601cfd5b7f000000000000000000000000000000000000000000000000000000000000000080600414613b595780600314613b475780600914613b105780600a14613ad357600814613a2d57634e487b7160e01b5f52605160045260245ffd5b613a43361568929eee149b4bd212686028615651565b805b613ac357507f000000000000000000000000000000000000000000000000000000000000000080600214613a9c57600114613a8e57634e487b7160e01b5f52605160045260245ffd5b3368929eee149b4bd212685d565b505f5460ff1615613ab5573368929eee149b4bd212685d565b3368929eee149b4bd2126855565b63f57c448b5f526020526024601cfd5b5060e0604036151768929eee149b4bd212680160c08101355f520135602052613b0a60405f2068929eee149b4bd212686031615651565b80613a45565b5068929eee149b4bd21328355f90815268929eee149b4bd213483560205260409020613b0a9068929eee149b4bd21268602f615651565b5068929eee149b4bd212685c80613a45565b505f5460ff1615613b755768929eee149b4bd212685c80613a45565b68929eee149b4bd2126854613b0a565b602460106020939284936014526370a0823160601b5f525afa601f3d11166020510290565b7f000000000000000000000000000000000000000000000000000000000000000080600614613bfc57600514613bee57634e487b7160e01b5f52605160045260245ffd5b5f68929eee149b4bd212685d565b505f5460ff1615613c15575f68929eee149b4bd212685d565b5f68929eee149b4bd2126855565b903590601e19813603018212156107d357018035906001600160401b0382116107d3576020019160608202360383136107d357565b60a090604051907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f82527f5e6f7b4e1ac3d625bac418bc955510b3e054cb6cc23cc27885107f080180b29260208301527f044852b2a670ade5407e78fb2863c51de9fcb96542a07186fe3aeda6bb8a116d604083015260608201523060808201522090565b90604051915f516020615fa55f395f51905f525f525f516020615fc55f395f51905f526020525f516020615f855f395f51905f5260405260051b5191604052565b60a0906080604051917fe055493563385cc588fffacbffe2dab023fef807baa449530431169b0eeb5b69835260208301372090565b90613d5c6139d1565b613d7c613d7460a43560c43560e435612082876148dc565b923090613b85565b906040519063137c29fe82526080600460208401373060a083015260243560c083015260843560e0830152610140610120830152610160820190565b60807f63697069656e7429546f6b656e5065726d697373696f6e73286164647265737391609681527f436f6d706163744465706f736974207769746e65737329436f6d70616374446560208201527f706f736974286164647265737320616c6c6f6361746f722c75696e743820726560408201527f736574506572696f642c75696e74382073636f70652c6164647265737320726560608201527520746f6b656e2c75696e7432353620616d6f756e742960968201520152565b9093805f9493601c92869582613e86614eaf565b9987015260408387018360208201520137016024019101826e22d473030f116ddee9f6b43ac78ba35af11615613eb857565b3d6107cb57637f28c61e5f526004601cfd5b613ed8909291923090613b85565b9283811015613eec5761393f93039161437c565b63426d8dcf5f526004601cfd5b6affffffffffffffffffffff6a7fffffffffffffffffffff8260491c16818360481c16178060021c178060041c178060081c178060101c178060201c176755555555555555558160011c169003673333333333333333808260021c169116018060041c01670f0f0f0f0f0f0f0f660f0f0f0f0f0f0f8260081c169116018060101c01911690690fedcba9876543210000600f60581b91607f600319918060201c0116604803161c60581b161790565b6744036fc77deaed23605c1b81175415613fbf5750565b63cf90c3a85f526020526024601cfd5b604051916020526303f37b1a600c5280604052603760282090600182549160ff161b9080821661400157179055604052565b63dbc205b160601b600c526044601cfd5b916140206040820135614f51565b803590601e19813603018212156107d35701918235926001600160401b0384116107d3576020019280360384136107d35761393f93614069916140616137c8565b918585614f6c565b336150bc565b90929183159161408185826038615aa0565b9161409561408e84614862565b8092613fcf565b946001600160601b0360019316905b8084106140c257505050506140b557565b633a03d3bb5f526004601cfd5b90919293600190836001600160601b036140df8886896038615b0a565b1614151794019291906140a4565b919093928415926140ff868284615aa0565b9261410c61408e85614862565b956001600160601b0360019416915b81851061412d5750505050506140b557565b9091929394600190846001600160601b0361414a8987878b615b0a565b1614151795019392919061411b565b91905f5b81811061416d5750505050600190565b8061418c8461417f60019486896138cd565b60208101359035336141b4565b0161415d565b9190811015612a6d5760051b81013590603e19813603018212156107d3570190565b91929092604051908360148301526368a30dd082526034820194855260548201526058601c8201208242019262278d00811182548510176142295750829055607401526001600160a01b0316907ff78a2f33ff80ef4391f7449c748dc2d577a62cd645108f4f4069f4a7e0635b6a90606090a2565b631f9a96f45f526020526024601cfd5b939195909497969286019586359560208801359760608101359861425d89876152bf565b89811061429c575091614299999a93916142939593604060018060a01b03910135169760016001605c1b038a60a01c1690614c4a565b90615c31565b90565b8990633078b2f65f526020526040526044601cfd5b90916142bc81613ef9565b6744036fc77deaed23605c1b811754909118613fbf5760a01b9160fc1b9060ff1b171790565b6142eb82613ef9565b6744036fc77deaed23605c1b81175490921861430f57600360fc1b9160a01b171790565b5063cf90c3a85f526020526024601cfd5b61432981613ef9565b6744036fc77deaed23605c1b811754909118613fbf5760a01b600360fc1b1790565b9261435581613ef9565b6744036fc77deaed23605c1b811754909118613fbf5760a01b9160fc1b9060ff1b17171790565b909167edcaa89a8229394060205281601452825f5260405f208054908282019182106107655755335f5260205260018060a01b03165f5f516020615f655f395f51905f52604082a4565b939194925f9160208601925f935f9515908161481f575b85156147ce575b505f92801561473a575b5f1981011561469b575b83156145e1575b8415614460575050508184959697823701946e75696e7432353620616d6f756e7429600e8701527f29546f6b656e5065726d697373696f6e73286164647265737320746f6b656e2c5f19870152600e81870301905280850390209303902090565b91985096935083919450600e925060051b936e75696e7432353620616d6f756e7429838201527f29546f6b656e5065726d697373696f6e73286164647265737320746f6b656e2c5f19820152030190526040519261456d575b83156144f9575b5f516020615fa55f395f51905f525f525f516020615fc55f395f51905f526020525f516020615f855f395f51905f526040525191604052565b7f45012d42fad8c9e937cff5a2d750ee18713dd45aadcd718660d5523056618d995f527fc2e16a823b8cdddfdf889991d7a461f0a19faf1f8e608f1c164495a52151cc3e6020527fd2f6ad391328936f118250f231e63c7e639f9756a9ebf972d81763870a772d87604052805193506144c0565b7f2bf981c42c7f423b06fa49ba996d2930887e2f1f53d9a26b8c7423ac1cf83e615f527fd14445d78213a5acddfa89171b0199de521c3b36738b835264cae18f5a53dbf36020527f329b3c527a3c74b8cabc51c304669d1866b87352cafdf440ef2becd6dc261d1e604052805193506144b9565b7f4d756c7469636861696e436f6d7061637420636f6d70616374294d756c74696387527f6861696e436f6d7061637428616464726573732073706f6e736f722c75696e7460208801527f323536206e6f6e63652c75696e7432353620657870697265732c5365676d656e60408801526f5d20696473416e64416d6f756e74732c60708801527f697465722c75696e7432353620636861696e49642c75696e743235365b325d5b6060880152601a87019660900193506143ff565b7f4261746368436f6d7061637420636f6d70616374294261746368436f6d70616387527f74286164647265737320617262697465722c616464726573732073706f6e736f60208801527a75696e743235365b325d5b5d20696473416e64416d6f756e74732c605b8801527f722c75696e74323536206e6f6e63652c75696e7432353620657870697265732c60408801526015870196607b0193506143f8565b7f436f6d7061637420636f6d7061637429436f6d7061637428616464726573732087527f617262697465722c616464726573732073706f6e736f722c75696e743235362060208801526f2c75696e7432353620616d6f756e742c60508801527f6e6f6e63652c75696e7432353620657870697265732c75696e743235362069646040880152601087019660700193506143ee565b7569766174696f6e2875696e743235365b5d206964732c60368a01527f426174636841637469766174696f6e207769746e65737329426174636841637490526056880195506038880194505f6143e4565b686e743235362069642c60298a01527f41637469766174696f6e207769746e6573732941637469766174696f6e28756981526049890196506033890195506143dd565b6744036fc77deaed23605c1b81175491908215613fbf5750565b91906148883084613b85565b9260405194606052306040523360601b602c526323b872dd60601b600c5260205f6064601c82855af13d1560015f51141716156148cf5761393f945f606052604052613eca565b637939f4245f526004601cfd5b8060601b156148e85790565b63961c9a4f6040526024605cfd5b908015155f52602052337fe27f5e0382cf5347965fc81d5c81cd141897fe9ce402d22c496b7c2ddc84e5fd60405fa3565b6001600160401b0381116115a05760051b60200190565b9061494882614927565b61495560405191826135f9565b8281528092614966601f1991614927565b0190602036910137565b8051821015612a6d5760209160051b010190565b919261498e6139d1565b6001600160a01b03833516159260208101353490811415851690158514178315176139c45783926149c660843560a43560c4356142b1565b956149d08261493e565b94614a6d575b50848103956149e48761493e565b925f925f5b898110614a0857505050506149fb5790565b630f2f1e515f526004601cfd5b80614a598a600193979596970194614a29614a2487878a6138cd565b6137b4565b90848060a01b0382166001600160601b0360a01b8a1617988911151797614a5181978d614970565b523090613b85565b614a638289614970565b52019291926149e9565b614a799087349161437c565b835115612a6d578560208501525f6149d6565b91604051918360061b8460071b9160061b6024350163fe8ec1a7855260c06020860152816101400160408601526004356060860152826101600160a0860152606060e0860152604435610100860152606435610120860152856101408601528160248201610160870137818501956101608701525f5b828110614b185750939450508301610180019150565b806040918801306101808201526101a06044838601013591015201614b02565b83515f96909594939290875b878110614b5f575050505050505050613eec5761393f613baa565b80614ba783600193019a614b818c614b7c614a2430928c8b6138cd565b613b85565b90614b9d614b8f858c614970565b519183831015179d89614970565b519103908a61437c565b01614b44565b90614bb78261361a565b614bc460405191826135f9565b8281528092614966601f199161361a565b9015612a6d5790565b9190811015612a6d576060020190565b8160061b82810460401483151715611efe57614c0990614bad565b915f5b818110614c20575050506020815191012090565b80614c2e6001928486614bde565b604060208360061b880192803582850152013591015201614c0c565b60408401356001600160a01b031697969095939486948994919387358801936020890135890192909183359190614c8460808c0135614f51565b614c8d90614862565b6060819b013590614c9d91613fcf565b86811502019181151587841415179081159b614cd49961393f9d614cf0575b505050614cda575b5050508582359260200191614f6c565b846150bc565b614ce8926020018c89614f6c565b5f8080614cc4565b614d1b9350605892601c926040519260148401526368a30dd083526034830152605482015201205490565b4210155f898e614cbc565b98979380959196614d6b939894890198893581019860208a81019a359b013597614d63614d538d8d614bd5565b3560a01c60016001605c1b031690565b9d8e91615e45565b90614d768686614bd5565b95614d9f6020614d93878a35809b6040810135948591013561535c565b83151798868686615c31565b506001600160601b0360019916985b818110614dc7575050505050505061371291925061536d565b614dd2818389614bde565b80359889918860408201359b8c926020013592614dee9361535c565b8c8360a01c60016001605c1b03161415171798614e0d91878787615c31565b50600101614dae565b9015612a6d57803590605e19813603018212156107d3570190565b9190811015612a6d5760051b81013590605e19813603018212156107d3570190565b8160061b82810460401483151715611efe57614e6e90614bad565b915f5b818110614e85575050506020815191012090565b80614e936001928486614e31565b604060208360061b880192803582850152013591015201614e71565b7f0000000000000000000000000000000000000000000000000000000000000000613712576e22d473030f116ddee9f6b43ac78ba33b151590565b60a092916040606092815194848601525f516020615f455f395f51905f5285528560208601933385524684880152608087208752820101358101803560051b80916020018537602001852060808601525f516020615f855f395f51905f5285520190372090565b42811115614f5c5750565b63f80dbaea5f526020526024601cfd5b604080516119015f9081526020979097529181526042601e20918152919390929091606483019083146001600160a01b0386166041851481614fc7575b5050505050505033141715614fba57565b638baa579f5f526004601cfd5b909192939495975060405192885f5261506c575b61502d575b60209495965f60605282604052630b135d3f60e11b83526004830152602482019586946040865281604485015260648401375afa9051630b135d3f60e11b1416905f808080808080614fa9565b60408401355f1a60205260408481376020600160805f825afa5181183d1517614fe0575094505050506001915f6060526040525f808080808080614fa9565b60208581013560ff81901c601b01825286356040526001600160ff1b0316606052600160805f825afa5182183d1517614fdb57505094505050506001915f6060526040525f808080808080614fa9565b5f91825233926001600160a01b03908116929116907f770c32a2314b700d6239ee35ba23a9690f2fceb93a55d8c753e953059b3b18d490602090a4565b6040519260608401525f516020615f455f395f51905f5283526020830191338352466040850152608084209082019060a082013583019060c0823560051b93013560051b5f905f5b85811061517857505050505091604060609260a09594602001852060808601525f516020615f855f395f51905f5285520190372090565b8089016020848301870101358152828214615197575b50602001615141565b602090810185905292508261518e565b949195849197966151d4948101358101988960200199359a6151cc614d538d8d614e16565b988991615e45565b8515956001600160601b035f9416935b8181106151fb57505050505050506137129061536d565b806152498761520d600194868c614e31565b80359b8c8a60016001605c1b036152248c846153b0565b9260a01c16141517179b87602061523e604085018561377f565b9190940135936153c6565b50016151e4565b614299906152756040361517829060e0910160c08101355f52013560205260405f2090565b906031615651565b9291905f5b818110615290575050505050565b806152b86152a160019385896138cd565b8560206152ad836137b4565b920135913389615c31565b5001615282565b8160ff1c15901517156152cf5750565b63a06356f55f526020526024601cfd5b95849061530e9399949692968a01998a3597889660408d013583019a60016001605c1b038960a01c1691615e45565b9561531f60209261429998946152bf565b0135928035906020016153c6565b60a0916040519382019160c0830135019081359384930135855260208501526020016040840137604001902090565b9261536791926153b0565b91101790565b6140b557565b60c09160408051925f516020615fc55f395f51905f5284523360208501523382850152602081013560608501520135608083015260a08201522090565b60ff1c600281101561158c576001149015151690565b91949290925f958415945f5b81811061540157505050505050828210176153ee575050600190565b633078b2f65f526020526040526044601cfd5b8061543460209a988761542d61541a600196888d6138cd565b9d8e0135928c84019c8d10179b9d6137b4565b8789615c31565b50016153d2565b906040519160c08101350191823580937f4d756c7469636861696e436f6d7061637428616464726573732073706f6e736f83527f722c75696e74323536206e6f6e63652c75696e7432353620657870697265732c60208401527f5365676d656e745b5d207365676d656e7473295365676d656e7428616464726560408401527535365b325d5b5d20696473416e64416d6f756e74732c60768401527f737320617262697465722c75696e7432353620636861696e49642c75696e74326060840152602001609683013782604301605382012092609601902090565b614299903615906028615651565b906142996155386040361517846028615651565b928336159161532d565b61556d906155676080361517829060e0910160c08101355f52013560205260405f2090565b90615b8a565b9091565b61556d906155966040361517829060e0910160c08101355f52013560205260405f2090565b90615b66565b906142996155386155c46080361517859060e0910160c08101355f52013560205260405f2090565b846032615651565b90614299615538610b6b6040361517859060e0910160c08101355f52013560205260405f2090565b61561f906156196080361517829060e0910160c08101355f52013560205260405f2090565b90615bd9565b9192909190565b61561f9061564b60c0361517829060e0910160c08101355f52013560205260405f2090565b90615c0a565b91909180603214615764578060311461575757806030146157475780602b146157165780602f1461570957806028146156c857806033146156b057602a146156a757634e487b7160e01b5f52605160045260245ffd5b61429991615373565b5060e0910160c08101355f52013560205260405f2090565b5060c060e092606060408051948301925f516020615fa55f395f51905f52865233602087015201604085013760a081013560a0840152013560c08201522090565b5061429991361590614eea565b509060c091606060408051935f516020615fc55f395f51905f52855233602086015201604084013760a08201522090565b5061429991604036151790614eea565b50614299913615906150f9565b50614299916040361517906150f9565b9061010060405160a060c085013585019460608635967f436f6d70616374286164647265737320617262697465722c6164647265737320855260208501977f73706f6e736f722c75696e74323536206e6f6e63652c75696e7432353620657889528060408701927f70697265732c75696e743235362069642c75696e7432353620616d6f756e742c845260200184880137820185209788865233905260408301903760e0810135828401528381013560c0840152013560e0820152209190565b60e09092919260a06040519160c081013581019560608735977f4261746368436f6d70616374286164647265737320617262697465722c616464865260208601987f726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e74328a52656f756e74732c60468801528060408801927f353620657870697265732c75696e743235365b325d5b5d20696473416e64416d8452602001606689013760660186209889875233905260408401903782840152013560c0820152209190565b92919280602c146159df5760291461591d57634e487b7160e01b5f52605160045260245ffd5b6101009060a0604051918360c082013582019660608835987f436f6d70616374286164647265737320617262697465722c6164647265737320875260208701997f73706f6e736f722c75696e74323536206e6f6e63652c75696e743235362065788b528060408901927f70697265732c75696e743235362069642c75696e7432353620616d6f756e742c8452602001848a013782018720998a8852339052604085019037820160e081013584860152013560c0840152013560e0820152209190565b5060e09060a06040519160c081013581019560608735977f4261746368436f6d70616374286164647265737320617262697465722c616464865260208601987f726573732073706f6e736f722c75696e74323536206e6f6e63652c75696e74328a52656f756e74732c60468801528060408801927f353620657870697265732c75696e743235365b325d5b5d20696473416e64416d8452602001606689013760660186209889875233905260408401903782840152013560c0820152209190565b91909180603814615af45780603914615ad857600714615ace57634e487b7160e01b5f52605160045260245ffd5b614299915f615651565b505f615aec9160016001605c1b0393614192565b3560a01c1690565b5015612a6d573560a01c60016001605c1b031690565b80603814615b525780603914615b3e57600714615b3557634e487b7160e01b5f52605160045260245ffd5b61429992615651565b5091615aec9160016001605c1b0393614192565b5091615aec9160016001605c1b03936138cd565b9190615b8690615b758461543b565b94908591604036151790602d615ce7565b9190565b9190615b8690615b998461543b565b94908591604036151790602e615ce7565b91615bba615b869284602c6158f7565b9290938460403615179161532d565b91615bba615b86928460296158f7565b91615b86604093615c0093615bed8261543b565b959091863615936080851786602d615ce7565b958691179161532d565b91615b86604093615c0093615c1e8261543b565b959091863615936080851786602e615ce7565b939291909380603514615cdd5780603414615c6a57603714615c6157634e487b7160e01b5f52605160045260245ffd5b614299936140ed565b5090929167edcaa89a8229394060205282601452835f5260405f20805480831183151761077257829003905581601452835f5260405f208054908282019182106107655755335f5260205260018060a01b03169060018060a01b03165f516020615f655f395f51905f5260405fa4600190565b5061429993613697565b9594939190929580602d14615dce57602e14615d1157634e487b7160e01b5f52605160045260245ffd5b6040519360608501528584525f516020615f455f395f51905f526020850196338852466040870152141580615dbf575b60051b60800184209083019060a082013584019060c0823560051b93013560051b5f905f5b858110615d9057505050505060609260a09596926040926020018620608087015285520190372090565b8089016020848301870101358152828214615daf575b50602001615d66565b6020908101859052925082615da6565b60a08401356080860152615d41565b5060609260a095969286604093845197878901528588525f516020615f455f395f51905f52602089019633885246878b0152141580615e37575b60051b60800188208852830101358201803560051b809160200186376020018620608087015285520190372090565b8285013560808a0152615e08565b969594939291909680602714615f315780602414615f1c5780602114615f075780602314615ef75780601f14615ee25780602614615ecf5780602214615ec45780602514615eb157601714615ea857634e487b7160e01b5f52605160045260245ffd5b61429996614c4a565b50906017959493929187614299986152df565b508661429997614239565b5090601795949392918761429998614d26565b50916142999691601796959493361593614d26565b5090614299969291361593614239565b509161429996916017969594933615936151a7565b509161429996916017969594933615936152df565b50906017959493929187614299986151a756fe295feb095767cc67d7e74695da0adaddede54d7b7194a8a5426fe8f0351e03371b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288595ca9a66b8bbf0d2316e90dfa3df465f0790b277b25393a3ef4d67e1f50865057cdca950b17b5efc016b74b912d8527dfba5e404a688cbc3dab16cb943287fec25a7fee8000a237929ef9be08f2933c4b4f320b00b38809f3c7aa104d5421049fa164736f6c634300081c000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_5`\xE0\x1C\x90\x81b\xAD\x80\x0C\x14a1'WP\x80b\xFD\xD5\x8E\x14a0\xEBW\x80c\x01\xFF\xC9\xA7\x14a0\xA7W\x80c\x03A}r\x14a0\x90W\x80c\x06e\x9B\x7F\x14a0{W\x80c\x06\xE8\xCC\x18\x14a0fW\x80c\x06\xFD\xDE\x03\x14a0<W\x80c\x08\xE6\0\xEE\x14a0'W\x80c\t[\xCD\xB6\x14a/NW\x80c\n\x13<\xF2\x14a/9W\x80c\rW\xFE\xC9\x14a/$W\x80c\x0F^\xEA\xDF\x14a/\x0FW\x80c\x10}N\xE4\x14a.\xC8W\x80c\x10\xD8&r\x14a-\xFFW\x80c\x12\xA1\xE6\xEA\x14a-\xEAW\x80c\x12\xD4\x88\x85\x14a-zW\x80c\x12\xF9\xD2\x1E\x14a-eW\x80c\x13X\x9B\xFE\x14a-PW\x80c\x13\x8C\xD8\x19\x14a-*W\x80c\x14K\xD5\xB5\x14a,\xC8W\x80c\x14\x86Y\x07\x14a,\xB3W\x80c\x17o@Z\x14a,RW\x80c\x1B\x98\xB6?\x14a,=W\x80c\x1B\xB8\x1A\x81\x14a,(W\x80c\x1DGK\x14\x14a,\x13W\x80c\x1E.\xAE\xAF\x14a+\xF7W\x80c \x0F\x0CM\x14a+\x8FW\x80c f \xA1\x14a+?W\x80c%\xD7wk\x14a+\x15W\x80c'7\xED\xB9\x14a*\xFEW\x80c'\xC7w\xA9\x14a*\x81W\x80c*\x9CM\r\x14a)QW\x80c*\xCD]\xC3\x14a)<W\x80c,K\xBD\x17\x14a)%W\x80c.?\xF2\xF7\x14a(\xC1W\x80c.MU\xCC\x14a(\xACW\x80c1\xBB\xAE>\x14a(nW\x80c2\xE2\xA8\x03\x14a(YW\x80c4\x10V\xC5\x14a(DW\x80c6D\xE5\x15\x14a(*W\x80c9<3\xE2\x14a'/W\x80c?E\x8A\x19\x14a'\x18W\x80c?G\xE6b\x14a&\xFCW\x80c@s\xC0\xCC\x14a&\xD9W\x80c@\x9B:~\x14a&\xC4W\x80cAO\xD9\x14\x14a&\xAFW\x80cA\x8A#\xF5\x14a&\x9AW\x80cBj\x84\x93\x14a&6W\x80cD\n\x0E\xC3\x14a%\xEDW\x80cD\xB9}x\x14a%\xBAW\x80cJ\xD5 ^\x14a%\xA3W\x80cL\x10$\x16\x14a%\x8CW\x80cMX_\xBF\x14a%uW\x80cNA\xA1\xFB\x14a%\x01W\x80cNU\xA5H\x14a$\xEAW\x80cP|\xB4o\x14a$\x90W\x80cS\xE5\0g\x14a#PW\x80cT\x849\xE1\x14a#9W\x80cU\x8Ar\x97\x14a\"\xC4W\x80cW|\xDCd\x14a\"\xADW\x80cY !(\x14a\"\x96W\x80cY\x8A\xF9\xE7\x14a\"`W\x80cZ\xC2\xCC\xF1\x14a\"IW\x80c[\x15\xBF\xD9\x14a!\xDDW\x80c[`\x16\xEC\x14a!vW\x80c]v\xA3\x82\x14a!aW\x80c^l\x91\xFF\x14a!LW\x80cb\xA4 \xBB\x14a!\x15W\x80cc\xF5\xB1\xAD\x14a \xD8W\x80cd\x87\x05V\x14a \x9AW\x80cg\x1B;\xD6\x14a *W\x80cj\x9ALD\x14a\x1F\x89W\x80cj\xF2y\x1B\x14a\x1FtW\x80cp\x03\x01\x90\x14a\x1F\x12W\x80cq\x12@m\x14a\x1D\xC8W\x80cq\xF5\x01'\x14a\x1D\xB1W\x80cr\x1Fb\x92\x14a\x1DvW\x80ct#\xEB<\x14a\x1C\x91W\x80cv\xD51\xD4\x14a\x1C|W\x80c\x83@\xF5I\x14a\x1CAW\x80c\x847\x19\xF0\x14a\x1B\xF1W\x80c\x86xUY\x14a\x1B\xDCW\x80c\x88\xD2G\xC4\x14a\x1B\xC5W\x80c\x88\xDA\x84\xD4\x14a\x1B\xAEW\x80c\x89\xCE\x06a\x14a\x1BYW\x80c\x93^\xD2\xBA\x14a\x1B\x1EW\x80c\x970\xF4\xFD\x14a\x1B\x07W\x80c\x99m:\xAC\x14a\x1A\xDCW\x80c\x99\xCF\x8B\x9B\x14a\x19\xE8W\x80c\x9B\xE5\xF57\x14a\x19\xD1W\x80c\xA29AG\x14a\x19\x1CW\x80c\xA4\xC7\xBD\x93\x14a\x18\xE2W\x80c\xAAA\xC8~\x14a\x18\x95W\x80c\xAA\x8B\x84]\x14a\x18cW\x80c\xB2\n\xBCH\x14a\x18NW\x80c\xB2HI\xB7\x14a\x18$W\x80c\xB3$C\x89\x14a\x17\xEEW\x80c\xB4\x03\x9F\xC2\x14a\x17\xC1W\x80c\xB5K\xAE\xFD\x14a\x17\x8CW\x80c\xB6\x02\xAE\x02\x14a\x17JW\x80c\xB66<\xF2\x14a\x17\x05W\x80c\xB7\xAC\xE0G\x14a\x16\xC0W\x80c\xB8\xA5\xBB\xAD\x14a\x16\x82W\x80c\xBC\x95\xBDz\x14a\x167W\x80c\xC4\xD1\x95\xE8\x14a\x15\xF0W\x80c\xC8\t\x10A\x14a\x15\xB4W\x80c\xC8{V\xDD\x14a\x142W\x80c\xCAl\xC3\x9F\x14a\x13\xE5W\x80c\xD2\x04\xF1\x1E\x14a\x13\x9AW\x80c\xD2\xA1\x80_\x14a\x13yW\x80c\xD3M\xDC\x82\x14a\x13bW\x80c\xD3P\x18\x8C\x14a\x13MW\x80c\xD3\x91\x7F<\x14a\x12\xFFW\x80c\xD9!\xF3j\x14a\x12\xB8W\x80c\xDA\x15\xEE\x7F\x14a\x11/W\x80c\xDA/&\x8B\x14a\x10\xE6W\x80c\xDB\x04\xBCr\x14a\x10\xD1W\x80c\xDB\xD05\xFF\x14a\x10YW\x80c\xDDX\x9C\xFC\x14a\x0F\xDCW\x80c\xE0V\\I\x14a\x0F\x8EW\x80c\xE0\\n}\x14a\x0FAW\x80c\xE6\xC5\xB6T\x14a\x0E\xE6W\x80c\xE8g/\x93\x14a\x0E\xD1W\x80c\xEA\x14S.\x14a\x0EjW\x80c\xEA\xA6t\x83\x14a\x0E3W\x80c\xEB\x19`\x08\x14a\r\xF9W\x80c\xEB5\xA6\xD2\x14a\r\x89W\x80c\xEBC\x18!\x14a\rMW\x80c\xEB\xCB\xD7\xB5\x14a\x0C\xF6W\x80c\xEC\xAC\xA4\x0E\x14a\x0C\x8DW\x80c\xEE\xA7zx\x14a\x0C\x18W\x80c\xEE\xD64\xAD\x14a\x0C\x03W\x80c\xEE\xD95r\x14a\x0B\xB8W\x80c\xF15\xBA\xAA\x14a\x0B\x9CW\x80c\xF2=\x92=\x14a\x0B.W\x80c\xF2\xF0\xDE\xF1\x14a\n\xE9W\x80c\xF3@\xFA\x01\x14a\n\xB8W\x80c\xF4J4R\x14a\nZW\x80c\xF7E8\x1C\x14a\n$W\x80c\xF9]=\x16\x14a\t\xEAW\x80c\xFA\x1CU\0\x14a\t\x8AW\x80c\xFBu\xFBi\x14a\t$W\x80c\xFC\xFEC\x1A\x14a\x08\xC1W\x80c\xFD\xC0`\xE7\x14a\x07\xD7Wc\xFE\x99\x04\x9A\x14a\x06UW_\x80\xFD[`\x806`\x03\x19\x01\x12a\x07\xD3Wa\x06ia1\xBDV[a\x06qa1\xFFV[`D5\x91`d5a\x06\x8D`\x01`\x01`\\\x1B\x03\x85`\xA0\x1C\x16aHbV[\x92`\x01\x80`\xA0\x1B\x03\x83\x16\x92`\x01\x80`\xA0\x1B\x03\x82\x16\x94_` \x81`\xA4`@Q\x94\x82\x80R`\x1C\x86\x01\x94\x85\x91c\x1A\x80\x8F\x91\x88R3\x86\x89\x01R\x8B`@\x89\x01R\x8C``\x89\x01R\x8D`\x80\x89\x01R\x8A`\xA0\x89\x01RZ\xF1_Qc\xE5\x7Fpo`\xE0\x1B\x01a\x07\xB8WPPPg\xED\xCA\xA8\x9A\x82)9@`4R`(R3`\x14R`4`  T\x15a\x07\x7FW[\x84`\x14R`@`\x14 \x80T\x80\x84\x11a\x07rW\x83\x90\x03\x90U`(R\x83`\x14R`@`\x14 \x80T\x90\x82\x82\x01\x91\x82\x10a\x07eWU3_R` R_Q` a_e_9_Q\x90_R`@_\xA4_`4R` `@Q`\x01\x81R\xF3[c\x89V\x0C\xA1_R`\x04`\x1C\xFD[c\xF4\xD6x\xB8_R`\x04`\x1C\xFD[\x84_R`T_ \x80T`\x01\x81\x01a\x07\x98W[PPa\x07\rV[\x80\x84\x11a\x07\xABW\x83\x90\x03\x90U_\x80a\x07\x91V[c\xDE\xDA\x900_R`\x04`\x1C\xFD[=\x15\x17\x15a\x07\xCBWc\x01L\x93\x10`\xA4\x92R\xFD[=_\x80>=_\xFD[_\x80\xFD[4a\x07\xD3Wa\x07\xE56a4\x08V[`\x80\x81\x01_\x80a\x07\xF5\x83\x85a7\x7FV[\x90_\x91[\x80\x83\x10a\x08\x9CWPPPa\x08\x8AWa\x08y`5\x92\x84a\x08ta\x08\x7F\x96`\xE0`@Q_Q` a_\xA5_9_Q\x90_R\x81R3` \x82\x01R3`@\x82\x01R` \x83\x01\x97``\x89\x81\x84\x017`\xC0\x82\x01R \x95``\x82\x015\x96a\x08oa\x08g`\x01`\x01`\\\x1B\x03\x8A`\xA0\x1C\x16aHbV[\x80\x935a?\xCFV[a@\x12V[a7\x7FV[\x90aR}V[` `@Q`\x01\x81R\xF3[cNH{q_R`\x11` R`$`\x1C\xFD[\x90\x91\x92`\x01\x90` a\x08\xAF\x86\x85\x87a8\xCDV[\x015\x80\x96\x01\x95\x86\x10\x17\x93\x01\x91\x90a\x07\xF9V[4a\x07\xD3W` a\t\x1A`\x17`5a\x08\xD86a3\xD4V[a\x01\x80a\x08\xF9a\x08\xF3a\x08\xED\x83\x85\x01\x85a<#V[\x90aK\xEEV[\x83a\\\nV[\x92\x90\x91\x93a\t\x0Ba\x01`\x82\x015a<XV[\x92a\t\x14a7\xC8V[\x95aM&V[`@Q\x90\x15\x15\x81R\xF3[4a\x07\xD3W` a\t\x1A`4a\t96a2IV[a\t[a\tSa\tMa\x01\0\x84\x01\x84a8\x98V[\x90aNSV[\x82`0aVQV[\x90a\x01\0a\tk6\x15\x84\x84aS-V[\x91a\ty`\x016\x15\x17a<\xDDV[\x92a\t\x82a7\xC8V[\x94`!a^EV[4a\x07\xD3W` a\t\x1A`4a\t\x9F6a2}V[a\t\xBBa\t\xB3a\x08\xEDa\x01\0\x84\x01\x84a<#V[\x82`1aVQV[\x90a\t\xC9`\xE0\x82\x015a<XV[a\x01\0a\t\xD9`\x026\x15\x17a<\xDDV[\x92a\t\xE2a7\xC8V[\x94`&a^EV[4a\x07\xD3W` a\t\x1A`5a\t\xFF6a2\x15V[a\x01 a\n\x10`@6\x15\x17\x83a[\xC9V[\x92\x91\x93\x90a\n\x1Ca7\xC8V[\x94`$a^EV[4a\x07\xD3W` a\t\x1A`\x17`4a\n;6a3<V[a\nD\x81aUqV[\x90a\x01\0a\nPa7\xC8V[\x936\x15\x92\x80aR\xDFV[4a\x07\xD3W` a\t\x1A`5a\no6a2IV[a\n\x8Aa\n\x82a\x08\xED`\xE0\x84\x01\x84a<#V[\x82`+aVQV[\x90`\xE0a\n\x996\x15\x84\x84aS-V[\x91a\n\xA7`\x016\x15\x17a<\xDDV[\x92a\n\xB0a7\xC8V[\x94`\x1Fa^EV[` 6`\x03\x19\x01\x12a\x07\xD3W` a\n\xD6a\n\xD1a1\xBDV[aC V[a\n\xE14\x823aC|V[`@Q\x90\x81R\xF3[4a\x07\xD3W` a\t\x1A`\x17`5a\x0B\x006a3\xA0V[a\x0B\x19a\x0B\x13a\tM`\xE0\x84\x01\x84a8\x98V[\x82aX4V[\x90`\xE0a\x0B$a7\xC8V[\x936\x15\x92\x80aQ\xA7V[4a\x07\xD3W` a\t\x1A`5a\x0BC6a2\x15V[6\x15a\x01\0a\x0Bsa\x0Bk`@\x84\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84`0aVQV[\x92a\x0B\x8B`\x02a\x0B\x84\x85\x87\x85aS-V[\x94\x17a<\xDDV[\x92a\x0B\x94a7\xC8V[\x94`#a^EV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045\\_R` _\xF3[4a\x07\xD3W` a\t\x1A`5a\x0B\xCD6a2\x15V[a\x0B\xE7a\x0B\xE1a\x08\xEDa\x01@\x84\x01\x84a<#V[\x82a[\x8AV[\x90\x91a\x01@a\x0B\xFAa\x01 \x83\x015a<XV[\x91a\t\xE2a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x0B\xCD6a2\x15V[4a\x07\xD3W` a\t\x1A`5a\x0C-6a3\xD4V[6\x15\x90a\x0C[a\x0CS`\x80\x84\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x82`2aVQV[\x91a\x01@a\x0Cj\x82\x85\x85aS-V[\x92a\x0C~`\x02a\x0B\x84a\x01 \x84\x015a<XV[\x93a\x0C\x87a7\xC8V[\x95aB9V[4a\x07\xD3W`\xA06`\x03\x19\x01\x12a\x07\xD3W` a\x0C\xA8a1\xBDV[a\x0C\xD9a\x0C\xC4a\x0C\xB6a1\xFFV[a\x0C\xBF\x84aH\xDCV[aB\xE2V[\x91a\x0C\xCDa9\xD1V[\x82`D5\x913\x90aH|V[a\x0C\xE1a;\xAAV[a\n\xE1a\x02X6\x15\x17`\x845`d53aA\xB4V[4a\x07\xD3W` a\t\x1A`4a\r\x0B6a4\xD1V[a\x01\x80a\r2a\x08\xF3`\xC06\x15\x17\x84\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x92\x90\x91\x93a\rDa\x01`\x82\x015a<XV[\x92a\x0C\x87a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\rb6a2}V[a\x01 a\r}a\rwa\tM\x83\x85\x01\x85a8\x98V[\x83a[\xAAV[\x92\x91\x93\x90a\t\x82a7\xC8V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W` `\x045a\n\xE1b\xFF\xFF\xFFw'\x8D\0\tH\x90\x01Q\x80\0\x0F<\0\x02X\0\0<\0\0\x0F\0\0\x01`\x18`\x07\x85`\xFC\x1C\x16\x02\x1C\x16B\x01\x82\x81a\r\xF3\x81\x953\x91\x90`@Q\x92`\x14RcA\xD0\xE0K_R`4R`8`\x1C \x91`@RV[UaH\xF6V[4a\x07\xD3W` a\t\x1A`5a\x0E\x0E6a3<V[a\x01\0a\x0E\x1A\x82aU\xCCV[\x91\x90\x92a\x0E*`\x026\x15\x17a<\xDDV[\x92a\n\x1Ca7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x0EH6a3\xA0V[a\x0E[a\n\x82a\tM`\xE0\x84\x01\x84a8\x98V[\x90`\xE0a\tk6\x15\x84\x84aS-V[4a\x07\xD3W` a\t\x1A`\x17`4a\x0E\x816a3<V[a\x0E\x95a\x0CSa\tMa\x01@\x84\x01\x84a8\x98V[\x90a\x0E\xA26\x15\x83\x83aS-V[\x90a\x01@a\x0E\xB4a\x01 \x83\x015a<XV[\x91a\x0E\xC2`\x026\x15\x17a<\xDDV[\x93a\x0E\xCBa7\xC8V[\x95aQ\xA7V[4a\x07\xD3W` a\t\x1A`4a\t\xFF6a2\x15V[4a\x07\xD3W` a\t\x1A`4a\x0E\xFB6a2}V[a\x0F a\x0F\x18\x82`\xE0\x90`\xC0\x81\x015_R\x015` R`@_ \x90V[\x82`/aVQV[\x906\x15`\xC0a\x0F1`\x02\x83\x17a<\xDDV[\x92a\x0F:a7\xC8V[\x94\x80aB9V[4a\x07\xD3W` a\t\x1A`5a\x0FV6a3<V[a\x0F_\x81aRPV[\x90a\x0Fm`\xE0\x82\x015a<XV[a\x01\0a\x0F}`\x026\x15\x17a<\xDDV[\x92a\x0F\x86a7\xC8V[\x94`%a^EV[4a\x07\xD3W` a\t\x1A`4a\x0F\xA36a2\x15V[a\x01\x006\x15a\x0F\xD1a\x0F\xCB`@\x83\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84a[fV[\x92\x90\x93a\x0F:a7\xC8V[4a\x07\xD3W` a\t\x1Aa\x0F\xEF6a4;V[`@Q_Q` a_\xA5_9_Q\x90_R\x81R3\x84\x82\x01R3`@\x82\x01Ra\x10?\x82`\xE0\x86\x82\x01\x93`\x80\x85``\x83\x017 \x92``\x82\x015\x93a\x08oa\x08g`\x01`\x01`\\\x1B\x03\x87`\xA0\x1C\x16aHbV[`\x80a\x10M`\xA0\x84\x01a7\xB4V[\x92\x015\x913`4a\\1V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x10\x89\x906\x90`\x04\x01a3pV[`@Q\x91`@\x83` \x81R\x83` \x82\x01R\x01\x91`\x05\x1B\x83\x01\x91` \x80`@\x85\x01\x93\x92[\x835T\x81R\x01\x91\x01\x90\x84\x83\x82\x10\x15a\x10\xC8WP` \x80\x91a\x10\xACV[`@\x81\x86\x03\x01\x90\xF3[4a\x07\xD3W` a\t\x1A`4a\no6a2IV[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3W` `\x045a\x11\x04a1\xFFV[\x90`@Q\x91\x83Rc\x03\xF3{\x1A`\x0CR\x80`@R`\x01`7`( T\x91\x83`@R`\xFF\x16\x1B\x16\x15\x15\x81R\xF3[a\x01`6`\x03\x19\x01\x12a\x07\xD3Wa\x11Da1\xBDV[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x11c\x906\x90`\x04\x01a4nV[a\x11n\x92\x91\x92a1\xD3V[P`\xA45\x90`\x08\x82\x10\x15a\x07\xD3W`\x02`\xC45\x10\x15a\x07\xD3W`\xE45\x91a\x01\x045\x94`\x03\x86\x10\x15a\x07\xD3Wa\x01$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x11\xB9\x906\x90`\x04\x01a3\x0FV[\x96a\x01D5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W\x86\x95\x88\x92a\x11\xDF\x906\x90`\x04\x01a3\x0FV[a\x11\xED\x85\x84\x89\x9E\x94\x9EaI\x84V[\x96\x81\x9F\x93\x91\x83\x83\x9B\x94\x9B\x01`\x05\x1B\x90` \x01 \x95a\x12\x0B\x8B\x84aJ\x8CV[\x83\x83\x99\x92\x996\x15\x97`\x01\x89\x17\x92a\x12!\x94aC\xC6V[\x9F\x90\x91`@Q\x92_R` R`@R``_ `\x80\x89\x01R`@R`\x1F\x19\x91`\x02\x81\x14`\x06\x1B\x90`\x01\x14`\x0B\x02\x01\x90\x80\x15\x15\x01\x01`\xF3\x01\x16\x90`\x07\x1B\x01a\x01\x80\x01\x90`\xC0\x17a\x12o\x94a>rV[a\x12y\x94\x8AaK8V[`\x18\x02w'\x8D\0\tH\x90\x01Q\x80\0\x0F<\0\x02X\0\0<\0\0\x0F\0\0\x01\x90\x1Cb\xFF\xFF\xFF\x16\x91a\x12\xA6\x93aA\xB4V[`@Qa\x12\xB4\x81\x92\x82a5\xC0V[\x03\x90\xF3[4a\x07\xD3W` a\t\x1A`\x17`5a\x12\xCF6a2\xDBV[a\x01\x80a\x12\xE4a\x08\xF3a\tM\x83\x85\x01\x85a8\x98V[\x92\x90\x91\x93a\x12\xF6a\x01`\x82\x015a<XV[\x92a\x0E\xCBa7\xC8V[4a\x07\xD3W` a\t\x1A`5a\x13\x146a3\xD4V[a\x01@a\x13Aa\x13;`\x806\x15\x17\x84\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x83a[\xD9V[\x92\x91\x93\x90a\x0B\x94a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x0E\x0E6a3<V[4a\x07\xD3W` a\t\x1A`\x17`4a\x0B\x006a3\xA0V[4a\x07\xD3W` a\t\x1A`5a\x13\x8E6a2\xDBV[a\x01@a\n\x10\x82aU\xF4V[4a\x07\xD3W` a\t\x1A`\x17`4a\x13\xB16a4;V[a\x13\xC4a\n\x82a\tM`\xA0\x84\x01\x84a8\x98V[\x906\x15`\xA0a\x13\xD5`\x01\x83\x17a<\xDDV[\x92a\x13\xDEa7\xC8V[\x94\x80aQ\xA7V[4a\x07\xD3W` a\t\x1A`5a\x13\xFA6a2\x15V[a\x14\x03\x81aRPV[\x90a\x14\x11`\xE0\x82\x015a<XV[a\x01\0a\x14!`\x026\x15\x17a<\xDDV[\x92a\x14*a7\xC8V[\x94`\"a^EV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`@Q`\x045`\x80\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x15\xA0W`@\x90\x81R_` \x84\x01\x81\x81R\x91\x84\x01\x81\x81R``\x85\x01\x91\x82R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x86Ra\x14\x9C`\xA0\x86\x90\x1C`\x01`\x01`\\\x1B\x03\x16aHbV[\x16\x83R`\x07\x84`\xFC\x1C\x16`\x08\x81\x10\x15a\x15\x8CW\x81R\x83`\xFF\x1C\x90`\x02\x82\x10\x15a\x15\x8CW\x90\x82R`@Qc\xD67\xCA\x8D`\xE0\x1B\x81R\x94Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16`\x04\x87\x01R\x92Q\x90\x92\x16`$\x85\x01R\x90Qa\x15\x0B\x91\x90a\x15\0\x90`D\x86\x01\x90a5\xA6V[Q`d\x84\x01\x90a5\xB3V[`\x84\x82\x01R_\x81`\xA4\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x15\x81Wa\x12\xB4\x91_\x91a\x15_W[P`@Q\x91\x82\x91\x82a1\x93V[a\x15{\x91P=\x80_\x83>a\x15s\x81\x83a5\xF9V[\x81\x01\x90a65V[\x82a\x15RV[`@Q=_\x82>=\x90\xFD[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x15\xE2a\x08\x7F\x916\x90`\x04\x01a4nV[a\x15\xEAa1\xFFV[\x91a8\xDDV[4a\x07\xD3W` a\t\x1A`\x17`5a\x16\x076a2}V[a\x16!a\x16\x1Ba\x08\xEDa\x01\0\x84\x01\x84a<#V[\x82a[fV[\x90a\x01\0a\x16-a7\xC8V[\x936\x15\x92\x80aM&V[4a\x07\xD3W` a\t\x1A`\x17`5a\x16N6a3\xA0V[a\x16aa\x0F\x18a\x08\xED`\xC0\x84\x01\x84a<#V[\x906\x15`\xC0a\x16r`\x02\x83\x17a<\xDDV[\x92a\x16{a7\xC8V[\x94\x80aM&V[4a\x07\xD3W` a\t\x1A`\x17`4a\x16\x996a3\xA0V[a\x16\xA2\x81aU\x16V[\x906\x15`\xA0a\x16\xB0\x82a<\xDDV[\x92a\x16\xB9a7\xC8V[\x94\x80aR\xDFV[4a\x07\xD3W` a\t\x1A`\x17`4a\x16\xD76a2IV[a\x16\xF4a\x0F\x18\x82`\xE0\x90`\xC0\x81\x015_R\x015` R`@_ \x90V[\x906\x15`\xC0a\x16\xB0`\x02\x83\x17a<\xDDV[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3Wa\x17\x1Ea1\xBDV[a\x17&a1\xFFV[\x90g\xED\xCA\xA8\x9A\x82)9@` R`\x14R_R` `4`\x0C T`@Q\x90\x15\x15\x81R\xF3[4a\x07\xD3W` a\t\x1A`5a\x17_6a2IV[6\x15a\x17m\x81\x83`(aVQV[\x90a\x17w\x81a<\xDDV[\x91a\x17\x80a7\xC8V[\x93`\xA0\x83\x17\x91\x80aB9V[4a\x07\xD3W` a\t\x1A`\x17`4a\x17\xA36a2IV[a\x17\xB6a\x0B\x13a\x08\xED`\xE0\x84\x01\x84a<#V[\x90`\xE0a\x16-a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x17\xD66a2}V[`\xE0a\x17\xE1\x82aU$V[\x91\x90\x92a\x0E*6\x15a<\xDDV[4a\x07\xD3W` a\t\x1A`4a\x18\x036a2\x15V[a\x01@a\x18\x18a\x13;a\x08\xED\x83\x85\x01\x85a<#V[\x92\x91\x93\x90a\n\xB0a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x1896a3<V[a\x01 a\x18\x18a\rwa\x08\xED\x83\x85\x01\x85a<#V[4a\x07\xD3W` a\t\x1A`5a\x1896a3<V[` a\x18|a\n\xE1a\x18t6a2\xB1V[\x93\x90\x91aC V[\x92a\x18\x884\x853aC|V[a\x02X6\x15\x17\x913aA\xB4V[4a\x07\xD3W` a\t\x1A`4a\x18\xAA6a3<V[a\x18\xBEa\x0B\xE1a\tMa\x01@\x84\x01\x84a8\x98V[\x90\x91a\x01@a\x18\xD1a\x01 \x83\x015a<XV[\x91a\x18\xDAa7\xC8V[\x94`'a^EV[4a\x07\xD3W` a\t\x1A`4a\x18\xF76a2\xDBV[a\x19\0\x81aUBV[\x90\x91a\x01@a\x19\x13a\x01 \x83\x015a<XV[\x91a\x0F\x86a7\xC8V[4a\x07\xD3Wa\x19*6a4\x08V[`\x80\x81\x01_\x80a\x19:\x83\x85a7\x7FV[\x90_\x91[\x80\x83\x10a\x19\xACWPPPa\x08\x8AWa\x08y`4\x92\x84a\x08ta\x08\x7F\x96`\xE0`@Q_Q` a_\xA5_9_Q\x90_R\x81R3` \x82\x01R3`@\x82\x01R` \x83\x01\x97``\x89\x81\x84\x017`\xC0\x82\x01R \x95``\x82\x015\x96a\x08oa\x08g`\x01`\x01`\\\x1B\x03\x8A`\xA0\x1C\x16aHbV[\x90\x91\x92`\x01\x90` a\x19\xBF\x86\x85\x87a8\xCDV[\x015\x80\x96\x01\x95\x86\x10\x17\x93\x01\x91\x90a\x19>V[4a\x07\xD3W` a\t\x1A`\x17`4a\x16N6a3\xA0V[a\x01 6`\x03\x19\x01\x12a\x07\xD3Wa\x19\xFDa1\xBDV[P`$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\x1A\x1D\x906\x90`\x04\x01a4nV[a\x1A%a1\xD3V[P`\x08`\xA45\x10\x15a\x07\xD3W`\x02`\xC45\x10\x15a\x07\xD3W`\xE45\x91`\x01`\x01`\xA0\x1B\x03\x83\x16\x83\x03a\x07\xD3Wa\x01\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x12\xB4\x93a\x1A\xCAa\x1A{a\x1A\xD0\x946\x90`\x04\x01a3\x0FV[\x95\x90\x93a\x1A\x89\x84\x83\x83aI\x84V[\x95\x92a\x1A\xB6`\xC0\x9B\x93\x99\x92\x9B6\x15\x92a\x1A\xA4`\x84\x85\x17a=\x1EV[a\x1A\xAE\x8D\x83aJ\x8CV[\x94\x90\x94a=\xB8V[`\x80\x84\x01R`\x07\x1Ba\x02 \x01\x92\x17\x90a>rV[\x86aK8V[`@Q\x91\x82\x91\x82a5\xC0V[4a\x07\xD3W` a\t\x1A`\x17`4a\x1A\xF36a2}V[a\x1A\xFC\x81aWtV[\x90`\xE0a\nPa7\xC8V[4a\x07\xD3W` a\t\x1A`\x17`4a\x16\x076a2}V[4a\x07\xD3W` a\t\x1A`\x17`4a\x1B56a59V[a\x1BHa\x0F\x18a\tM`\xC0\x84\x01\x84a8\x98V[\x906\x15`\xC0a\x13\xD5`\x02\x83\x17a<\xDDV[4a\x07\xD3W` a\t\x1A`5a\x1Bn6a3\xD4V[a\x1B\x92a\x0B\xE1`\x806\x15\x17\x83\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90\x91a\x01@a\x1B\xA5a\x01 \x83\x015a<XV[\x91a\x14*a7\xC8V[4a\x07\xD3W` a\t\x1A`\x17`5a\x0E\x816a3<V[4a\x07\xD3W` a\t\x1A`\x17`5a\x1B56a59V[4a\x07\xD3W` a\t\x1A`4a\x17_6a2IV[4a\x07\xD3W` a\t\x1A`\x17`5a\x1C\x086a2\xDBV[a\x1C\x11\x81aU\x9CV[\x90\x91a\x01@a\x1C$a\x01 \x83\x015a<XV[\x91a\x1C2`\x026\x15\x17a<\xDDV[\x93a\x1C;a7\xC8V[\x95aR\xDFV[4a\x07\xD3W` a\x1Cca\x1Cta\x1CW6a5lV[\x91\x93\x90a\x0C\xBF\x85aH\xDCV[\x80\x93a\x1Cma9\xD1V[3\x90aH|V[a\n\xE1a;\xAAV[4a\x07\xD3W` a\t\x1A`5a\x0E\xFB6a2}V[4a\x07\xD3W_6`\x03\x19\x01\x12a\x07\xD3W23\x03a\x1DgW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x15a\x1D\\W[a\x1DMW_\x80\x80\x80\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\nZ\x04\xFA=\x15a\x1DHW=a\x1D\x0E\x81a6\x1AV[\x90a\x1D\x1C`@Q\x92\x83a5\xF9V[\x81R_` =\x92\x01>[\x15a\x1D9W_\x80T`\xFF\x19\x16`\x01\x17\x90U\0[cp\xA4\x07\x8F`\xE0\x1B_R`\x04_\xFD[a\x1D&V[c\x0FE\xB9\x8B`\xE4\x1B_R`\x04_\xFD[P`\xFF_T\x16a\x1C\xD0V[c\tfP\xC5`\xE2\x1B_R`\x04_\xFD[4a\x07\xD3W` a\t\x1A`\x17`5a\x1D\x8D6a59V[a\x1D\xA0a\n\x82a\x08\xED`\xA0\x84\x01\x84a<#V[\x906\x15`\xA0a\x16r`\x01\x83\x17a<\xDDV[4a\x07\xD3W` a\t\x1A`\x17`5a\x16\x996a3\xA0V[4a\x07\xD3Wa\x1D\xD66a4\x9EV[``\x81\x01a\x1D\xE4\x81\x83a8\x98V[\x80`\x06\x94\x92\x94\x1B\x81\x81\x04`@\x14\x82\x15\x17\x15a\x1E\xFEWa\x1E\x02\x90aK\xADV[\x93_\x91_[\x81\x81\x10a\x1E\x95WPPPa\x08\x8AWa\x1EM\x81a\x1E-\x85` a\x1ER\x97Q\x91\x01 \x82aSsV[a\x1EG`9a\x1E<\x87\x85a8\x98V[` \x86\x015\x91a@\xEDV[\x90a@\x12V[a8\x98V[_[\x81\x81\x10a\x1EfW` `@Q`\x01\x81R\xF3[\x80a\x1E\x8F`4a\x1Ey`\x01\x94\x86\x88aA\x92V[a\x1E\x86` \x82\x01\x82a7\x7FV[\x90\x915\x91aR}V[\x01a\x1ETV[a\x1E\xA0\x81\x83\x85aA\x92V[_\x90a\x1E\xAF` \x82\x01\x82a7\x7FV[\x90_\x91[\x80\x83\x10a\x1E\xD9WPPP\x90`@\x83\x92`\x01\x94`\x06\x1B\x8B\x01\x905` \x82\x01R\x01R\x01a\x1E\x07V[\x90\x91\x97`\x01\x90` a\x1E\xEC\x8B\x85\x87a8\xCDV[\x015\x80\x96\x01\x95\x86\x10\x17\x98\x01\x91\x90a\x1E\xB3V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045a\x1FI\x813\x91\x90`@Q\x92`\x14RcA\xD0\xE0K_R`4R`8`\x1C \x91`@RV[\x80T\x15a\x1F_W\x90_a\x08\x7F\x92U6\x15\x90aH\xF6V[Pc\xE62\xDB\xAD_R3` R`@R`D`\x1C\xFD[4a\x07\xD3W` a\t\x1A`4a\x0C-6a3\xD4V[4a\x07\xD3W`\x80a\x1F\x996a4\x08V[a\x1F\xEDa\x1F\xE4``\x83\x01a\x1F\xDE\x84a\x1F\xC6a\x1F\xB4\x84\x83a7\x7FV[`@Q\x90`\x06\x1B\x80\x92\x827 \x82aSsV[a\x1EGa\x1F\xD3\x85\x84a7\x7FV[` \x85\x015\x91a@oV[\x83a7\x7FV[\x93\x90\x92\x01a7\xB4V[\x90_[\x83\x81\x10a \x02W` `@Q`\x01\x81R\xF3[\x80a #a \x13`\x01\x93\x87\x86a8\xCDV[` \x81\x015\x905\x863`5a\\1V[P\x01a\x1F\xF0V[4a\x07\xD3W`\xC06`\x03\x19\x01\x12a\x07\xD3Wa Ca1\xBDV[a Ka1\xFFV[\x90`D5\x91`\x08\x83\x10\x15a\x07\xD3W`d5\x91`\x02\x83\x10\x15a\x07\xD3Wa \x87a\x1Ct\x92` \x95a xa1\xE9V[\x95a \x82\x85aH\xDCV[aCKV[\x80\x93a \x91a9\xD1V[`\x845\x92aH|V[4a\x07\xD3W` a\t\x1A`\x17`5a \xB16a5\x05V[a\x01\x80a \xBD\x82aV&V[\x92\x90\x91\x93a \xCFa\x01`\x82\x015a<XV[\x92a\x1C;a7\xC8V[4a\x07\xD3W` a\t\x1A`4a \xED6a3<V[6\x15`\xE0a!\0`@\x83\x17\x84`(aVQV[\x92a\x0B\x8Ba!\x0F\x84\x86\x84aS-V[\x93a<\xDDV[4a\x07\xD3W` a\t\x1A`\x17`5a!,6a2IV[a!@a\x16\x1Ba\tMa\x01\0\x84\x01\x84a8\x98V[\x90a\x01\0a\x0B$a7\xC8V[4a\x07\xD3W` a\t\x1A`4a\x1Bn6a3\xD4V[4a\x07\xD3W` a\t\x1A`5a\x18\xAA6a3<V[``6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa!\xA1\x906\x90`\x04\x01a4nV[`$5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W` \x92a!\xD4a!\xCAa\t\x1A\x946\x90`\x04\x01a4nV[\x92\x90\x933\x91a8\xDDV[`D5\x91aAYV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x80`\x045a\"Ga\"\x0B`\x01`\x01`\\\x1B\x03\x83`\xA0\x1C\x16aHbV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x86\x16\x82R\x90\x92\x16` \x83\x01R\x90\x92\x90a\":\x90\x84\x01`\xFC\x83\x90\x1C`\x07\x16a5\xA6V[``\x83\x01\x90`\xFF\x1Ca5\xB3V[\xF3[4a\x07\xD3W` a\t\x1A`\x17`4a\x08\xD86a3\xD4V[4a\x07\xD3Wa\"n6a5lV[\x91g\xED\xCA\xA8\x9A\x82)9@`4R`(R`\x14R_R` `T_ T_`4R`@Q\x90\x81R\xF3[4a\x07\xD3W` a\t\x1A`\x17`4a\x1D\x8D6a59V[4a\x07\xD3W` a\t\x1A`\x17`4a!,6a2IV[`@6`\x03\x19\x01\x12a\x07\xD3Wa\"\xD8a1\xBDV[`$5\x90\x81\x15\x15\x80\x92\x03a\x07\xD3Wg\xED\xCA\xA8\x9A\x82)9@` R3`\x14R_R\x80`4`\x0C U` R`\x0CQ``\x1C3\x7F\xCE\xB5v\xD9\xF1^N \x0F\xDBP\x96\xD6M]\xFDf~\x16\xDE\xF2\x0C\x1E\xEF\xD1BV\xD8\xE3\xFA\xA2g` \x80\xA3` `@Q`\x01\x81R\xF3[4a\x07\xD3W` a\t\x1A`\x17`5a\x13\xB16a4;V[4a\x07\xD3Wa\x01\x806`\x03\x19\x01\x12a\x07\xD3Wa#ja1\xBDV[a#ra1\xD3V[\x90a#{a1\xE9V[P`\xC45`\x08\x81\x10\x15a\x07\xD3W`\x02`\xE45\x10\x15a\x07\xD3Wa\x01\x045\x90a\x01$5\x90`\x03\x82\x10\x15a\x07\xD3Wa\x01D5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa#\xC6\x906\x90`\x04\x01a3\x0FV[\x94\x90\x92a\x01d5\x95`\x01`\x01`@\x1B\x03\x87\x11a\x07\xD3W\x87\x96a#\xEC\x906\x90`\x04\x01a3\x0FV[\x98\x90\x91a#\xF8\x85a=SV[\x83\x9D\x93\x96\x92\x97\x91\x946\x15\x9Ba$\x0E\x93\x8D\x93aC\xC6V[\x99\x90`@Q\x90_R\x86` R\x8B`@R``_ a\x01\0\x86\x01R`@R`\x1F\x19a\x01`\x85\x01Qa\x01\x7F\x01\x16\x90a\x01@\x17a$G\x94a>rV[a$P\x93a>\xCAV[`\x18\x02w'\x8D\0\tH\x90\x01Q\x80\0\x0F<\0\x02X\0\0<\0\0\x0F\0\0\x01\x90\x1Cb\xFF\xFF\xFF\x16\x91a$}\x93aA\xB4V[a$\x85a;\xAAV[`@Q\x90\x81R` \x90\xF3[`\x806`\x03\x19\x01\x12a\x07\xD3Wa$\xA4a1\xBDV[`$5`\x08\x81\x10\x15a\x07\xD3W`D5\x90`\x02\x82\x10\x15a\x07\xD3W`d5\x91`\x01`\x01`\xA0\x1B\x03\x83\x16\x83\x03a\x07\xD3W` \x93a\n\xE1\x92a$\xE1\x92aB\xB1V[\x91\x824\x91aC|V[4a\x07\xD3W` a\t\x1A`\x17`5a\x17\xA36a2IV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`@QcNA\xA1\xFB`\xE0\x1B\x81R`\x04\x805\x90\x82\x01R_\x81`$\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x15\x81Wa\x12\xB4\x91_\x91a\x15_WP`@Q\x91\x82\x91\x82a1\x93V[4a\x07\xD3W` a\t\x1A`\x17`4a \xB16a5\x05V[4a\x07\xD3W` a\t\x1A`\x17`4a\x1C\x086a2\xDBV[4a\x07\xD3W` a\t\x1A`\x17`5a\x1A\xF36a2}V[4a\x07\xD3W` a\t\x1A`4a%\xCF6a3<V[a%\xD8\x81aWtV[\x90`\xE0a%\xE3a7\xC8V[\x936\x15\x92\x80aB9V[4a\x07\xD3W`@a&'a&\x006a2\xB1V[\x91`X\x92`\x1C\x92`@Q\x92`\x14\x84\x01Rch\xA3\r\xD0\x83R`4\x83\x01R`T\x82\x01R\x01 T\x90V[\x81Q\x90B\x81\x11\x82R` \x82\x01R\xF3[a&?6a2\xB1V[\x90\x91g\xED\xCA\xA8\x9A\x82)9@`4R3`(R`\x14R\x81_R\x80`T_ U_R` Q``\x1C3\x7F\xB3\xFDPq\x83X\x87Vz\x06q\x15\x11!\x89M\xDC\xCC(B\xF1\xD1\x0B\xED\xAD\x13\xE0\xD1|\xAC\xE9\xA7` _\xA4_`4R` `@Q`\x01\x81R\xF3[4a\x07\xD3W` a\t\x1A`5a\r\x0B6a4\xD1V[4a\x07\xD3W` a\t\x1A`4a\x13\x8E6a2\xDBV[4a\x07\xD3W` a\t\x1A`4a\x0FV6a3<V[4a\x07\xD3W``6`\x03\x19\x01\x12a\x07\xD3Wa\x08\x7F`D5`$5`\x0453aA\xB4V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W` `@Q`\x12\x81R\xF3[4a\x07\xD3W` a\t\x1A`\x17`5a\n;6a3<V[4a\x07\xD3Wa'=6a4\x9EV[``\x81\x01a'K\x81\x83a8\x98V[\x80`\x06\x94\x92\x94\x1B\x81\x81\x04`@\x14\x82\x15\x17\x15a\x1E\xFEWa'i\x90aK\xADV[\x93_\x91_[\x81\x81\x10a'\xC1WPPPa\x08\x8AWa\x1EM\x81a\x1E-\x85` a'\x94\x97Q\x91\x01 \x82aSsV[_[\x81\x81\x10a'\xA8W` `@Q`\x01\x81R\xF3[\x80a'\xBB`5a\x1Ey`\x01\x94\x86\x88aA\x92V[\x01a'\x96V[a'\xCC\x81\x83\x85aA\x92V[_\x90a'\xDB` \x82\x01\x82a7\x7FV[\x90_\x91[\x80\x83\x10a(\x05WPPP\x90`@\x83\x92`\x01\x94`\x06\x1B\x8B\x01\x905` \x82\x01R\x01R\x01a'nV[\x90\x91\x97`\x01\x90` a(\x18\x8B\x85\x87a8\xCDV[\x015\x80\x96\x01\x95\x86\x10\x17\x98\x01\x91\x90a'\xDFV[4a\x07\xD3W_6`\x03\x19\x01\x12a\x07\xD3W` a\n\xE1a7\xC8V[4a\x07\xD3W` a\t\x1A`5a\x18\xF76a2\xDBV[4a\x07\xD3W` a\t\x1A`4a\x13\xFA6a2\x15V[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa\t\x1Aa(\xA3` \x926\x90`\x04\x01a4nV[`$5\x91aAYV[4a\x07\xD3W` a\t\x1A`5a%\xCF6a3<V[4a\x07\xD3W``6`\x03\x19\x01\x12a\x07\xD3W`\x045a(\xDDa1\xFFV[`@\x80Q3`\x14RcA\xD0\xE0K_R`4\x84\x90R`8`\x1C \x91RTB\x81\x11\x90\x15\x17a)\x14Wa\t\x1A\x90` \x92`D5\x913a6\x97V[Pc\x92\x87\xBC\xB0_R` R`$`\x1C\xFD[4a\x07\xD3W` a\t\x1A`\x17`4a\x12\xCF6a2\xDBV[4a\x07\xD3W` a\t\x1A`5a\t\x9F6a2}V[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3Wa)ja1\xBDV[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa)\x89\x906\x90`\x04\x01a3\x0FV[`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91`U\x81\x14\x913\x84\x14\x84;\x15\x15\x17\x91\x83a*5W[PP\x17\x15a*%Wa)\xBA\x81a>\xF9V[\x80gD\x03o\xC7}\xEA\xED#`\\\x1B\x17\x91\x82T\x80a*\x11WP\x80` \x93U\x81_R\x82R\x7F\xC5M\xCA\xA6z\x8F\xD7\xB4\xA9\xAAo\xD5sQ\x93Ly&\x13\xD5\xEC\x1A\xCB\xD6Rt'\x0Em\xE8\xF7\xE4`@_\xA1`\x01`\x01``\x1B\x03`@Q\x91\x16\x81R\xF3[\x82c\xC1\x8B\x0E\x97_R` R`@R`D`\x1C\xFD[cN\x7FI+_R` R`$`\x1C\xFD[\x80\x91\x92\x93P\x15a*mW\x80\x82`@Q7`@Q `\x01`\x01`\xA0\x1B\x03\x16\x83\x14`\x01`\x01`\xF8\x1B\x03\x19\x915\x82\x16\x90\x91\x14\x16\x90\x83\x80a)\xA9V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[4a\x07\xD3W` a\t\x1Aa*\x946a4;V[`@Q_Q` a_\xA5_9_Q\x90_R\x81R3\x84\x82\x01R3`@\x82\x01Ra*\xE4\x82`\xE0\x86\x82\x01\x93`\x80\x85``\x83\x017 \x92``\x82\x015\x93a\x08oa\x08g`\x01`\x01`\\\x1B\x03\x87`\xA0\x1C\x16aHbV[`\x80a*\xF2`\xA0\x84\x01a7\xB4V[\x92\x015\x913`5a\\1V[4a\x07\xD3W` a\t\x1A`\x17`5a\x16\xD76a2IV[4a\x07\xD3W` a\t\x1A`5a+*6a3<V[a\x01@a\r}a\x13;a\tM\x83\x85\x01\x85a8\x98V[4a\x07\xD3W` a\t\x1A`5a+T6a2IV[a+ha\t\xB3a\tMa\x01\0\x84\x01\x84a8\x98V[\x90a+v`\xE0\x82\x015a<XV[a\x01\0a+\x86`\x026\x15\x17a<\xDDV[\x92a\x18\xDAa7\xC8V[4a\x07\xD3W`\x80a+\x9F6a4\x08V[a+\xBAa\x1F\xE4``\x83\x01a\x1F\xDE\x84a\x1F\xC6a\x1F\xB4\x84\x83a7\x7FV[\x90_[\x83\x81\x10a+\xCFW` `@Q`\x01\x81R\xF3[\x80a+\xF0a+\xE0`\x01\x93\x87\x86a8\xCDV[` \x81\x015\x905\x863`4a\\1V[P\x01a+\xBDV[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045T_R` _\xF3[4a\x07\xD3W` a\t\x1A`4a\x13\x146a3\xD4V[4a\x07\xD3W` a\t\x1A`5a \xED6a3<V[4a\x07\xD3W` a\t\x1A`5a\x0F\xA36a2\x15V[4a\x07\xD3W` a\t\x1A`\x17`4a,i6a2\x15V[a,}a\x0CSa\x08\xEDa\x01@\x84\x01\x84a<#V[\x90a,\x8A6\x15\x83\x83aS-V[\x90a\x01@a,\x9Ca\x01 \x83\x015a<XV[\x91a,\xAA`\x026\x15\x17a<\xDDV[\x93a\t\x14a7\xC8V[4a\x07\xD3W` a\t\x1A`5a\x18\x036a2\x15V[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3Wa-\x06a,\xE4a1\xBDV[`$5\x90\x91\x90`@Q\x92`\x14RcA\xD0\xE0K_R`4R`8`\x1C \x91`@RV[T`@Q\x81\x15\x15B\x83\x11`\x02\x03\x02\x91`\x03\x83\x10\x15a\x15\x8CW`@\x92\x82R` \x82\x01R\xF3[4a\x07\xD3W` a\t\x1A`5a-?6a2\xDBV[a\x01 a\x13A`@6\x15\x17\x83a[\xC9V[4a\x07\xD3W` a\t\x1A`5a\x0EH6a3\xA0V[4a\x07\xD3W` a\t\x1A`4a\x0BC6a2\x15V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3Wa-\xAA\x906\x90`\x04\x01a3pV[\x90a-\xBCa-\xB73a>\xF9V[a?\xA8V[\x80\x91`\x05\x1B\x01\x90[\x81\x81\x10a-\xD6W` `@Q`\x01\x81R\xF3[` \x90a-\xE43\x825a?\xCFV[\x01a-\xC4V[4a\x07\xD3W` a\t\x1A`4a+*6a3<V[4a\x07\xD3Wa\x01@6`\x03\x19\x01\x12a\x07\xD3Wa.\x19a1\xBDV[a.!a1\xD3V[Pa.*a1\xE9V[P`\x08`\xC45\x10\x15a\x07\xD3W`\x02`\xE45\x10\x15a\x07\xD3Wa\x01\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3Wa\x01$5`\x01`\x01`@\x1B\x03\x81\x11a\x07\xD3W` \x92a.\xAD\x92a.\x80a\x1Ct\x936\x90`\x04\x01a3\x0FV[\x92\x90\x91a.\xC36\x15\x94a.\x95`\xA4\x87\x17a=\x1EV[\x94a.\x9F\x84a=SV[\x9B\x83\x9C\x9A\x93\x99\x91\x92\x9Aa=\xB8V[a\x01\0\x82\x01Ra\x01@a\x02\0\x83\x17\x92\x17\x90a>rV[a>\xCAV[4a\x07\xD3W` a\t\x1A`4a.\xDD6a2}V[a.\xF1a\tSa\x08\xEDa\x01\0\x84\x01\x84a<#V[\x90a\x01\0a/\x016\x15\x84\x84aS-V[\x91a\n\xA7`\x026\x15\x17a<\xDDV[4a\x07\xD3W` a\t\x1A`5a.\xDD6a2}V[4a\x07\xD3W` a\t\x1A`4a-?6a2\xDBV[4a\x07\xD3W` a\t\x1A`5a\t96a2IV[a/W6a2\xB1V[a/o`\x01`\x01`\\\x1B\x03\x83`\xA0\x95\x94\x95\x1C\x16aHbV[\x91`\x01\x80`\xA0\x1B\x03\x81\x16\x92_` \x81`\xA4`@Q\x94\x82\x80R`\x1C\x86\x01\x94\x85\x91c\x1A\x80\x8F\x91\x88R3\x86\x89\x01R3`@\x89\x01R\x8A``\x89\x01R\x8B`\x80\x89\x01R\x89`\xA0\x89\x01RZ\xF1_Qc\xE5\x7Fpo`\xE0\x1B\x01a\x07\xB8WPPPg\xED\xCA\xA8\x9A\x82)9@` R3`\x14R\x83_R`@_ \x80T\x80\x84\x11a\x07rW\x83\x90\x03\x90U`\x14R\x82_R`@_ \x80T\x90\x82\x82\x01\x91\x82\x10a\x07eWU3_R` R3_Q` a_e_9_Q\x90_R`@_\xA4` `@Q`\x01\x81R\xF3[4a\x07\xD3W` a\t\x1A`5a\rb6a2}V[4a\x07\xD3W_6`\x03\x19\x01\x12a\x07\xD3W` \x80Rk\x0BThe Compact`KR``` \xF3[4a\x07\xD3W` a\t\x1A`5a\x17\xD66a2}V[4a\x07\xD3W` a\t\x1A`4a+T6a2IV[4a\x07\xD3W` a\t\x1A`\x17`5a,i6a2\x15V[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x03a\x07\xD3W` \x90`\xE0\x1C`@Q\x90c\x01\xFF\xC9\xA7c\x0Fc/\xB3\x82\x14\x91\x14\x17\x15\x15\x81R\xF3[4a\x07\xD3W`@6`\x03\x19\x01\x12a\x07\xD3Wa1\x04a1\xBDV[g\xED\xCA\xA8\x9A\x82)9@` R`\x14R`$5_R` `@_ T`@Q\x90\x81R\xF3[4a\x07\xD3W` 6`\x03\x19\x01\x12a\x07\xD3Wb+`\x03`\xE2\x1B\x81R`\x04\x805\x90\x82\x01R_\x81`$\x81\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x80\x15a\x15\x81Wa\x12\xB4\x91_\x91a\x15_WP`@Q\x91\x82\x91\x82[` `@\x92\x81\x83R\x80Q\x91\x82\x91\x82\x82\x86\x01R\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[`\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3WV[`\x845\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3WV[`\xA45\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3WV[`$5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x07\xD3WV[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\x80\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01 \x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01@\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[``\x90`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x07\xD3W\x90`$5\x90`D5\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\xA0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[\x91\x81`\x1F\x84\x01\x12\x15a\x07\xD3W\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x07\xD3W` \x83\x81\x86\x01\x95\x01\x01\x11a\x07\xD3WV[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01`\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[\x91\x81`\x1F\x84\x01\x12\x15a\x07\xD3W\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x07\xD3W` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x07\xD3WV[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\xC0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W`\xA0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W`\xC0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[\x91\x81`\x1F\x84\x01\x12\x15a\x07\xD3W\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x07\xD3W` \x80\x85\x01\x94\x84`\x06\x1B\x01\x01\x11a\x07\xD3WV[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W`\x80\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x02\0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3Wa\x01\xE0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[` `\x03\x19\x82\x01\x12a\x07\xD3W`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W`\xE0\x90\x82\x90\x03`\x03\x19\x01\x12a\x07\xD3W`\x04\x01\x90V[``\x90`\x03\x19\x01\x12a\x07\xD3W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x07\xD3W\x90`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x07\xD3W\x90`D5\x90V[\x90`\x08\x82\x10\x15a\x15\x8CWRV[\x90`\x02\x82\x10\x15a\x15\x8CWRV[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90_[\x81\x81\x10a5\xE3WPPP\x90V[\x82Q\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a5\xD6V[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x15\xA0W`@RV[`\x01`\x01`@\x1B\x03\x81\x11a\x15\xA0W`\x1F\x01`\x1F\x19\x16` \x01\x90V[` \x81\x83\x03\x12a\x07\xD3W\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W\x01\x81`\x1F\x82\x01\x12\x15a\x07\xD3W\x80Q\x90a6h\x82a6\x1AV[\x92a6v`@Q\x94\x85a5\xF9V[\x82\x84R` \x83\x83\x01\x01\x11a\x07\xD3W\x81_\x92` \x80\x93\x01\x83\x86\x01^\x83\x01\x01R\x90V[\x90\x92\x91\x92a6\xA3a9\xD1V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x80a7$WP_\x90\x81\x80\x858\x93Z\xF1\x15a7\x17W[g\xED\xCA\xA8\x9A\x82)9@` R\x80`\x14R\x82_R`@_ \x91\x82T\x92\x83\x82\x11a\x07rW\x81_\x94\x03\x90U3\x83R` R`\x01\x80`\xA0\x1B\x03\x16_Q` a_e_9_Q\x90_R`@\x83\xA4a7\x12a;\xAAV[`\x01\x90V[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x90\x91\x92a710\x83a;\x85V[\x92`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10\x82\x85Z\xF1=\x15`\x01_Q\x14\x17\x16\x15a7rWa7j\x90_`4R0\x90a;\x85V[\x90\x03\x90a6\xC2V[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W` \x01\x91\x81`\x06\x1B6\x03\x83\x13a\x07\xD3WV[5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x07\xD3W\x90V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\x18a8\x13W\x90V[P`\xA0`@Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x82\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x82\x01RF``\x82\x01R0`\x80\x82\x01R \x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W` \x01\x91\x81`\x05\x1B6\x03\x83\x13a\x07\xD3WV[\x91\x90\x81\x10\x15a*mW`\x06\x1B\x01\x90V[\x91\x90a8\xE7a9\xD1V[\x825\x90`\x01\x80`\xA0\x1B\x03\x82\x16\x15\x91` \x85\x0154\x14\x15\x83\x164\x15\x84\x14\x17\x82\x15\x17a9\xC4W\x80`\x01`\x01`\\\x1B\x03\x84\x92`\xA0\x1C\x16a9#\x81a?\xA8V[\x93a9\xB2W[P[\x81\x81\x10a9AWPPPPPa9?a;\xAAV[V[a9L\x81\x83\x87a8\xCDV[\x805\x90`\x01`\x01`\\\x1B\x03\x82`\xA0\x1C\x16`\x01`\x01``\x1B\x03\x86\x16\x81\x03a9\x91W[P`\x01\x92\x91a9\x8B\x91` \x015\x90\x87`\x01`\x01`\xA0\x1B\x03\x82\x16aH|V[\x01a9+V[a9\x8B\x91\x95P\x91` \x83a9\xA7`\x01\x96\x95a?\xA8V[\x96\x92PP\x91\x92a9mV[a9\xBE\x904\x90\x86aC|V[_a9)V[c\xCA\x0F\xC0\x8E_R`\x04`\x1C\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x04\x14a;YW\x80`\x03\x14a;GW\x80`\t\x14a;\x10W\x80`\n\x14a:\xD3W`\x08\x14a:-WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a:C6\x15h\x92\x9E\xEE\x14\x9BK\xD2\x12h`(aVQV[\x80[a:\xC3WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x02\x14a:\x9CW`\x01\x14a:\x8EWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[3h\x92\x9E\xEE\x14\x9BK\xD2\x12h]V[P_T`\xFF\x16\x15a:\xB5W3h\x92\x9E\xEE\x14\x9BK\xD2\x12h]V[3h\x92\x9E\xEE\x14\x9BK\xD2\x12hUV[c\xF5|D\x8B_R` R`$`\x1C\xFD[P`\xE0`@6\x15\x17h\x92\x9E\xEE\x14\x9BK\xD2\x12h\x01`\xC0\x81\x015_R\x015` Ra;\n`@_ h\x92\x9E\xEE\x14\x9BK\xD2\x12h`1aVQV[\x80a:EV[Ph\x92\x9E\xEE\x14\x9BK\xD2\x13(5_\x90\x81Rh\x92\x9E\xEE\x14\x9BK\xD2\x13H5` R`@\x90 a;\n\x90h\x92\x9E\xEE\x14\x9BK\xD2\x12h`/aVQV[Ph\x92\x9E\xEE\x14\x9BK\xD2\x12h\\\x80a:EV[P_T`\xFF\x16\x15a;uWh\x92\x9E\xEE\x14\x9BK\xD2\x12h\\\x80a:EV[h\x92\x9E\xEE\x14\x9BK\xD2\x12hTa;\nV[`$`\x10` \x93\x92\x84\x93`\x14Rcp\xA0\x821``\x1B_RZ\xFA`\x1F=\x11\x16` Q\x02\x90V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80`\x06\x14a;\xFCW`\x05\x14a;\xEEWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[_h\x92\x9E\xEE\x14\x9BK\xD2\x12h]V[P_T`\xFF\x16\x15a<\x15W_h\x92\x9E\xEE\x14\x9BK\xD2\x12h]V[_h\x92\x9E\xEE\x14\x9BK\xD2\x12hUV[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x07\xD3W` \x01\x91``\x82\x026\x03\x83\x13a\x07\xD3WV[`\xA0\x90`@Q\x90\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x82R\x7F^o{N\x1A\xC3\xD6%\xBA\xC4\x18\xBC\x95U\x10\xB3\xE0T\xCBl\xC2<\xC2x\x85\x10\x7F\x08\x01\x80\xB2\x92` \x83\x01R\x7F\x04HR\xB2\xA6p\xAD\xE5@~x\xFB(c\xC5\x1D\xE9\xFC\xB9eB\xA0q\x86\xFE:\xED\xA6\xBB\x8A\x11m`@\x83\x01R``\x82\x01R0`\x80\x82\x01R \x90V[\x90`@Q\x91_Q` a_\xA5_9_Q\x90_R_R_Q` a_\xC5_9_Q\x90_R` R_Q` a_\x85_9_Q\x90_R`@R`\x05\x1BQ\x91`@RV[`\xA0\x90`\x80`@Q\x91\x7F\xE0UI5c8\\\xC5\x88\xFF\xFA\xCB\xFF\xE2\xDA\xB0#\xFE\xF8\x07\xBA\xA4IS\x041\x16\x9B\x0E\xEB[i\x83R` \x83\x017 \x90V[\x90a=\\a9\xD1V[a=|a=t`\xA45`\xC45`\xE45a \x82\x87aH\xDCV[\x920\x90a;\x85V[\x90`@Q\x90c\x13|)\xFE\x82R`\x80`\x04` \x84\x0170`\xA0\x83\x01R`$5`\xC0\x83\x01R`\x845`\xE0\x83\x01Ra\x01@a\x01 \x83\x01Ra\x01`\x82\x01\x90V[`\x80\x7Fcipient)TokenPermissions(address\x91`\x96\x81R\x7FCompactDeposit witness)CompactDe` \x82\x01R\x7Fposit(address allocator,uint8 re`@\x82\x01R\x7FsetPeriod,uint8 scope,address re``\x82\x01Ru token,uint256 amount)`\x96\x82\x01R\x01RV[\x90\x93\x80_\x94\x93`\x1C\x92\x86\x95\x82a>\x86aN\xAFV[\x99\x87\x01R`@\x83\x87\x01\x83` \x82\x01R\x017\x01`$\x01\x91\x01\x82n\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3Z\xF1\x16\x15a>\xB8WV[=a\x07\xCBWc\x7F(\xC6\x1E_R`\x04`\x1C\xFD[a>\xD8\x90\x92\x91\x920\x90a;\x85V[\x92\x83\x81\x10\x15a>\xECWa9?\x93\x03\x91aC|V[cBm\x8D\xCF_R`\x04`\x1C\xFD[j\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFj\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`I\x1C\x16\x81\x83`H\x1C\x16\x17\x80`\x02\x1C\x17\x80`\x04\x1C\x17\x80`\x08\x1C\x17\x80`\x10\x1C\x17\x80` \x1C\x17gUUUUUUUU\x81`\x01\x1C\x16\x90\x03g33333333\x80\x82`\x02\x1C\x16\x91\x16\x01\x80`\x04\x1C\x01g\x0F\x0F\x0F\x0F\x0F\x0F\x0F\x0Ff\x0F\x0F\x0F\x0F\x0F\x0F\x0F\x82`\x08\x1C\x16\x91\x16\x01\x80`\x10\x1C\x01\x91\x16\x90i\x0F\xED\xCB\xA9\x87eC!\0\0`\x0F`X\x1B\x91`\x7F`\x03\x19\x91\x80` \x1C\x01\x16`H\x03\x16\x1C`X\x1B\x16\x17\x90V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x15a?\xBFWPV[c\xCF\x90\xC3\xA8_R` R`$`\x1C\xFD[`@Q\x91` Rc\x03\xF3{\x1A`\x0CR\x80`@R`7`( \x90`\x01\x82T\x91`\xFF\x16\x1B\x90\x80\x82\x16a@\x01W\x17\x90U`@RV[c\xDB\xC2\x05\xB1``\x1B`\x0CR`D`\x1C\xFD[\x91a@ `@\x82\x015aOQV[\x805\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x91\x825\x92`\x01`\x01`@\x1B\x03\x84\x11a\x07\xD3W` \x01\x92\x806\x03\x84\x13a\x07\xD3Wa9?\x93a@i\x91a@aa7\xC8V[\x91\x85\x85aOlV[3aP\xBCV[\x90\x92\x91\x83\x15\x91a@\x81\x85\x82`8aZ\xA0V[\x91a@\x95a@\x8E\x84aHbV[\x80\x92a?\xCFV[\x94`\x01`\x01``\x1B\x03`\x01\x93\x16\x90[\x80\x84\x10a@\xC2WPPPPa@\xB5WV[c:\x03\xD3\xBB_R`\x04`\x1C\xFD[\x90\x91\x92\x93`\x01\x90\x83`\x01`\x01``\x1B\x03a@\xDF\x88\x86\x89`8a[\nV[\x16\x14\x15\x17\x94\x01\x92\x91\x90a@\xA4V[\x91\x90\x93\x92\x84\x15\x92a@\xFF\x86\x82\x84aZ\xA0V[\x92aA\x0Ca@\x8E\x85aHbV[\x95`\x01`\x01``\x1B\x03`\x01\x94\x16\x91[\x81\x85\x10aA-WPPPPPa@\xB5WV[\x90\x91\x92\x93\x94`\x01\x90\x84`\x01`\x01``\x1B\x03aAJ\x89\x87\x87\x8Ba[\nV[\x16\x14\x15\x17\x95\x01\x93\x92\x91\x90aA\x1BV[\x91\x90_[\x81\x81\x10aAmWPPPP`\x01\x90V[\x80aA\x8C\x84aA\x7F`\x01\x94\x86\x89a8\xCDV[` \x81\x015\x9053aA\xB4V[\x01aA]V[\x91\x90\x81\x10\x15a*mW`\x05\x1B\x81\x015\x90`>\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x90V[\x91\x92\x90\x92`@Q\x90\x83`\x14\x83\x01Rch\xA3\r\xD0\x82R`4\x82\x01\x94\x85R`T\x82\x01R`X`\x1C\x82\x01 \x82B\x01\x92b'\x8D\0\x81\x11\x82T\x85\x10\x17aB)WP\x82\x90U`t\x01R`\x01`\x01`\xA0\x1B\x03\x16\x90\x7F\xF7\x8A/3\xFF\x80\xEFC\x91\xF7D\x9Ct\x8D\xC2\xD5w\xA6,\xD6E\x10\x8FO@i\xF4\xA7\xE0c[j\x90``\x90\xA2V[c\x1F\x9A\x96\xF4_R` R`$`\x1C\xFD[\x93\x91\x95\x90\x94\x97\x96\x92\x86\x01\x95\x865\x95` \x88\x015\x97``\x81\x015\x98aB]\x89\x87aR\xBFV[\x89\x81\x10aB\x9CWP\x91aB\x99\x99\x9A\x93\x91aB\x93\x95\x93`@`\x01\x80`\xA0\x1B\x03\x91\x015\x16\x97`\x01`\x01`\\\x1B\x03\x8A`\xA0\x1C\x16\x90aLJV[\x90a\\1V[\x90V[\x89\x90c0x\xB2\xF6_R` R`@R`D`\x1C\xFD[\x90\x91aB\xBC\x81a>\xF9V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x90\x91\x18a?\xBFW`\xA0\x1B\x91`\xFC\x1B\x90`\xFF\x1B\x17\x17\x90V[aB\xEB\x82a>\xF9V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x90\x92\x18aC\x0FW`\x03`\xFC\x1B\x91`\xA0\x1B\x17\x17\x90V[Pc\xCF\x90\xC3\xA8_R` R`$`\x1C\xFD[aC)\x81a>\xF9V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x90\x91\x18a?\xBFW`\xA0\x1B`\x03`\xFC\x1B\x17\x90V[\x92aCU\x81a>\xF9V[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x90\x91\x18a?\xBFW`\xA0\x1B\x91`\xFC\x1B\x90`\xFF\x1B\x17\x17\x17\x90V[\x90\x91g\xED\xCA\xA8\x9A\x82)9@` R\x81`\x14R\x82_R`@_ \x80T\x90\x82\x82\x01\x91\x82\x10a\x07eWU3_R` R`\x01\x80`\xA0\x1B\x03\x16__Q` a_e_9_Q\x90_R`@\x82\xA4V[\x93\x91\x94\x92_\x91` \x86\x01\x92_\x93_\x95\x15\x90\x81aH\x1FW[\x85\x15aG\xCEW[P_\x92\x80\x15aG:W[_\x19\x81\x01\x15aF\x9BW[\x83\x15aE\xE1W[\x84\x15aD`WPPP\x81\x84\x95\x96\x97\x827\x01\x94nuint256 amount)`\x0E\x87\x01R\x7F)TokenPermissions(address token,_\x19\x87\x01R`\x0E\x81\x87\x03\x01\x90R\x80\x85\x03\x90 \x93\x03\x90 \x90V[\x91\x98P\x96\x93P\x83\x91\x94P`\x0E\x92P`\x05\x1B\x93nuint256 amount)\x83\x82\x01R\x7F)TokenPermissions(address token,_\x19\x82\x01R\x03\x01\x90R`@Q\x92aEmW[\x83\x15aD\xF9W[_Q` a_\xA5_9_Q\x90_R_R_Q` a_\xC5_9_Q\x90_R` R_Q` a_\x85_9_Q\x90_R`@RQ\x91`@RV[\x7FE\x01-B\xFA\xD8\xC9\xE97\xCF\xF5\xA2\xD7P\xEE\x18q=\xD4Z\xAD\xCDq\x86`\xD5R0Va\x8D\x99_R\x7F\xC2\xE1j\x82;\x8C\xDD\xDF\xDF\x88\x99\x91\xD7\xA4a\xF0\xA1\x9F\xAF\x1F\x8E`\x8F\x1C\x16D\x95\xA5!Q\xCC>` R\x7F\xD2\xF6\xAD9\x13(\x93o\x11\x82P\xF21\xE6<~c\x9F\x97V\xA9\xEB\xF9r\xD8\x17c\x87\nw-\x87`@R\x80Q\x93PaD\xC0V[\x7F+\xF9\x81\xC4,\x7FB;\x06\xFAI\xBA\x99m)0\x88~/\x1FS\xD9\xA2k\x8Ct#\xAC\x1C\xF8>a_R\x7F\xD1DE\xD7\x82\x13\xA5\xAC\xDD\xFA\x89\x17\x1B\x01\x99\xDER\x1C;6s\x8B\x83Rd\xCA\xE1\x8FZS\xDB\xF3` R\x7F2\x9B<Rz<t\xB8\xCA\xBCQ\xC3\x04f\x9D\x18f\xB8sR\xCA\xFD\xF4@\xEF+\xEC\xD6\xDC&\x1D\x1E`@R\x80Q\x93PaD\xB9V[\x7FMultichainCompact compact)Multic\x87R\x7FhainCompact(address sponsor,uint` \x88\x01R\x7F256 nonce,uint256 expires,Segmen`@\x88\x01Ro] idsAndAmounts,`p\x88\x01R\x7Fiter,uint256 chainId,uint256[2][``\x88\x01R`\x1A\x87\x01\x96`\x90\x01\x93PaC\xFFV[\x7FBatchCompact compact)BatchCompac\x87R\x7Ft(address arbiter,address sponso` \x88\x01Rzuint256[2][] idsAndAmounts,`[\x88\x01R\x7Fr,uint256 nonce,uint256 expires,`@\x88\x01R`\x15\x87\x01\x96`{\x01\x93PaC\xF8V[\x7FCompact compact)Compact(address \x87R\x7Farbiter,address sponsor,uint256 ` \x88\x01Ro,uint256 amount,`P\x88\x01R\x7Fnonce,uint256 expires,uint256 id`@\x88\x01R`\x10\x87\x01\x96`p\x01\x93PaC\xEEV[uivation(uint256[] ids,`6\x8A\x01R\x7FBatchActivation witness)BatchAct\x90R`V\x88\x01\x95P`8\x88\x01\x94P_aC\xE4V[hnt256 id,`)\x8A\x01R\x7FActivation witness)Activation(ui\x81R`I\x89\x01\x96P`3\x89\x01\x95PaC\xDDV[gD\x03o\xC7}\xEA\xED#`\\\x1B\x81\x17T\x91\x90\x82\x15a?\xBFWPV[\x91\x90aH\x880\x84a;\x85V[\x92`@Q\x94``R0`@R3``\x1B`,Rc#\xB8r\xDD``\x1B`\x0CR` _`d`\x1C\x82\x85Z\xF1=\x15`\x01_Q\x14\x17\x16\x15aH\xCFWa9?\x94_``R`@Ra>\xCAV[cy9\xF4$_R`\x04`\x1C\xFD[\x80``\x1B\x15aH\xE8W\x90V[c\x96\x1C\x9AO`@R`$`\\\xFD[\x90\x80\x15\x15_R` R3\x7F\xE2\x7F^\x03\x82\xCFSG\x96_\xC8\x1D\\\x81\xCD\x14\x18\x97\xFE\x9C\xE4\x02\xD2,Ik|-\xDC\x84\xE5\xFD`@_\xA3V[`\x01`\x01`@\x1B\x03\x81\x11a\x15\xA0W`\x05\x1B` \x01\x90V[\x90aIH\x82aI'V[aIU`@Q\x91\x82a5\xF9V[\x82\x81R\x80\x92aIf`\x1F\x19\x91aI'V[\x01\x90` 6\x91\x017V[\x80Q\x82\x10\x15a*mW` \x91`\x05\x1B\x01\x01\x90V[\x91\x92aI\x8Ea9\xD1V[`\x01`\x01`\xA0\x1B\x03\x835\x16\x15\x92` \x81\x0154\x90\x81\x14\x15\x85\x16\x90\x15\x85\x14\x17\x83\x15\x17a9\xC4W\x83\x92aI\xC6`\x845`\xA45`\xC45aB\xB1V[\x95aI\xD0\x82aI>V[\x94aJmW[P\x84\x81\x03\x95aI\xE4\x87aI>V[\x92_\x92_[\x89\x81\x10aJ\x08WPPPPaI\xFBW\x90V[c\x0F/\x1EQ_R`\x04`\x1C\xFD[\x80aJY\x8A`\x01\x93\x97\x95\x96\x97\x01\x94aJ)aJ$\x87\x87\x8Aa8\xCDV[a7\xB4V[\x90\x84\x80`\xA0\x1B\x03\x82\x16`\x01`\x01``\x1B\x03`\xA0\x1B\x8A\x16\x17\x98\x89\x11\x15\x17\x97aJQ\x81\x97\x8DaIpV[R0\x90a;\x85V[aJc\x82\x89aIpV[R\x01\x92\x91\x92aI\xE9V[aJy\x90\x874\x91aC|V[\x83Q\x15a*mW\x85` \x85\x01R_aI\xD6V[\x91`@Q\x91\x83`\x06\x1B\x84`\x07\x1B\x91`\x06\x1B`$5\x01c\xFE\x8E\xC1\xA7\x85R`\xC0` \x86\x01R\x81a\x01@\x01`@\x86\x01R`\x045``\x86\x01R\x82a\x01`\x01`\xA0\x86\x01R```\xE0\x86\x01R`D5a\x01\0\x86\x01R`d5a\x01 \x86\x01R\x85a\x01@\x86\x01R\x81`$\x82\x01a\x01`\x87\x017\x81\x85\x01\x95a\x01`\x87\x01R_[\x82\x81\x10aK\x18WP\x93\x94PP\x83\x01a\x01\x80\x01\x91PV[\x80`@\x91\x88\x010a\x01\x80\x82\x01Ra\x01\xA0`D\x83\x86\x01\x015\x91\x01R\x01aK\x02V[\x83Q_\x96\x90\x95\x94\x93\x92\x90\x87[\x87\x81\x10aK_WPPPPPPPPa>\xECWa9?a;\xAAV[\x80aK\xA7\x83`\x01\x93\x01\x9AaK\x81\x8CaK|aJ$0\x92\x8C\x8Ba8\xCDV[a;\x85V[\x90aK\x9DaK\x8F\x85\x8CaIpV[Q\x91\x83\x83\x10\x15\x17\x9D\x89aIpV[Q\x91\x03\x90\x8AaC|V[\x01aKDV[\x90aK\xB7\x82a6\x1AV[aK\xC4`@Q\x91\x82a5\xF9V[\x82\x81R\x80\x92aIf`\x1F\x19\x91a6\x1AV[\x90\x15a*mW\x90V[\x91\x90\x81\x10\x15a*mW``\x02\x01\x90V[\x81`\x06\x1B\x82\x81\x04`@\x14\x83\x15\x17\x15a\x1E\xFEWaL\t\x90aK\xADV[\x91_[\x81\x81\x10aL WPPP` \x81Q\x91\x01 \x90V[\x80aL.`\x01\x92\x84\x86aK\xDEV[`@` \x83`\x06\x1B\x88\x01\x92\x805\x82\x85\x01R\x015\x91\x01R\x01aL\x0CV[`@\x84\x015`\x01`\x01`\xA0\x1B\x03\x16\x97\x96\x90\x95\x93\x94\x86\x94\x89\x94\x91\x93\x875\x88\x01\x93` \x89\x015\x89\x01\x92\x90\x91\x835\x91\x90aL\x84`\x80\x8C\x015aOQV[aL\x8D\x90aHbV[``\x81\x9B\x015\x90aL\x9D\x91a?\xCFV[\x86\x81\x15\x02\x01\x91\x81\x15\x15\x87\x84\x14\x15\x17\x90\x81\x15\x9BaL\xD4\x99a9?\x9DaL\xF0W[PPPaL\xDAW[PPP\x85\x825\x92` \x01\x91aOlV[\x84aP\xBCV[aL\xE8\x92` \x01\x8C\x89aOlV[_\x80\x80aL\xC4V[aM\x1B\x93P`X\x92`\x1C\x92`@Q\x92`\x14\x84\x01Rch\xA3\r\xD0\x83R`4\x83\x01R`T\x82\x01R\x01 T\x90V[B\x10\x15_\x89\x8EaL\xBCV[\x98\x97\x93\x80\x95\x91\x96aMk\x93\x98\x94\x89\x01\x98\x895\x81\x01\x98` \x8A\x81\x01\x9A5\x9B\x015\x97aMcaMS\x8D\x8DaK\xD5V[5`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x90V[\x9D\x8E\x91a^EV[\x90aMv\x86\x86aK\xD5V[\x95aM\x9F` aM\x93\x87\x8A5\x80\x9B`@\x81\x015\x94\x85\x91\x015aS\\V[\x83\x15\x17\x98\x86\x86\x86a\\1V[P`\x01`\x01``\x1B\x03`\x01\x99\x16\x98[\x81\x81\x10aM\xC7WPPPPPPPa7\x12\x91\x92PaSmV[aM\xD2\x81\x83\x89aK\xDEV[\x805\x98\x89\x91\x88`@\x82\x015\x9B\x8C\x92` \x015\x92aM\xEE\x93aS\\V[\x8C\x83`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x14\x15\x17\x17\x98aN\r\x91\x87\x87\x87a\\1V[P`\x01\x01aM\xAEV[\x90\x15a*mW\x805\x90`^\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x90V[\x91\x90\x81\x10\x15a*mW`\x05\x1B\x81\x015\x90`^\x19\x816\x03\x01\x82\x12\x15a\x07\xD3W\x01\x90V[\x81`\x06\x1B\x82\x81\x04`@\x14\x83\x15\x17\x15a\x1E\xFEWaNn\x90aK\xADV[\x91_[\x81\x81\x10aN\x85WPPP` \x81Q\x91\x01 \x90V[\x80aN\x93`\x01\x92\x84\x86aN1V[`@` \x83`\x06\x1B\x88\x01\x92\x805\x82\x85\x01R\x015\x91\x01R\x01aNqV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a7\x12Wn\"\xD4s\x03\x0F\x11m\xDE\xE9\xF6\xB4:\xC7\x8B\xA3;\x15\x15\x90V[`\xA0\x92\x91`@``\x92\x81Q\x94\x84\x86\x01R_Q` a_E_9_Q\x90_R\x85R\x85` \x86\x01\x933\x85RF\x84\x88\x01R`\x80\x87 \x87R\x82\x01\x015\x81\x01\x805`\x05\x1B\x80\x91` \x01\x857` \x01\x85 `\x80\x86\x01R_Q` a_\x85_9_Q\x90_R\x85R\x01\x907 \x90V[B\x81\x11\x15aO\\WPV[c\xF8\r\xBA\xEA_R` R`$`\x1C\xFD[`@\x80Qa\x19\x01_\x90\x81R` \x97\x90\x97R\x91\x81R`B`\x1E \x91\x81R\x91\x93\x90\x92\x90\x91`d\x83\x01\x90\x83\x14`\x01`\x01`\xA0\x1B\x03\x86\x16`A\x85\x14\x81aO\xC7W[PPPPPPP3\x14\x17\x15aO\xBAWV[c\x8B\xAAW\x9F_R`\x04`\x1C\xFD[\x90\x91\x92\x93\x94\x95\x97P`@Q\x92\x88_RaPlW[aP-W[` \x94\x95\x96_``R\x82`@Rc\x0B\x13]?`\xE1\x1B\x83R`\x04\x83\x01R`$\x82\x01\x95\x86\x94`@\x86R\x81`D\x85\x01R`d\x84\x017Z\xFA\x90Qc\x0B\x13]?`\xE1\x1B\x14\x16\x90_\x80\x80\x80\x80\x80\x80aO\xA9V[`@\x84\x015_\x1A` R`@\x84\x817` `\x01`\x80_\x82Z\xFAQ\x81\x18=\x15\x17aO\xE0WP\x94PPPP`\x01\x91_``R`@R_\x80\x80\x80\x80\x80\x80aO\xA9V[` \x85\x81\x015`\xFF\x81\x90\x1C`\x1B\x01\x82R\x865`@R`\x01`\x01`\xFF\x1B\x03\x16``R`\x01`\x80_\x82Z\xFAQ\x82\x18=\x15\x17aO\xDBWPP\x94PPPP`\x01\x91_``R`@R_\x80\x80\x80\x80\x80\x80aO\xA9V[_\x91\x82R3\x92`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x91\x16\x90\x7Fw\x0C2\xA21Kp\rb9\xEE5\xBA#\xA9i\x0F/\xCE\xB9:U\xD8\xC7S\xE9S\x05\x9B;\x18\xD4\x90` \x90\xA4V[`@Q\x92``\x84\x01R_Q` a_E_9_Q\x90_R\x83R` \x83\x01\x913\x83RF`@\x85\x01R`\x80\x84 \x90\x82\x01\x90`\xA0\x82\x015\x83\x01\x90`\xC0\x825`\x05\x1B\x93\x015`\x05\x1B_\x90_[\x85\x81\x10aQxWPPPPP\x91`@``\x92`\xA0\x95\x94` \x01\x85 `\x80\x86\x01R_Q` a_\x85_9_Q\x90_R\x85R\x01\x907 \x90V[\x80\x89\x01` \x84\x83\x01\x87\x01\x015\x81R\x82\x82\x14aQ\x97W[P` \x01aQAV[` \x90\x81\x01\x85\x90R\x92P\x82aQ\x8EV[\x94\x91\x95\x84\x91\x97\x96aQ\xD4\x94\x81\x015\x81\x01\x98\x89` \x01\x995\x9AaQ\xCCaMS\x8D\x8DaN\x16V[\x98\x89\x91a^EV[\x85\x15\x95`\x01`\x01``\x1B\x03_\x94\x16\x93[\x81\x81\x10aQ\xFBWPPPPPPPa7\x12\x90aSmV[\x80aRI\x87aR\r`\x01\x94\x86\x8CaN1V[\x805\x9B\x8C\x8A`\x01`\x01`\\\x1B\x03aR$\x8C\x84aS\xB0V[\x92`\xA0\x1C\x16\x14\x15\x17\x17\x9B\x87` aR>`@\x85\x01\x85a7\x7FV[\x91\x90\x94\x015\x93aS\xC6V[P\x01aQ\xE4V[aB\x99\x90aRu`@6\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90`1aVQV[\x92\x91\x90_[\x81\x81\x10aR\x90WPPPPPV[\x80aR\xB8aR\xA1`\x01\x93\x85\x89a8\xCDV[\x85` aR\xAD\x83a7\xB4V[\x92\x015\x913\x89a\\1V[P\x01aR\x82V[\x81`\xFF\x1C\x15\x90\x15\x17\x15aR\xCFWPV[c\xA0cV\xF5_R` R`$`\x1C\xFD[\x95\x84\x90aS\x0E\x93\x99\x94\x96\x92\x96\x8A\x01\x99\x8A5\x97\x88\x96`@\x8D\x015\x83\x01\x9A`\x01`\x01`\\\x1B\x03\x89`\xA0\x1C\x16\x91a^EV[\x95aS\x1F` \x92aB\x99\x98\x94aR\xBFV[\x015\x92\x805\x90` \x01aS\xC6V[`\xA0\x91`@Q\x93\x82\x01\x91`\xC0\x83\x015\x01\x90\x815\x93\x84\x93\x015\x85R` \x85\x01R` \x01`@\x84\x017`@\x01\x90 \x90V[\x92aSg\x91\x92aS\xB0V[\x91\x10\x17\x90V[a@\xB5WV[`\xC0\x91`@\x80Q\x92_Q` a_\xC5_9_Q\x90_R\x84R3` \x85\x01R3\x82\x85\x01R` \x81\x015``\x85\x01R\x015`\x80\x83\x01R`\xA0\x82\x01R \x90V[`\xFF\x1C`\x02\x81\x10\x15a\x15\x8CW`\x01\x14\x90\x15\x15\x16\x90V[\x91\x94\x92\x90\x92_\x95\x84\x15\x94_[\x81\x81\x10aT\x01WPPPPPP\x82\x82\x10\x17aS\xEEWPP`\x01\x90V[c0x\xB2\xF6_R` R`@R`D`\x1C\xFD[\x80aT4` \x9A\x98\x87aT-aT\x1A`\x01\x96\x88\x8Da8\xCDV[\x9D\x8E\x015\x92\x8C\x84\x01\x9C\x8D\x10\x17\x9B\x9Da7\xB4V[\x87\x89a\\1V[P\x01aS\xD2V[\x90`@Q\x91`\xC0\x81\x015\x01\x91\x825\x80\x93\x7FMultichainCompact(address sponso\x83R\x7Fr,uint256 nonce,uint256 expires,` \x84\x01R\x7FSegment[] segments)Segment(addre`@\x84\x01Ru56[2][] idsAndAmounts,`v\x84\x01R\x7Fss arbiter,uint256 chainId,uint2``\x84\x01R` \x01`\x96\x83\x017\x82`C\x01`S\x82\x01 \x92`\x96\x01\x90 \x90V[aB\x99\x906\x15\x90`(aVQV[\x90aB\x99aU8`@6\x15\x17\x84`(aVQV[\x92\x836\x15\x91aS-V[aUm\x90aUg`\x806\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a[\x8AV[\x90\x91V[aUm\x90aU\x96`@6\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a[fV[\x90aB\x99aU8aU\xC4`\x806\x15\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x84`2aVQV[\x90aB\x99aU8a\x0Bk`@6\x15\x17\x85\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[aV\x1F\x90aV\x19`\x806\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a[\xD9V[\x91\x92\x90\x91\x90V[aV\x1F\x90aVK`\xC06\x15\x17\x82\x90`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[\x90a\\\nV[\x91\x90\x91\x80`2\x14aWdW\x80`1\x14aWWW\x80`0\x14aWGW\x80`+\x14aW\x16W\x80`/\x14aW\tW\x80`(\x14aV\xC8W\x80`3\x14aV\xB0W`*\x14aV\xA7WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x91aSsV[P`\xE0\x91\x01`\xC0\x81\x015_R\x015` R`@_ \x90V[P`\xC0`\xE0\x92```@\x80Q\x94\x83\x01\x92_Q` a_\xA5_9_Q\x90_R\x86R3` \x87\x01R\x01`@\x85\x017`\xA0\x81\x015`\xA0\x84\x01R\x015`\xC0\x82\x01R \x90V[PaB\x99\x916\x15\x90aN\xEAV[P\x90`\xC0\x91```@\x80Q\x93_Q` a_\xC5_9_Q\x90_R\x85R3` \x86\x01R\x01`@\x84\x017`\xA0\x82\x01R \x90V[PaB\x99\x91`@6\x15\x17\x90aN\xEAV[PaB\x99\x916\x15\x90aP\xF9V[PaB\x99\x91`@6\x15\x17\x90aP\xF9V[\x90a\x01\0`@Q`\xA0`\xC0\x85\x015\x85\x01\x94``\x865\x96\x7FCompact(address arbiter,address \x85R` \x85\x01\x97\x7Fsponsor,uint256 nonce,uint256 ex\x89R\x80`@\x87\x01\x92\x7Fpires,uint256 id,uint256 amount,\x84R` \x01\x84\x88\x017\x82\x01\x85 \x97\x88\x86R3\x90R`@\x83\x01\x907`\xE0\x81\x015\x82\x84\x01R\x83\x81\x015`\xC0\x84\x01R\x015`\xE0\x82\x01R \x91\x90V[`\xE0\x90\x92\x91\x92`\xA0`@Q\x91`\xC0\x81\x015\x81\x01\x95``\x875\x97\x7FBatchCompact(address arbiter,add\x86R` \x86\x01\x98\x7Fress sponsor,uint256 nonce,uint2\x8AReounts,`F\x88\x01R\x80`@\x88\x01\x92\x7F56 expires,uint256[2][] idsAndAm\x84R` \x01`f\x89\x017`f\x01\x86 \x98\x89\x87R3\x90R`@\x84\x01\x907\x82\x84\x01R\x015`\xC0\x82\x01R \x91\x90V[\x92\x91\x92\x80`,\x14aY\xDFW`)\x14aY\x1DWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[a\x01\0\x90`\xA0`@Q\x91\x83`\xC0\x82\x015\x82\x01\x96``\x885\x98\x7FCompact(address arbiter,address \x87R` \x87\x01\x99\x7Fsponsor,uint256 nonce,uint256 ex\x8BR\x80`@\x89\x01\x92\x7Fpires,uint256 id,uint256 amount,\x84R` \x01\x84\x8A\x017\x82\x01\x87 \x99\x8A\x88R3\x90R`@\x85\x01\x907\x82\x01`\xE0\x81\x015\x84\x86\x01R\x015`\xC0\x84\x01R\x015`\xE0\x82\x01R \x91\x90V[P`\xE0\x90`\xA0`@Q\x91`\xC0\x81\x015\x81\x01\x95``\x875\x97\x7FBatchCompact(address arbiter,add\x86R` \x86\x01\x98\x7Fress sponsor,uint256 nonce,uint2\x8AReounts,`F\x88\x01R\x80`@\x88\x01\x92\x7F56 expires,uint256[2][] idsAndAm\x84R` \x01`f\x89\x017`f\x01\x86 \x98\x89\x87R3\x90R`@\x84\x01\x907\x82\x84\x01R\x015`\xC0\x82\x01R \x91\x90V[\x91\x90\x91\x80`8\x14aZ\xF4W\x80`9\x14aZ\xD8W`\x07\x14aZ\xCEWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x91_aVQV[P_aZ\xEC\x91`\x01`\x01`\\\x1B\x03\x93aA\x92V[5`\xA0\x1C\x16\x90V[P\x15a*mW5`\xA0\x1C`\x01`\x01`\\\x1B\x03\x16\x90V[\x80`8\x14a[RW\x80`9\x14a[>W`\x07\x14a[5WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x92aVQV[P\x91aZ\xEC\x91`\x01`\x01`\\\x1B\x03\x93aA\x92V[P\x91aZ\xEC\x91`\x01`\x01`\\\x1B\x03\x93a8\xCDV[\x91\x90a[\x86\x90a[u\x84aT;V[\x94\x90\x85\x91`@6\x15\x17\x90`-a\\\xE7V[\x91\x90V[\x91\x90a[\x86\x90a[\x99\x84aT;V[\x94\x90\x85\x91`@6\x15\x17\x90`.a\\\xE7V[\x91a[\xBAa[\x86\x92\x84`,aX\xF7V[\x92\x90\x93\x84`@6\x15\x17\x91aS-V[\x91a[\xBAa[\x86\x92\x84`)aX\xF7V[\x91a[\x86`@\x93a\\\0\x93a[\xED\x82aT;V[\x95\x90\x91\x866\x15\x93`\x80\x85\x17\x86`-a\\\xE7V[\x95\x86\x91\x17\x91aS-V[\x91a[\x86`@\x93a\\\0\x93a\\\x1E\x82aT;V[\x95\x90\x91\x866\x15\x93`\x80\x85\x17\x86`.a\\\xE7V[\x93\x92\x91\x90\x93\x80`5\x14a\\\xDDW\x80`4\x14a\\jW`7\x14a\\aWcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x93a@\xEDV[P\x90\x92\x91g\xED\xCA\xA8\x9A\x82)9@` R\x82`\x14R\x83_R`@_ \x80T\x80\x83\x11\x83\x15\x17a\x07rW\x82\x90\x03\x90U\x81`\x14R\x83_R`@_ \x80T\x90\x82\x82\x01\x91\x82\x10a\x07eWU3_R` R`\x01\x80`\xA0\x1B\x03\x16\x90`\x01\x80`\xA0\x1B\x03\x16_Q` a_e_9_Q\x90_R`@_\xA4`\x01\x90V[PaB\x99\x93a6\x97V[\x95\x94\x93\x91\x90\x92\x95\x80`-\x14a]\xCEW`.\x14a]\x11WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[`@Q\x93``\x85\x01R\x85\x84R_Q` a_E_9_Q\x90_R` \x85\x01\x963\x88RF`@\x87\x01R\x14\x15\x80a]\xBFW[`\x05\x1B`\x80\x01\x84 \x90\x83\x01\x90`\xA0\x82\x015\x84\x01\x90`\xC0\x825`\x05\x1B\x93\x015`\x05\x1B_\x90_[\x85\x81\x10a]\x90WPPPPP``\x92`\xA0\x95\x96\x92`@\x92` \x01\x86 `\x80\x87\x01R\x85R\x01\x907 \x90V[\x80\x89\x01` \x84\x83\x01\x87\x01\x015\x81R\x82\x82\x14a]\xAFW[P` \x01a]fV[` \x90\x81\x01\x85\x90R\x92P\x82a]\xA6V[`\xA0\x84\x015`\x80\x86\x01Ra]AV[P``\x92`\xA0\x95\x96\x92\x86`@\x93\x84Q\x97\x87\x89\x01R\x85\x88R_Q` a_E_9_Q\x90_R` \x89\x01\x963\x88RF\x87\x8B\x01R\x14\x15\x80a^7W[`\x05\x1B`\x80\x01\x88 \x88R\x83\x01\x015\x82\x01\x805`\x05\x1B\x80\x91` \x01\x867` \x01\x86 `\x80\x87\x01R\x85R\x01\x907 \x90V[\x82\x85\x015`\x80\x8A\x01Ra^\x08V[\x96\x95\x94\x93\x92\x91\x90\x96\x80`'\x14a_1W\x80`$\x14a_\x1CW\x80`!\x14a_\x07W\x80`#\x14a^\xF7W\x80`\x1F\x14a^\xE2W\x80`&\x14a^\xCFW\x80`\"\x14a^\xC4W\x80`%\x14a^\xB1W`\x17\x14a^\xA8WcNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[aB\x99\x96aLJV[P\x90`\x17\x95\x94\x93\x92\x91\x87aB\x99\x98aR\xDFV[P\x86aB\x99\x97aB9V[P\x90`\x17\x95\x94\x93\x92\x91\x87aB\x99\x98aM&V[P\x91aB\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93aM&V[P\x90aB\x99\x96\x92\x916\x15\x93aB9V[P\x91aB\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93aQ\xA7V[P\x91aB\x99\x96\x91`\x17\x96\x95\x94\x936\x15\x93aR\xDFV[P\x90`\x17\x95\x94\x93\x92\x91\x87aB\x99\x98aQ\xA7V\xFE)_\xEB\tWg\xCCg\xD7\xE7F\x95\xDA\n\xDA\xDD\xED\xE5M{q\x94\xA8\xA5Bo\xE8\xF05\x1E\x037\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y\\\xA9\xA6k\x8B\xBF\r#\x16\xE9\r\xFA=\xF4e\xF0y\x0B'{%9:>\xF4\xD6~\x1FP\x86PW\xCD\xCA\x95\x0B\x17\xB5\xEF\xC0\x16\xB7K\x91-\x85'\xDF\xBA^@Jh\x8C\xBC=\xAB\x16\xCB\x942\x87\xFE\xC2Z\x7F\xEE\x80\0\xA27\x92\x9E\xF9\xBE\x08\xF2\x93<KO2\x0B\0\xB3\x88\t\xF3\xC7\xAA\x10MT!\x04\x9F\xA1dsolcC\0\x08\x1C\0\n",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CompactCategory(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<CompactCategory> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl CompactCategory {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for CompactCategory {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for CompactCategory {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ForcedWithdrawalStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ForcedWithdrawalStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl ForcedWithdrawalStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ForcedWithdrawalStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ForcedWithdrawalStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ResetPeriod(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ResetPeriod> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl ResetPeriod {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ResetPeriod {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ResetPeriod {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Scope(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Scope> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl Scope {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Scope {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Scope {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct BasicClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BasicClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BasicClaim> for UnderlyingRustTuple<'_> {
            fn from(value: BasicClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BasicClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    id: tuple.5,
                    allocatedAmount: tuple.6,
                    claimant: tuple.7,
                    amount: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BasicClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BasicClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BasicClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BasicClaim {
            const NAME: &'static str = "BasicClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BasicClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BasicClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BasicTransfer { bytes allocatorSignature; uint256 nonce; uint256 expires; uint256 id; uint256 amount; address recipient; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BasicTransfer {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        pub recipient: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BasicTransfer> for UnderlyingRustTuple<'_> {
            fn from(value: BasicTransfer) -> Self {
                (
                    value.allocatorSignature,
                    value.nonce,
                    value.expires,
                    value.id,
                    value.amount,
                    value.recipient,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BasicTransfer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    nonce: tuple.1,
                    expires: tuple.2,
                    id: tuple.3,
                    amount: tuple.4,
                    recipient: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BasicTransfer {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BasicTransfer {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BasicTransfer {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BasicTransfer {
            const NAME: &'static str = "BasicTransfer";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BasicTransfer(bytes allocatorSignature,uint256 nonce,uint256 expires,uint256 id,uint256 amount,address recipient)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.recipient,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BasicTransfer {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.recipient,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.recipient,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchClaim> for UnderlyingRustTuple<'_> {
            fn from(value: BatchClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    claims: tuple.5,
                    claimant: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchClaim {
            const NAME: &'static str = "BatchClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchClaimComponent { uint256 id; uint256 allocatedAmount; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchClaimComponent {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchClaimComponent> for UnderlyingRustTuple<'_> {
            fn from(value: BatchClaimComponent) -> Self {
                (value.id, value.allocatedAmount, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchClaimComponent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    id: tuple.0,
                    allocatedAmount: tuple.1,
                    amount: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchClaimComponent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchClaimComponent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchClaimComponent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchClaimComponent {
            const NAME: &'static str = "BatchClaimComponent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchClaimComponent(uint256 id,uint256 allocatedAmount,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchClaimComponent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchClaimWithWitness> for UnderlyingRustTuple<'_> {
            fn from(value: BatchClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    claims: tuple.7,
                    claimant: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchClaimWithWitness {
            const NAME: &'static str = "BatchClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchMultichainClaim> for UnderlyingRustTuple<'_> {
            fn from(value: BatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    claims: tuple.6,
                    claimant: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchMultichainClaim {
            const NAME: &'static str = "BatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: BatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for BatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    claims: tuple.8,
                    claimant: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for BatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchMultichainClaimWithWitness {
            const NAME: &'static str = "BatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BatchTransfer { bytes allocatorSignature; uint256 nonce; uint256 expires; TransferComponent[] transfers; address recipient; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BatchTransfer {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub transfers: alloy::sol_types::private::Vec<
            <TransferComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub recipient: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<TransferComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <TransferComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BatchTransfer> for UnderlyingRustTuple<'_> {
            fn from(value: BatchTransfer) -> Self {
                (
                    value.allocatorSignature,
                    value.nonce,
                    value.expires,
                    value.transfers,
                    value.recipient,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BatchTransfer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    nonce: tuple.1,
                    expires: tuple.2,
                    transfers: tuple.3,
                    recipient: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BatchTransfer {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BatchTransfer {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        TransferComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.transfers),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BatchTransfer {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BatchTransfer {
            const NAME: &'static str = "BatchTransfer";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BatchTransfer(bytes allocatorSignature,uint256 nonce,uint256 expires,TransferComponent[] transfers,address recipient)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <TransferComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <TransferComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        TransferComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.transfers)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.recipient,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BatchTransfer {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        TransferComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.transfers,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.recipient,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    TransferComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.transfers,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.recipient,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClaimWithWitness> for UnderlyingRustTuple<'_> {
            fn from(value: ClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    id: tuple.7,
                    allocatedAmount: tuple.8,
                    claimant: tuple.9,
                    amount: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ClaimWithWitness {
            const NAME: &'static str = "ClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    chainIndex: tuple.6,
                    notarizedChainId: tuple.7,
                    claims: tuple.8,
                    claimant: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousBatchMultichainClaim {
            const NAME: &'static str = "ExogenousBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    claims: tuple.10,
                    claimant: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousBatchMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    chainIndex: tuple.6,
                    notarizedChainId: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimant: tuple.10,
                    amount: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ExogenousMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousMultichainClaim {
            const NAME: &'static str = "ExogenousMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimant: tuple.12,
                    amount: tuple.13,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    claims: tuple.10,
                    claimant: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousQualifiedBatchMultichainClaim {
            const NAME: &'static str = "ExogenousQualifiedBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousQualifiedBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    chainIndex: tuple.10,
                    notarizedChainId: tuple.11,
                    claims: tuple.12,
                    claimant: tuple.13,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousQualifiedBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimant: tuple.12,
                    amount: tuple.13,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousQualifiedMultichainClaim {
            const NAME: &'static str = "ExogenousQualifiedMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousQualifiedMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    chainIndex: tuple.10,
                    notarizedChainId: tuple.11,
                    id: tuple.12,
                    allocatedAmount: tuple.13,
                    claimant: tuple.14,
                    amount: tuple.15,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousQualifiedMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousQualifiedMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedSplitBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedSplitBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedSplitBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedSplitBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedSplitBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    claims: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedSplitBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedSplitBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedSplitBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousQualifiedSplitBatchMultichainClaim {
            const NAME: &'static str = "ExogenousQualifiedSplitBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedSplitBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedSplitBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<
            ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
        > for UnderlyingRustTuple<'_> {
            fn from(
                value: ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            ) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    chainIndex: tuple.10,
                    notarizedChainId: tuple.11,
                    claims: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousQualifiedSplitBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedSplitBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedSplitMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedSplitMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedSplitMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedSplitMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedSplitMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimants: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousQualifiedSplitMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedSplitMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousQualifiedSplitMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousQualifiedSplitMultichainClaim {
            const NAME: &'static str = "ExogenousQualifiedSplitMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedSplitMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousQualifiedSplitMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousQualifiedSplitMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousQualifiedSplitMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousQualifiedSplitMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousQualifiedSplitMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    chainIndex: tuple.10,
                    notarizedChainId: tuple.11,
                    id: tuple.12,
                    allocatedAmount: tuple.13,
                    claimants: tuple.14,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousQualifiedSplitMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousQualifiedSplitMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousQualifiedSplitMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousSplitBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousSplitBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousSplitBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousSplitBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousSplitBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    chainIndex: tuple.6,
                    notarizedChainId: tuple.7,
                    claims: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousSplitBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousSplitBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousSplitBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousSplitBatchMultichainClaim {
            const NAME: &'static str = "ExogenousSplitBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousSplitBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousSplitBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousSplitBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousSplitBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousSplitBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousSplitBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousSplitBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    claims: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for ExogenousSplitBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousSplitBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for ExogenousSplitBatchMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousSplitBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousSplitBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for ExogenousSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousSplitMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousSplitMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousSplitMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousSplitMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousSplitMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    chainIndex: tuple.6,
                    notarizedChainId: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimants: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousSplitMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousSplitMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousSplitMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousSplitMultichainClaim {
            const NAME: &'static str = "ExogenousSplitMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousSplitMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousSplitMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ExogenousSplitMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 chainIndex; uint256 notarizedChainId; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExogenousSplitMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub chainIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub notarizedChainId: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExogenousSplitMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: ExogenousSplitMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.chainIndex,
                    value.notarizedChainId,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ExogenousSplitMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    chainIndex: tuple.8,
                    notarizedChainId: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimants: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ExogenousSplitMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for ExogenousSplitMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.notarizedChainId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ExogenousSplitMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ExogenousSplitMultichainClaimWithWitness {
            const NAME: &'static str = "ExogenousSplitMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ExogenousSplitMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 chainIndex,uint256 notarizedChainId,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainIndex)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.notarizedChainId,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ExogenousSplitMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.notarizedChainId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.notarizedChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct MultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MultichainClaim> for UnderlyingRustTuple<'_> {
            fn from(value: MultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    id: tuple.6,
                    allocatedAmount: tuple.7,
                    claimant: tuple.8,
                    amount: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for MultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for MultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for MultichainClaim {
            const NAME: &'static str = "MultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "MultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct MultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: MultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for MultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimant: tuple.10,
                    amount: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for MultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for MultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for MultichainClaimWithWitness {
            const NAME: &'static str = "MultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "MultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedBatchClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedBatchClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedBatchClaim> for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedBatchClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QualifiedBatchClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    claims: tuple.7,
                    claimant: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedBatchClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedBatchClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedBatchClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedBatchClaim {
            const NAME: &'static str = "QualifiedBatchClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedBatchClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedBatchClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedBatchClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedBatchClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedBatchClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedBatchClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedBatchClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    claims: tuple.9,
                    claimant: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedBatchClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedBatchClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedBatchClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedBatchClaimWithWitness {
            const NAME: &'static str = "QualifiedBatchClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedBatchClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedBatchClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    claims: tuple.8,
                    claimant: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedBatchMultichainClaim {
            const NAME: &'static str = "QualifiedBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; BatchClaimComponent[] claims; address claimant; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
        pub claimant: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<BatchClaimComponent>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <BatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.claims,
                    value.claimant,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    claims: tuple.10,
                    claimant: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedBatchMultichainClaimWithWitness {
            const NAME: &'static str = "QualifiedBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,BatchClaimComponent[] claims,address claimant)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <BatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        BatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    BatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedClaim> for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QualifiedClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    id: tuple.7,
                    allocatedAmount: tuple.8,
                    claimant: tuple.9,
                    amount: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedClaim {
            const NAME: &'static str = "QualifiedClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    id: tuple.9,
                    allocatedAmount: tuple.10,
                    claimant: tuple.11,
                    amount: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedClaimWithWitness {
            const NAME: &'static str = "QualifiedClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimant: tuple.10,
                    amount: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedMultichainClaim {
            const NAME: &'static str = "QualifiedMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimant,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimant: tuple.12,
                    amount: tuple.13,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedMultichainClaimWithWitness {
            const NAME: &'static str = "QualifiedMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitBatchClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitBatchClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitBatchClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitBatchClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitBatchClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    claims: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitBatchClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedSplitBatchClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitBatchClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitBatchClaim {
            const NAME: &'static str = "QualifiedSplitBatchClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitBatchClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitBatchClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitBatchClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitBatchClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitBatchClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitBatchClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitBatchClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    claims: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitBatchClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitBatchClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitBatchClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitBatchClaimWithWitness {
            const NAME: &'static str = "QualifiedSplitBatchClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitBatchClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitBatchClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    claims: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitBatchMultichainClaim {
            const NAME: &'static str = "QualifiedSplitBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    claims: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue
        for QualifiedSplitBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct
        for QualifiedSplitBatchMultichainClaimWithWitness {
            const NAME: &'static str = "QualifiedSplitBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic
        for QualifiedSplitBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitClaim> for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QualifiedSplitClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    id: tuple.7,
                    allocatedAmount: tuple.8,
                    claimants: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QualifiedSplitClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitClaim {
            const NAME: &'static str = "QualifiedSplitClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    id: tuple.9,
                    allocatedAmount: tuple.10,
                    claimants: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitClaimWithWitness {
            const NAME: &'static str = "QualifiedSplitClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    qualificationTypehash: tuple.5,
                    qualificationPayload: tuple.6,
                    additionalChains: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimants: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitMultichainClaim {
            const NAME: &'static str = "QualifiedSplitMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QualifiedSplitMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32 qualificationTypehash; bytes qualificationPayload; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QualifiedSplitMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub qualificationTypehash: alloy::sol_types::private::FixedBytes<32>,
        pub qualificationPayload: alloy::sol_types::private::Bytes,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QualifiedSplitMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: QualifiedSplitMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.qualificationTypehash,
                    value.qualificationPayload,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for QualifiedSplitMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    qualificationTypehash: tuple.7,
                    qualificationPayload: tuple.8,
                    additionalChains: tuple.9,
                    id: tuple.10,
                    allocatedAmount: tuple.11,
                    claimants: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QualifiedSplitMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for QualifiedSplitMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationTypehash,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.qualificationPayload,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QualifiedSplitMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QualifiedSplitMultichainClaimWithWitness {
            const NAME: &'static str = "QualifiedSplitMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QualifiedSplitMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32 qualificationTypehash,bytes qualificationPayload,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationTypehash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.qualificationPayload,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QualifiedSplitMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationTypehash,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.qualificationPayload,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationTypehash,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.qualificationPayload,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchClaim> for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitBatchClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    claims: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitBatchClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchClaim {
            const NAME: &'static str = "SplitBatchClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchClaimComponent { uint256 id; uint256 allocatedAmount; SplitComponent[] portions; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchClaimComponent {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub portions: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchClaimComponent>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchClaimComponent) -> Self {
                (value.id, value.allocatedAmount, value.portions)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitBatchClaimComponent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    id: tuple.0,
                    allocatedAmount: tuple.1,
                    portions: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchClaimComponent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitBatchClaimComponent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.portions),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchClaimComponent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchClaimComponent {
            const NAME: &'static str = "SplitBatchClaimComponent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchClaimComponent(uint256 id,uint256 allocatedAmount,SplitComponent[] portions)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.portions)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchClaimComponent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.portions,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.portions,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitBatchClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    claims: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for SplitBatchClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchClaimWithWitness {
            const NAME: &'static str = "SplitBatchClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchMultichainClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitBatchMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    claims: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitBatchMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchMultichainClaim {
            const NAME: &'static str = "SplitBatchMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; SplitBatchClaimComponent[] claims; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub claims: alloy::sol_types::private::Vec<
            <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Array<SplitBatchClaimComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Vec<
                <SplitBatchClaimComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.claims,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitBatchMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    claims: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for SplitBatchMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claims),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchMultichainClaimWithWitness {
            const NAME: &'static str = "SplitBatchMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,SplitBatchClaimComponent[] claims)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitBatchClaimComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claims)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitBatchClaimComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claims,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitBatchClaimComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claims,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitBatchTransfer { bytes allocatorSignature; uint256 nonce; uint256 expires; SplitByIdComponent[] transfers; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitBatchTransfer {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub transfers: alloy::sol_types::private::Vec<
            <SplitByIdComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitByIdComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitByIdComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitBatchTransfer> for UnderlyingRustTuple<'_> {
            fn from(value: SplitBatchTransfer) -> Self {
                (value.allocatorSignature, value.nonce, value.expires, value.transfers)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitBatchTransfer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    nonce: tuple.1,
                    expires: tuple.2,
                    transfers: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitBatchTransfer {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitBatchTransfer {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        SplitByIdComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.transfers),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitBatchTransfer {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitBatchTransfer {
            const NAME: &'static str = "SplitBatchTransfer";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitBatchTransfer(bytes allocatorSignature,uint256 nonce,uint256 expires,SplitByIdComponent[] transfers)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitByIdComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitByIdComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitByIdComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.transfers)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitBatchTransfer {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitByIdComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.transfers,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitByIdComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.transfers,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitByIdComponent { uint256 id; SplitComponent[] portions; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitByIdComponent {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub portions: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitByIdComponent> for UnderlyingRustTuple<'_> {
            fn from(value: SplitByIdComponent) -> Self {
                (value.id, value.portions)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitByIdComponent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    id: tuple.0,
                    portions: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitByIdComponent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitByIdComponent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.portions),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitByIdComponent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitByIdComponent {
            const NAME: &'static str = "SplitByIdComponent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitByIdComponent(uint256 id,SplitComponent[] portions)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.portions)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitByIdComponent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.portions,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.portions,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitClaim> for UnderlyingRustTuple<'_> {
            fn from(value: SplitClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    id: tuple.5,
                    allocatedAmount: tuple.6,
                    claimants: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitClaim {
            const NAME: &'static str = "SplitClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitClaimWithWitness> for UnderlyingRustTuple<'_> {
            fn from(value: SplitClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    id: tuple.7,
                    allocatedAmount: tuple.8,
                    claimants: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitClaimWithWitness {
            const NAME: &'static str = "SplitClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitComponent { address claimant; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitComponent {
        pub claimant: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitComponent> for UnderlyingRustTuple<'_> {
            fn from(value: SplitComponent) -> Self {
                (value.claimant, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitComponent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    claimant: tuple.0,
                    amount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitComponent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitComponent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.claimant,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitComponent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitComponent {
            const NAME: &'static str = "SplitComponent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitComponent(address claimant,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.claimant,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitComponent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimant,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimant,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitMultichainClaim { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitMultichainClaim {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitMultichainClaim> for UnderlyingRustTuple<'_> {
            fn from(value: SplitMultichainClaim) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitMultichainClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    additionalChains: tuple.5,
                    id: tuple.6,
                    allocatedAmount: tuple.7,
                    claimants: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitMultichainClaim {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitMultichainClaim {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitMultichainClaim {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitMultichainClaim {
            const NAME: &'static str = "SplitMultichainClaim";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitMultichainClaim(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitMultichainClaim {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitMultichainClaimWithWitness { bytes allocatorSignature; bytes sponsorSignature; address sponsor; uint256 nonce; uint256 expires; bytes32 witness; string witnessTypestring; bytes32[] additionalChains; uint256 id; uint256 allocatedAmount; SplitComponent[] claimants; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitMultichainClaimWithWitness {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub sponsorSignature: alloy::sol_types::private::Bytes,
        pub sponsor: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub witness: alloy::sol_types::private::FixedBytes<32>,
        pub witnessTypestring: alloy::sol_types::private::String,
        pub additionalChains: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimants: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::FixedBytes<32>,
            >,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::String,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitMultichainClaimWithWitness>
        for UnderlyingRustTuple<'_> {
            fn from(value: SplitMultichainClaimWithWitness) -> Self {
                (
                    value.allocatorSignature,
                    value.sponsorSignature,
                    value.sponsor,
                    value.nonce,
                    value.expires,
                    value.witness,
                    value.witnessTypestring,
                    value.additionalChains,
                    value.id,
                    value.allocatedAmount,
                    value.claimants,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SplitMultichainClaimWithWitness {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    sponsorSignature: tuple.1,
                    sponsor: tuple.2,
                    nonce: tuple.3,
                    expires: tuple.4,
                    witness: tuple.5,
                    witnessTypestring: tuple.6,
                    additionalChains: tuple.7,
                    id: tuple.8,
                    allocatedAmount: tuple.9,
                    claimants: tuple.10,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitMultichainClaimWithWitness {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self>
        for SplitMultichainClaimWithWitness {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sponsorSignature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witnessTypestring,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.additionalChains),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimants),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitMultichainClaimWithWitness {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitMultichainClaimWithWitness {
            const NAME: &'static str = "SplitMultichainClaimWithWitness";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitMultichainClaimWithWitness(bytes allocatorSignature,bytes sponsorSignature,address sponsor,uint256 nonce,uint256 expires,bytes32 witness,string witnessTypestring,bytes32[] additionalChains,uint256 id,uint256 allocatedAmount,SplitComponent[] claimants)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sponsor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.witness)
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.witnessTypestring,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.additionalChains,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatedAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.claimants)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitMultichainClaimWithWitness {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsorSignature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sponsor,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witness,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.witnessTypestring,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.additionalChains,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatedAmount,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.claimants,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sponsor,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witness,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.witnessTypestring,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.additionalChains,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatedAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.claimants,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SplitTransfer { bytes allocatorSignature; uint256 nonce; uint256 expires; uint256 id; SplitComponent[] recipients; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SplitTransfer {
        pub allocatorSignature: alloy::sol_types::private::Bytes,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub recipients: alloy::sol_types::private::Vec<
            <SplitComponent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Array<SplitComponent>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Vec<
                <SplitComponent as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SplitTransfer> for UnderlyingRustTuple<'_> {
            fn from(value: SplitTransfer) -> Self {
                (
                    value.allocatorSignature,
                    value.nonce,
                    value.expires,
                    value.id,
                    value.recipients,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SplitTransfer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatorSignature: tuple.0,
                    nonce: tuple.1,
                    expires: tuple.2,
                    id: tuple.3,
                    recipients: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SplitTransfer {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SplitTransfer {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.allocatorSignature,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::tokenize(&self.recipients),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SplitTransfer {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SplitTransfer {
            const NAME: &'static str = "SplitTransfer";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SplitTransfer(bytes allocatorSignature,uint256 nonce,uint256 expires,uint256 id,SplitComponent[] recipients)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <SplitComponent as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.allocatorSignature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expires)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.recipients)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SplitTransfer {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.allocatorSignature,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expires,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Array<
                        SplitComponent,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.recipients,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.allocatorSignature,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expires,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Array<
                    SplitComponent,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.recipients,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct TransferComponent { uint256 id; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TransferComponent {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TransferComponent> for UnderlyingRustTuple<'_> {
            fn from(value: TransferComponent) -> Self {
                (value.id, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TransferComponent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    id: tuple.0,
                    amount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for TransferComponent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for TransferComponent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for TransferComponent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for TransferComponent {
            const NAME: &'static str = "TransferComponent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "TransferComponent(uint256 id,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.id)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for TransferComponent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.id)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.id, out);
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `AllocatedAmountExceeded(uint256,uint256)` and selector `0x3078b2f6`.
```solidity
error AllocatedAmountExceeded(uint256 allocatedAmount, uint256 providedAmount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AllocatedAmountExceeded {
        pub allocatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub providedAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AllocatedAmountExceeded> for UnderlyingRustTuple<'_> {
            fn from(value: AllocatedAmountExceeded) -> Self {
                (value.allocatedAmount, value.providedAmount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AllocatedAmountExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    allocatedAmount: tuple.0,
                    providedAmount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AllocatedAmountExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AllocatedAmountExceeded(uint256,uint256)";
            const SELECTOR: [u8; 4] = [48u8, 120u8, 178u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatedAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.providedAmount),
                )
            }
        }
    };
    /**Custom error with signature `BalanceOverflow()` and selector `0x89560ca1`.
```solidity
error BalanceOverflow();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BalanceOverflow {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BalanceOverflow> for UnderlyingRustTuple<'_> {
            fn from(value: BalanceOverflow) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BalanceOverflow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BalanceOverflow {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BalanceOverflow()";
            const SELECTOR: [u8; 4] = [137u8, 86u8, 12u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `Expired(uint256)` and selector `0xf80dbaea`.
```solidity
error Expired(uint256 expiration);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Expired {
        pub expiration: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Expired> for UnderlyingRustTuple<'_> {
            fn from(value: Expired) -> Self {
                (value.expiration,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Expired {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { expiration: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Expired {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Expired(uint256)";
            const SELECTOR: [u8; 4] = [248u8, 13u8, 186u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiration),
                )
            }
        }
    };
    /**Custom error with signature `ForcedWithdrawalAlreadyDisabled(address,uint256)` and selector `0xe632dbad`.
```solidity
error ForcedWithdrawalAlreadyDisabled(address account, uint256 id);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ForcedWithdrawalAlreadyDisabled {
        pub account: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ForcedWithdrawalAlreadyDisabled>
        for UnderlyingRustTuple<'_> {
            fn from(value: ForcedWithdrawalAlreadyDisabled) -> Self {
                (value.account, value.id)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ForcedWithdrawalAlreadyDisabled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    id: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ForcedWithdrawalAlreadyDisabled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ForcedWithdrawalAlreadyDisabled(address,uint256)";
            const SELECTOR: [u8; 4] = [230u8, 50u8, 219u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientBalance()` and selector `0xf4d678b8`.
```solidity
error InsufficientBalance();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance()";
            const SELECTOR: [u8; 4] = [244u8, 214u8, 120u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientPermission()` and selector `0xdeda9030`.
```solidity
error InsufficientPermission();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientPermission {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientPermission> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientPermission) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientPermission {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientPermission {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientPermission()";
            const SELECTOR: [u8; 4] = [222u8, 218u8, 144u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidBatchAllocation()` and selector `0x3a03d3bb`.
```solidity
error InvalidBatchAllocation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidBatchAllocation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidBatchAllocation> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidBatchAllocation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidBatchAllocation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidBatchAllocation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidBatchAllocation()";
            const SELECTOR: [u8; 4] = [58u8, 3u8, 211u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidBatchDepositStructure()` and selector `0xca0fc08e`.
```solidity
error InvalidBatchDepositStructure();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidBatchDepositStructure {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidBatchDepositStructure>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidBatchDepositStructure) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidBatchDepositStructure {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidBatchDepositStructure {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidBatchDepositStructure()";
            const SELECTOR: [u8; 4] = [202u8, 15u8, 192u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidDepositBalanceChange()` and selector `0x426d8dcf`.
```solidity
error InvalidDepositBalanceChange();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDepositBalanceChange {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDepositBalanceChange>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDepositBalanceChange) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidDepositBalanceChange {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDepositBalanceChange {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDepositBalanceChange()";
            const SELECTOR: [u8; 4] = [66u8, 109u8, 141u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidDepositTokenOrdering()` and selector `0x0f2f1e51`.
```solidity
error InvalidDepositTokenOrdering();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDepositTokenOrdering {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDepositTokenOrdering>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDepositTokenOrdering) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidDepositTokenOrdering {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDepositTokenOrdering {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDepositTokenOrdering()";
            const SELECTOR: [u8; 4] = [15u8, 47u8, 30u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidRegistrationDuration(uint256)` and selector `0x1f9a96f4`.
```solidity
error InvalidRegistrationDuration(uint256 duration);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidRegistrationDuration {
        pub duration: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidRegistrationDuration>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidRegistrationDuration) -> Self {
                (value.duration,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidRegistrationDuration {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { duration: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidRegistrationDuration {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidRegistrationDuration(uint256)";
            const SELECTOR: [u8; 4] = [31u8, 154u8, 150u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
        }
    };
    /**Custom error with signature `InvalidRegistrationProof(address)` and selector `0x4e7f492b`.
```solidity
error InvalidRegistrationProof(address allocator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidRegistrationProof {
        pub allocator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidRegistrationProof>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidRegistrationProof) -> Self {
                (value.allocator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidRegistrationProof {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { allocator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidRegistrationProof {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidRegistrationProof(address)";
            const SELECTOR: [u8; 4] = [78u8, 127u8, 73u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `InvalidScope(uint256)` and selector `0xa06356f5`.
```solidity
error InvalidScope(uint256 id);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidScope {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidScope> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidScope) -> Self {
                (value.id,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidScope {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { id: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidScope {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidScope(uint256)";
            const SELECTOR: [u8; 4] = [160u8, 99u8, 86u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
        }
    };
    /**Custom error with signature `InvalidSignature()` and selector `0x8baa579f`.
```solidity
error InvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSignature()";
            const SELECTOR: [u8; 4] = [139u8, 170u8, 87u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidToken(address)` and selector `0x961c9a4f`.
```solidity
error InvalidToken(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidToken {
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidToken> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidToken) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidToken {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidToken {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidToken(address)";
            const SELECTOR: [u8; 4] = [150u8, 28u8, 154u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OnlyDirectCalls()` and selector `0x25994314`.
```solidity
error OnlyDirectCalls();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OnlyDirectCalls {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OnlyDirectCalls> for UnderlyingRustTuple<'_> {
            fn from(value: OnlyDirectCalls) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OnlyDirectCalls {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OnlyDirectCalls {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OnlyDirectCalls()";
            const SELECTOR: [u8; 4] = [37u8, 153u8, 67u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `Permit2CallFailed()` and selector `0x7f28c61e`.
```solidity
error Permit2CallFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Permit2CallFailed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Permit2CallFailed> for UnderlyingRustTuple<'_> {
            fn from(value: Permit2CallFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Permit2CallFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Permit2CallFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Permit2CallFailed()";
            const SELECTOR: [u8; 4] = [127u8, 40u8, 198u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `PrematureWithdrawal(uint256)` and selector `0x9287bcb0`.
```solidity
error PrematureWithdrawal(uint256 id);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PrematureWithdrawal {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PrematureWithdrawal> for UnderlyingRustTuple<'_> {
            fn from(value: PrematureWithdrawal) -> Self {
                (value.id,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PrematureWithdrawal {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { id: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PrematureWithdrawal {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PrematureWithdrawal(uint256)";
            const SELECTOR: [u8; 4] = [146u8, 135u8, 188u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
        }
    };
    /**Custom error with signature `ReentrantCall(address)` and selector `0xf57c448b`.
```solidity
error ReentrantCall(address existingCaller);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrantCall {
        pub existingCaller: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrantCall> for UnderlyingRustTuple<'_> {
            fn from(value: ReentrantCall) -> Self {
                (value.existingCaller,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { existingCaller: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrantCall(address)";
            const SELECTOR: [u8; 4] = [245u8, 124u8, 68u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.existingCaller,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `TStoreAlreadyActivated()` and selector `0xf45b98b0`.
```solidity
error TStoreAlreadyActivated();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TStoreAlreadyActivated {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TStoreAlreadyActivated> for UnderlyingRustTuple<'_> {
            fn from(value: TStoreAlreadyActivated) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TStoreAlreadyActivated {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TStoreAlreadyActivated {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TStoreAlreadyActivated()";
            const SELECTOR: [u8; 4] = [244u8, 91u8, 152u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TStoreNotSupported()` and selector `0x70a4078f`.
```solidity
error TStoreNotSupported();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TStoreNotSupported {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TStoreNotSupported> for UnderlyingRustTuple<'_> {
            fn from(value: TStoreNotSupported) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TStoreNotSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TStoreNotSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TStoreNotSupported()";
            const SELECTOR: [u8; 4] = [112u8, 164u8, 7u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TloadTestContractDeploymentFailed()` and selector `0x2aea5887`.
```solidity
error TloadTestContractDeploymentFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TloadTestContractDeploymentFailed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TloadTestContractDeploymentFailed>
        for UnderlyingRustTuple<'_> {
            fn from(value: TloadTestContractDeploymentFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for TloadTestContractDeploymentFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TloadTestContractDeploymentFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TloadTestContractDeploymentFailed()";
            const SELECTOR: [u8; 4] = [42u8, 234u8, 88u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnallocatedTransfer(address,address,address,uint256,uint256)` and selector `0x014c9310`.
```solidity
error UnallocatedTransfer(address operator, address from, address to, uint256 id, uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnallocatedTransfer {
        pub operator: alloy::sol_types::private::Address,
        pub from: alloy::sol_types::private::Address,
        pub to: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnallocatedTransfer> for UnderlyingRustTuple<'_> {
            fn from(value: UnallocatedTransfer) -> Self {
                (value.operator, value.from, value.to, value.id, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnallocatedTransfer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    from: tuple.1,
                    to: tuple.2,
                    id: tuple.3,
                    amount: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnallocatedTransfer {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnallocatedTransfer(address,address,address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [1u8, 76u8, 147u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
        }
    };
    /**Event with signature `AllocatorRegistered(uint96,address)` and selector `0xc54dcaa67a8fd7b4a9aa6fd57351934c792613d5ec1acbd65274270e6de8f7e4`.
```solidity
event AllocatorRegistered(uint96 allocatorId, address allocator);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AllocatorRegistered {
        #[allow(missing_docs)]
        pub allocatorId: alloy::sol_types::private::primitives::aliases::U96,
        #[allow(missing_docs)]
        pub allocator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AllocatorRegistered {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<96>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AllocatorRegistered(uint96,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                197u8,
                77u8,
                202u8,
                166u8,
                122u8,
                143u8,
                215u8,
                180u8,
                169u8,
                170u8,
                111u8,
                213u8,
                115u8,
                81u8,
                147u8,
                76u8,
                121u8,
                38u8,
                19u8,
                213u8,
                236u8,
                26u8,
                203u8,
                214u8,
                82u8,
                116u8,
                39u8,
                14u8,
                109u8,
                232u8,
                247u8,
                228u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    allocatorId: data.0,
                    allocator: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        96,
                    > as alloy_sol_types::SolType>::tokenize(&self.allocatorId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AllocatorRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AllocatorRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AllocatorRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256,uint256)` and selector `0xb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a7`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8,
                253u8,
                80u8,
                113u8,
                131u8,
                88u8,
                135u8,
                86u8,
                122u8,
                6u8,
                113u8,
                21u8,
                17u8,
                33u8,
                137u8,
                77u8,
                220u8,
                204u8,
                40u8,
                66u8,
                241u8,
                209u8,
                11u8,
                237u8,
                173u8,
                19u8,
                224u8,
                209u8,
                124u8,
                172u8,
                233u8,
                167u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    id: topics.3,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.owner.clone(),
                    self.spender.clone(),
                    self.id.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Claim(address,address,address,bytes32)` and selector `0x770c32a2314b700d6239ee35ba23a9690f2fceb93a55d8c753e953059b3b18d4`.
```solidity
event Claim(address indexed sponsor, address indexed allocator, address indexed arbiter, bytes32 claimHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Claim {
        #[allow(missing_docs)]
        pub sponsor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allocator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub arbiter: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub claimHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Claim {
            type DataTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Claim(address,address,address,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                119u8,
                12u8,
                50u8,
                162u8,
                49u8,
                75u8,
                112u8,
                13u8,
                98u8,
                57u8,
                238u8,
                53u8,
                186u8,
                35u8,
                169u8,
                105u8,
                15u8,
                47u8,
                206u8,
                185u8,
                58u8,
                85u8,
                216u8,
                199u8,
                83u8,
                233u8,
                83u8,
                5u8,
                155u8,
                59u8,
                24u8,
                212u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    sponsor: topics.1,
                    allocator: topics.2,
                    arbiter: topics.3,
                    claimHash: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.sponsor.clone(),
                    self.allocator.clone(),
                    self.arbiter.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sponsor,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.allocator,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.arbiter,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Claim {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Claim> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Claim) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CompactRegistered(address,bytes32,bytes32,uint256)` and selector `0xf78a2f33ff80ef4391f7449c748dc2d577a62cd645108f4f4069f4a7e0635b6a`.
```solidity
event CompactRegistered(address indexed sponsor, bytes32 claimHash, bytes32 typehash, uint256 expires);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CompactRegistered {
        #[allow(missing_docs)]
        pub sponsor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub claimHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub typehash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CompactRegistered {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "CompactRegistered(address,bytes32,bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                247u8,
                138u8,
                47u8,
                51u8,
                255u8,
                128u8,
                239u8,
                67u8,
                145u8,
                247u8,
                68u8,
                156u8,
                116u8,
                141u8,
                194u8,
                213u8,
                119u8,
                166u8,
                44u8,
                214u8,
                69u8,
                16u8,
                143u8,
                79u8,
                64u8,
                105u8,
                244u8,
                167u8,
                224u8,
                99u8,
                91u8,
                106u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    sponsor: topics.1,
                    claimHash: data.0,
                    typehash: data.1,
                    expires: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.typehash),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expires),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.sponsor.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sponsor,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CompactRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CompactRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CompactRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ForcedWithdrawalStatusUpdated(address,uint256,bool,uint256)` and selector `0xe27f5e0382cf5347965fc81d5c81cd141897fe9ce402d22c496b7c2ddc84e5fd`.
```solidity
event ForcedWithdrawalStatusUpdated(address indexed account, uint256 indexed id, bool activating, uint256 withdrawableAt);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ForcedWithdrawalStatusUpdated {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub activating: bool,
        #[allow(missing_docs)]
        pub withdrawableAt: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ForcedWithdrawalStatusUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "ForcedWithdrawalStatusUpdated(address,uint256,bool,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                226u8,
                127u8,
                94u8,
                3u8,
                130u8,
                207u8,
                83u8,
                71u8,
                150u8,
                95u8,
                200u8,
                29u8,
                92u8,
                129u8,
                205u8,
                20u8,
                24u8,
                151u8,
                254u8,
                156u8,
                228u8,
                2u8,
                210u8,
                44u8,
                73u8,
                107u8,
                124u8,
                45u8,
                220u8,
                132u8,
                229u8,
                253u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    id: topics.2,
                    activating: data.0,
                    withdrawableAt: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.activating,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.withdrawableAt),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone(), self.id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ForcedWithdrawalStatusUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ForcedWithdrawalStatusUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ForcedWithdrawalStatusUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorSet(address,address,bool)` and selector `0xceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa267`.
```solidity
event OperatorSet(address indexed owner, address indexed operator, bool approved);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorSet {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorSet(address,address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                206u8,
                181u8,
                118u8,
                217u8,
                241u8,
                94u8,
                78u8,
                32u8,
                15u8,
                219u8,
                80u8,
                150u8,
                214u8,
                77u8,
                93u8,
                253u8,
                102u8,
                126u8,
                22u8,
                222u8,
                242u8,
                12u8,
                30u8,
                239u8,
                209u8,
                66u8,
                86u8,
                216u8,
                227u8,
                250u8,
                162u8,
                103u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    operator: topics.2,
                    approved: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,address,uint256,uint256)` and selector `0x1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859`.
```solidity
event Transfer(address by, address indexed from, address indexed to, uint256 indexed id, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub by: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                27u8,
                61u8,
                126u8,
                219u8,
                46u8,
                156u8,
                11u8,
                14u8,
                124u8,
                82u8,
                91u8,
                32u8,
                170u8,
                174u8,
                240u8,
                245u8,
                148u8,
                13u8,
                46u8,
                215u8,
                22u8,
                99u8,
                199u8,
                211u8,
                146u8,
                102u8,
                236u8,
                175u8,
                172u8,
                114u8,
                136u8,
                89u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    by: data.0,
                    from: topics.1,
                    to: topics.2,
                    id: topics.3,
                    amount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.by,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.from.clone(),
                    self.to.clone(),
                    self.id.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORCall {}
    ///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DOMAIN_SEPARATORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
            const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `__activateTstore()` and selector `0x7423eb3c`.
```solidity
function __activateTstore() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct __activateTstoreCall {}
    ///Container type for the return parameters of the [`__activateTstore()`](__activateTstoreCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct __activateTstoreReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<__activateTstoreCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: __activateTstoreCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for __activateTstoreCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<__activateTstoreReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: __activateTstoreReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for __activateTstoreReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for __activateTstoreCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = __activateTstoreReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "__activateTstore()";
            const SELECTOR: [u8; 4] = [116u8, 35u8, 235u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `__registerAllocator(address,bytes)` and selector `0x2a9c4d0d`.
```solidity
function __registerAllocator(address allocator, bytes memory proof) external returns (uint96);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct __registerAllocatorCall {
        pub allocator: alloy::sol_types::private::Address,
        pub proof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`__registerAllocator(address,bytes)`](__registerAllocatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct __registerAllocatorReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U96,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<__registerAllocatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: __registerAllocatorCall) -> Self {
                    (value.allocator, value.proof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for __registerAllocatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        allocator: tuple.0,
                        proof: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U96,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<__registerAllocatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: __registerAllocatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for __registerAllocatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for __registerAllocatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = __registerAllocatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<96>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "__registerAllocator(address,bytes)";
            const SELECTOR: [u8; 4] = [42u8, 156u8, 77u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.proof,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocatedTransfer((bytes,uint256,uint256,(uint256,uint256)[],address))` and selector `0x200f0c4d`.
```solidity
function allocatedTransfer(BatchTransfer memory transfer) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedTransfer_0Call {
        pub transfer: <BatchTransfer as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`allocatedTransfer((bytes,uint256,uint256,(uint256,uint256)[],address))`](allocatedTransfer_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedTransfer_0Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchTransfer,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchTransfer as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedTransfer_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedTransfer_0Call) -> Self {
                    (value.transfer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedTransfer_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { transfer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedTransfer_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedTransfer_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedTransfer_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocatedTransfer_0Call {
            type Parameters<'a> = (BatchTransfer,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocatedTransfer_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocatedTransfer((bytes,uint256,uint256,(uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [32u8, 15u8, 12u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BatchTransfer as alloy_sol_types::SolType>::tokenize(&self.transfer),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocatedTransfer((bytes,uint256,uint256,(uint256,(address,uint256)[])[]))` and selector `0x7112406d`.
```solidity
function allocatedTransfer(SplitBatchTransfer memory transfer) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedTransfer_1Call {
        pub transfer: <SplitBatchTransfer as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`allocatedTransfer((bytes,uint256,uint256,(uint256,(address,uint256)[])[]))`](allocatedTransfer_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedTransfer_1Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchTransfer,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchTransfer as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedTransfer_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedTransfer_1Call) -> Self {
                    (value.transfer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedTransfer_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { transfer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedTransfer_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedTransfer_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedTransfer_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocatedTransfer_1Call {
            type Parameters<'a> = (SplitBatchTransfer,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocatedTransfer_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocatedTransfer((bytes,uint256,uint256,(uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [113u8, 18u8, 64u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchTransfer as alloy_sol_types::SolType>::tokenize(
                        &self.transfer,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocatedTransfer((bytes,uint256,uint256,uint256,(address,uint256)[]))` and selector `0xa2394147`.
```solidity
function allocatedTransfer(SplitTransfer memory transfer) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedTransfer_2Call {
        pub transfer: <SplitTransfer as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`allocatedTransfer((bytes,uint256,uint256,uint256,(address,uint256)[]))`](allocatedTransfer_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedTransfer_2Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitTransfer,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitTransfer as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedTransfer_2Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedTransfer_2Call) -> Self {
                    (value.transfer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedTransfer_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { transfer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedTransfer_2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedTransfer_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedTransfer_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocatedTransfer_2Call {
            type Parameters<'a> = (SplitTransfer,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocatedTransfer_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocatedTransfer((bytes,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [162u8, 57u8, 65u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<SplitTransfer as alloy_sol_types::SolType>::tokenize(&self.transfer),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocatedTransfer((bytes,uint256,uint256,uint256,uint256,address))` and selector `0xdd589cfc`.
```solidity
function allocatedTransfer(BasicTransfer memory transfer) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedTransfer_3Call {
        pub transfer: <BasicTransfer as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`allocatedTransfer((bytes,uint256,uint256,uint256,uint256,address))`](allocatedTransfer_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedTransfer_3Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BasicTransfer,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BasicTransfer as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedTransfer_3Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedTransfer_3Call) -> Self {
                    (value.transfer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedTransfer_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { transfer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedTransfer_3Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedTransfer_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedTransfer_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocatedTransfer_3Call {
            type Parameters<'a> = (BasicTransfer,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocatedTransfer_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocatedTransfer((bytes,uint256,uint256,uint256,uint256,address))";
            const SELECTOR: [u8; 4] = [221u8, 88u8, 156u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BasicTransfer as alloy_sol_types::SolType>::tokenize(&self.transfer),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocatedWithdrawal((bytes,uint256,uint256,uint256,uint256,address))` and selector `0x27c777a9`.
```solidity
function allocatedWithdrawal(BasicTransfer memory withdrawal) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedWithdrawal_0Call {
        pub withdrawal: <BasicTransfer as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`allocatedWithdrawal((bytes,uint256,uint256,uint256,uint256,address))`](allocatedWithdrawal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedWithdrawal_0Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BasicTransfer,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BasicTransfer as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedWithdrawal_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedWithdrawal_0Call) -> Self {
                    (value.withdrawal,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedWithdrawal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawal: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedWithdrawal_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedWithdrawal_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedWithdrawal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocatedWithdrawal_0Call {
            type Parameters<'a> = (BasicTransfer,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocatedWithdrawal_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocatedWithdrawal((bytes,uint256,uint256,uint256,uint256,address))";
            const SELECTOR: [u8; 4] = [39u8, 199u8, 119u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BasicTransfer as alloy_sol_types::SolType>::tokenize(
                        &self.withdrawal,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocatedWithdrawal((bytes,uint256,uint256,(uint256,(address,uint256)[])[]))` and selector `0x393c33e2`.
```solidity
function allocatedWithdrawal(SplitBatchTransfer memory withdrawal) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedWithdrawal_1Call {
        pub withdrawal: <SplitBatchTransfer as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`allocatedWithdrawal((bytes,uint256,uint256,(uint256,(address,uint256)[])[]))`](allocatedWithdrawal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedWithdrawal_1Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchTransfer,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchTransfer as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedWithdrawal_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedWithdrawal_1Call) -> Self {
                    (value.withdrawal,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedWithdrawal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawal: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedWithdrawal_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedWithdrawal_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedWithdrawal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocatedWithdrawal_1Call {
            type Parameters<'a> = (SplitBatchTransfer,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocatedWithdrawal_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocatedWithdrawal((bytes,uint256,uint256,(uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [57u8, 60u8, 51u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchTransfer as alloy_sol_types::SolType>::tokenize(
                        &self.withdrawal,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocatedWithdrawal((bytes,uint256,uint256,(uint256,uint256)[],address))` and selector `0x6a9a4c44`.
```solidity
function allocatedWithdrawal(BatchTransfer memory withdrawal) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedWithdrawal_2Call {
        pub withdrawal: <BatchTransfer as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`allocatedWithdrawal((bytes,uint256,uint256,(uint256,uint256)[],address))`](allocatedWithdrawal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedWithdrawal_2Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchTransfer,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchTransfer as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedWithdrawal_2Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedWithdrawal_2Call) -> Self {
                    (value.withdrawal,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedWithdrawal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawal: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedWithdrawal_2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedWithdrawal_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedWithdrawal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocatedWithdrawal_2Call {
            type Parameters<'a> = (BatchTransfer,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocatedWithdrawal_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocatedWithdrawal((bytes,uint256,uint256,(uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [106u8, 154u8, 76u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchTransfer as alloy_sol_types::SolType>::tokenize(
                        &self.withdrawal,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocatedWithdrawal((bytes,uint256,uint256,uint256,(address,uint256)[]))` and selector `0xfdc060e7`.
```solidity
function allocatedWithdrawal(SplitTransfer memory withdrawal) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedWithdrawal_3Call {
        pub withdrawal: <SplitTransfer as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`allocatedWithdrawal((bytes,uint256,uint256,uint256,(address,uint256)[]))`](allocatedWithdrawal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocatedWithdrawal_3Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitTransfer,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitTransfer as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedWithdrawal_3Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedWithdrawal_3Call) -> Self {
                    (value.withdrawal,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedWithdrawal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { withdrawal: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocatedWithdrawal_3Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocatedWithdrawal_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocatedWithdrawal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocatedWithdrawal_3Call {
            type Parameters<'a> = (SplitTransfer,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocatedWithdrawal_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocatedWithdrawal((bytes,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [253u8, 192u8, 96u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitTransfer as alloy_sol_types::SolType>::tokenize(
                        &self.withdrawal,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address,uint256)` and selector `0x598af9e7`.
```solidity
function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceCall {
        pub owner: alloy::sol_types::private::Address,
        pub spender: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`allowance(address,address,uint256)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender, value.id)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        id: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address,uint256)";
            const SELECTOR: [u8; 4] = [89u8, 138u8, 249u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256,uint256)` and selector `0x426a8493`.
```solidity
function approve(address spender, uint256 id, uint256 amount) external payable returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        pub spender: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [66u8, 106u8, 132u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address,uint256)` and selector `0x00fdd58e`.
```solidity
function balanceOf(address owner, uint256 id) external view returns (uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        pub owner: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`balanceOf(address,uint256)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.owner, value.id)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        id: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address,uint256)";
            const SELECTOR: [u8; 4] = [0u8, 253u8, 213u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x06659b7f`.
```solidity
function claim(ExogenousSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_0Call {
        pub claimPayload: <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_0Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_0Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_0Call {
            type Parameters<'a> = (ExogenousSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [6u8, 101u8, 155u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))` and selector `0x0d57fec9`.
```solidity
function claim(QualifiedClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_1Call {
        pub claimPayload: <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))`](claim_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_1Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_1Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_1Call {
            type Parameters<'a> = (QualifiedClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [13u8, 87u8, 254u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x107d4ee4`.
```solidity
function claim(QualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_2Call {
        pub claimPayload: <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))`](claim_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_2Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_2Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_2Call {
            type Parameters<'a> = (QualifiedBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [16u8, 125u8, 78u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x12a1e6ea`.
```solidity
function claim(QualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_3Call {
        pub claimPayload: <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claim_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_3Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                QualifiedSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_3Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_3Call {
            type Parameters<'a> = (QualifiedSplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [18u8, 161u8, 230u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))` and selector `0x12f9d21e`.
```solidity
function claim(QualifiedMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_4Call {
        pub claimPayload: <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))`](claim_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_4Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_4Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_4Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_4Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_4Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_4Call {
            type Parameters<'a> = (QualifiedMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [18u8, 249u8, 210u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x176f405a`.
```solidity
function claim(ExogenousQualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_5Call {
        pub claimPayload: <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_5Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_5Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_5Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_5Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_5Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_5Call {
            type Parameters<'a> = (ExogenousQualifiedBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_5Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [23u8, 111u8, 64u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))` and selector `0x1d474b14`.
```solidity
function claim(QualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_6Call {
        pub claimPayload: <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))`](claim_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_6Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_6Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_6Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_6Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_6Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_6Call {
            type Parameters<'a> = (QualifiedMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_6Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [29u8, 71u8, 75u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x2c4bbd17`.
```solidity
function claim(ExogenousQualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_7Call {
        pub claimPayload: <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_7Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_7Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_7Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_7Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_7Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_7Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_7Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_7Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_7Call {
            type Parameters<'a> = (
                ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_7Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [44u8, 75u8, 189u8, 23u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x32e2a803`.
```solidity
function claim(ExogenousMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_8Call {
        pub claimPayload: <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claim_8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_8Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_8Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_8Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_8Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_8Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_8Call {
            type Parameters<'a> = (ExogenousMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_8Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [50u8, 226u8, 168u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x409b3a7e`.
```solidity
function claim(ExogenousSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_9Call {
        pub claimPayload: <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_9Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_9Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_9Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_9Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_9Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_9Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_9Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_9Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_9Call {
            type Parameters<'a> = (ExogenousSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_9Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [64u8, 155u8, 58u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0x414fd914`.
```solidity
function claim(QualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_10Call {
        pub claimPayload: <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))`](claim_10Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_10Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_10Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_10Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_10Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_10Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_10Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_10Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_10Call {
            type Parameters<'a> = (QualifiedSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_10Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [65u8, 79u8, 217u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))` and selector `0x44b97d78`.
```solidity
function claim(ClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_11Call {
        pub claimPayload: <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))`](claim_11Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_11Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_11Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_11Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_11Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_11Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_11Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_11Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_11Call {
            type Parameters<'a> = (ClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_11Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [68u8, 185u8, 125u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x4c102416`.
```solidity
function claim(ExogenousQualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_12Call {
        pub claimPayload: <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_12Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_12Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_12Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_12Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_12Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_12Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_12Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_12Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_12Call {
            type Parameters<'a> = (ExogenousQualifiedSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_12Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [76u8, 16u8, 36u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x4d585fbf`.
```solidity
function claim(ExogenousQualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_13Call {
        pub claimPayload: <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_13Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_13Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedSplitMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_13Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_13Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_13Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_13Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_13Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_13Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_13Call {
            type Parameters<'a> = (ExogenousQualifiedSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_13Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [77u8, 88u8, 95u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x577cdc64`.
```solidity
function claim(SplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_14Call {
        pub claimPayload: <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claim_14Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_14Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_14Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_14Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_14Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_14Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_14Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_14Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_14Call {
            type Parameters<'a> = (SplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_14Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [87u8, 124u8, 220u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x59202128`.
```solidity
function claim(BatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_15Call {
        pub claimPayload: <BatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_15Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_15Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_15Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_15Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_15Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_15Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_15Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_15Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_15Call {
            type Parameters<'a> = (BatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_15Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [89u8, 32u8, 33u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BatchClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x5ac2ccf1`.
```solidity
function claim(ExogenousQualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_16Call {
        pub claimPayload: <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_16Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_16Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_16Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_16Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_16Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_16Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_16Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_16Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_16Call {
            type Parameters<'a> = (ExogenousQualifiedBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_16Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [90u8, 194u8, 204u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x5e6c91ff`.
```solidity
function claim(ExogenousMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_17Call {
        pub claimPayload: <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claim_17Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_17Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_17Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_17Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_17Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_17Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_17Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_17Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_17Call {
            type Parameters<'a> = (ExogenousMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_17Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [94u8, 108u8, 145u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))` and selector `0x63f5b1ad`.
```solidity
function claim(QualifiedClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_18Call {
        pub claimPayload: <QualifiedClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))`](claim_18Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_18Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_18Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_18Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_18Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_18Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_18Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_18Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_18Call {
            type Parameters<'a> = (QualifiedClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_18Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [99u8, 245u8, 177u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x6af2791b`.
```solidity
function claim(ExogenousQualifiedMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_19Call {
        pub claimPayload: <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claim_19Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_19Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_19Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_19Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_19Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_19Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_19Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_19Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_19Call {
            type Parameters<'a> = (ExogenousQualifiedMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_19Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [106u8, 242u8, 121u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))` and selector `0x86785559`.
```solidity
function claim(BasicClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_20Call {
        pub claimPayload: <BasicClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))`](claim_20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_20Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BasicClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BasicClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_20Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_20Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_20Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_20Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_20Call {
            type Parameters<'a> = (BasicClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_20Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [134u8, 120u8, 85u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BasicClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x935ed2ba`.
```solidity
function claim(SplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_21Call {
        pub claimPayload: <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claim_21Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_21Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_21Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_21Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_21Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_21Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_21Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_21Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_21Call {
            type Parameters<'a> = (SplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_21Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [147u8, 94u8, 210u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x9730f4fd`.
```solidity
function claim(BatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_22Call {
        pub claimPayload: <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))`](claim_22Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_22Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_22Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_22Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_22Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_22Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_22Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_22Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_22Call {
            type Parameters<'a> = (BatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_22Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [151u8, 48u8, 244u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))` and selector `0x996d3aac`.
```solidity
function claim(SplitClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_23Call {
        pub claimPayload: <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))`](claim_23Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_23Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_23Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_23Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_23Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_23Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_23Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_23Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_23Call {
            type Parameters<'a> = (SplitClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_23Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [153u8, 109u8, 58u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x9be5f537`.
```solidity
function claim(BatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_24Call {
        pub claimPayload: <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))`](claim_24Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_24Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_24Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_24Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_24Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_24Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_24Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_24Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_24Call {
            type Parameters<'a> = (BatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_24Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [155u8, 229u8, 245u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0xa4c7bd93`.
```solidity
function claim(ExogenousSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_25Call {
        pub claimPayload: <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_25Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_25Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_25Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_25Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_25Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_25Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_25Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_25Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_25Call {
            type Parameters<'a> = (ExogenousSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_25Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [164u8, 199u8, 189u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0xaa41c87e`.
```solidity
function claim(ExogenousSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_26Call {
        pub claimPayload: <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_26Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_26Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_26Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_26Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_26Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_26Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_26Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_26Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_26Call {
            type Parameters<'a> = (ExogenousSplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_26Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [170u8, 65u8, 200u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))` and selector `0xb24849b7`.
```solidity
function claim(QualifiedBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_27Call {
        pub claimPayload: <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))`](claim_27Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_27Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_27Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_27Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_27Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_27Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_27Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_27Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_27Call {
            type Parameters<'a> = (QualifiedBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_27Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [178u8, 72u8, 73u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0xb3244389`.
```solidity
function claim(QualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_28Call {
        pub claimPayload: <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))`](claim_28Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_28Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_28Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_28Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_28Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_28Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_28Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_28Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_28Call {
            type Parameters<'a> = (QualifiedBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_28Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [179u8, 36u8, 67u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))` and selector `0xb4039fc2`.
```solidity
function claim(QualifiedSplitClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_29Call {
        pub claimPayload: <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))`](claim_29Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_29Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_29Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_29Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_29Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_29Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_29Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_29Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_29Call {
            type Parameters<'a> = (QualifiedSplitClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_29Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [180u8, 3u8, 159u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))` and selector `0xb54baefd`.
```solidity
function claim(BatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_30Call {
        pub claimPayload: <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))`](claim_30Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_30Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_30Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_30Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_30Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_30Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_30Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_30Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_30Call {
            type Parameters<'a> = (BatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_30Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [181u8, 75u8, 174u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xb7ace047`.
```solidity
function claim(SplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_31Call {
        pub claimPayload: <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))`](claim_31Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_31Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_31Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_31Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_31Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_31Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_31Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_31Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_31Call {
            type Parameters<'a> = (SplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_31Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [183u8, 172u8, 224u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0xb8a5bbad`.
```solidity
function claim(SplitClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_32Call {
        pub claimPayload: <SplitClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))`](claim_32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_32Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_32Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_32Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_32Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_32Call {
            type Parameters<'a> = (SplitClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [184u8, 165u8, 187u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<SplitClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0xd204f11e`.
```solidity
function claim(SplitBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_33Call {
        pub claimPayload: <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_33Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_33Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_33Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_33Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_33Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_33Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_33Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_33Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_33Call {
            type Parameters<'a> = (SplitBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_33Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [210u8, 4u8, 241u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))` and selector `0xd34ddc82`.
```solidity
function claim(SplitBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_34Call {
        pub claimPayload: <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))`](claim_34Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_34Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_34Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_34Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_34Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_34Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_34Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_34Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_34Call {
            type Parameters<'a> = (SplitBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_34Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [211u8, 77u8, 220u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xd350188c`.
```solidity
function claim(QualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_35Call {
        pub claimPayload: <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))`](claim_35Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_35Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_35Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_35Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_35Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_35Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_35Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_35Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_35Call {
            type Parameters<'a> = (QualifiedSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_35Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [211u8, 80u8, 24u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))` and selector `0xdb04bc72`.
```solidity
function claim(QualifiedBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_36Call {
        pub claimPayload: <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))`](claim_36Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_36Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_36Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_36Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_36Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_36Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_36Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_36Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_36Call {
            type Parameters<'a> = (QualifiedBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_36Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [219u8, 4u8, 188u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))` and selector `0xe0565c49`.
```solidity
function claim(MultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_37Call {
        pub claimPayload: <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))`](claim_37Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_37Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_37Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_37Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_37Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_37Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_37Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_37Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_37Call {
            type Parameters<'a> = (MultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_37Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [224u8, 86u8, 92u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <MultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))` and selector `0xe6c5b654`.
```solidity
function claim(MultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_38Call {
        pub claimPayload: <MultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))`](claim_38Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_38Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_38Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_38Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_38Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_38Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_38Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_38Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_38Call {
            type Parameters<'a> = (MultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_38Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [230u8, 197u8, 182u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <MultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))` and selector `0xe8672f93`.
```solidity
function claim(QualifiedSplitClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_39Call {
        pub claimPayload: <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))`](claim_39Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_39Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_39Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_39Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_39Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_39Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_39Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_39Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_39Call {
            type Parameters<'a> = (QualifiedSplitClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_39Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [232u8, 103u8, 47u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0xea14532e`.
```solidity
function claim(ExogenousQualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_40Call {
        pub claimPayload: <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claim_40Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_40Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_40Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_40Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_40Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_40Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_40Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_40Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_40Call {
            type Parameters<'a> = (ExogenousQualifiedSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_40Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [234u8, 20u8, 83u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))` and selector `0xeaa67483`.
```solidity
function claim(QualifiedSplitBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_41Call {
        pub claimPayload: <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))`](claim_41Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_41Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_41Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_41Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_41Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_41Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_41Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_41Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_41Call {
            type Parameters<'a> = (QualifiedSplitBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_41Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [234u8, 166u8, 116u8, 131u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))` and selector `0xeb431821`.
```solidity
function claim(QualifiedSplitBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_42Call {
        pub claimPayload: <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))`](claim_42Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_42Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_42Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_42Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_42Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_42Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_42Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_42Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_42Call {
            type Parameters<'a> = (QualifiedSplitBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_42Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [235u8, 67u8, 24u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0xebcbd7b5`.
```solidity
function claim(ExogenousQualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_43Call {
        pub claimPayload: <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claim_43Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_43Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_43Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_43Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_43Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_43Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_43Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_43Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_43Call {
            type Parameters<'a> = (ExogenousQualifiedMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_43Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [235u8, 203u8, 215u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0xeed634ad`.
```solidity
function claim(ExogenousBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_44Call {
        pub claimPayload: <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_44Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_44Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_44Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_44Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_44Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_44Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_44Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_44Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_44Call {
            type Parameters<'a> = (ExogenousBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_44Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [238u8, 214u8, 52u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xf745381c`.
```solidity
function claim(SplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_45Call {
        pub claimPayload: <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))`](claim_45Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_45Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_45Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_45Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_45Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_45Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_45Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_45Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_45Call {
            type Parameters<'a> = (SplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_45Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [247u8, 69u8, 56u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0xfa1c5500`.
```solidity
function claim(ExogenousBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_46Call {
        pub claimPayload: <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claim_46Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_46Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_46Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_46Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_46Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_46Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_46Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_46Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_46Call {
            type Parameters<'a> = (ExogenousBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_46Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [250u8, 28u8, 85u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0xfb75fb69`.
```solidity
function claim(QualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_47Call {
        pub claimPayload: <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claim_47Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claim_47Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_47Call> for UnderlyingRustTuple<'_> {
                fn from(value: claim_47Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_47Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claim_47Return> for UnderlyingRustTuple<'_> {
                fn from(value: claim_47Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claim_47Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claim_47Call {
            type Parameters<'a> = (QualifiedSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claim_47Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claim((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [251u8, 117u8, 251u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x03417d72`.
```solidity
function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_0Call {
        pub claimPayload: <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_0Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_0Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_0Call {
            type Parameters<'a> = (ExogenousQualifiedBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [3u8, 65u8, 125u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))` and selector `0x06e8cc18`.
```solidity
function claimAndWithdraw(QualifiedSplitClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_1Call {
        pub claimPayload: <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_1Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_1Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_1Call {
            type Parameters<'a> = (QualifiedSplitClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [6u8, 232u8, 204u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))` and selector `0x08e600ee`.
```solidity
function claimAndWithdraw(QualifiedSplitBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_2Call {
        pub claimPayload: <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_2Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_2Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_2Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_2Call {
            type Parameters<'a> = (QualifiedSplitBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [8u8, 230u8, 0u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x0a133cf2`.
```solidity
function claimAndWithdraw(QualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_3Call {
        pub claimPayload: <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_3Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_3Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_3Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_3Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_3Call {
            type Parameters<'a> = (QualifiedSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [10u8, 19u8, 60u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x0f5eeadf`.
```solidity
function claimAndWithdraw(QualifiedBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_4Call {
        pub claimPayload: <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))`](claimAndWithdraw_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_4Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_4Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_4Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_4Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_4Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_4Call {
            type Parameters<'a> = (QualifiedBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [15u8, 94u8, 234u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))` and selector `0x13589bfe`.
```solidity
function claimAndWithdraw(QualifiedSplitBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_5Call {
        pub claimPayload: <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_5Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_5Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_5Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_5Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_5Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_5Call {
            type Parameters<'a> = (QualifiedSplitBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_5Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [19u8, 88u8, 155u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))` and selector `0x138cd819`.
```solidity
function claimAndWithdraw(QualifiedClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_6Call {
        pub claimPayload: <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))`](claimAndWithdraw_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_6Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_6Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_6Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_6Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_6Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_6Call {
            type Parameters<'a> = (QualifiedClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_6Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [19u8, 140u8, 216u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0x14865907`.
```solidity
function claimAndWithdraw(QualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_7Call {
        pub claimPayload: <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))`](claimAndWithdraw_7Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_7Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_7Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_7Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_7Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_7Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_7Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_7Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_7Call {
            type Parameters<'a> = (QualifiedBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_7Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [20u8, 134u8, 89u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))` and selector `0x1b98b63f`.
```solidity
function claimAndWithdraw(MultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_8Call {
        pub claimPayload: <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))`](claimAndWithdraw_8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_8Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_8Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_8Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_8Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_8Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_8Call {
            type Parameters<'a> = (MultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_8Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [27u8, 152u8, 182u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <MultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))` and selector `0x1bb81a81`.
```solidity
function claimAndWithdraw(QualifiedClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_9Call {
        pub claimPayload: <QualifiedClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))`](claimAndWithdraw_9Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_9Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_9Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_9Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_9Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_9Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_9Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_9Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_9Call {
            type Parameters<'a> = (QualifiedClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_9Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [27u8, 184u8, 26u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x206620a1`.
```solidity
function claimAndWithdraw(ExogenousSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_10Call {
        pub claimPayload: <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_10Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_10Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_10Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_10Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_10Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_10Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_10Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_10Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_10Call {
            type Parameters<'a> = (ExogenousSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_10Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [32u8, 102u8, 32u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x25d7776b`.
```solidity
function claimAndWithdraw(QualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_11Call {
        pub claimPayload: <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_11Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_11Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                QualifiedSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_11Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_11Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_11Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_11Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_11Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_11Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_11Call {
            type Parameters<'a> = (QualifiedSplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_11Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [37u8, 215u8, 119u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0x2737edb9`.
```solidity
function claimAndWithdraw(SplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_12Call {
        pub claimPayload: <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_12Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_12Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_12Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_12Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_12Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_12Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_12Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_12Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_12Call {
            type Parameters<'a> = (SplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_12Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [39u8, 55u8, 237u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x2acd5dc3`.
```solidity
function claimAndWithdraw(ExogenousBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_13Call {
        pub claimPayload: <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_13Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_13Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_13Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_13Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_13Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_13Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_13Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_13Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_13Call {
            type Parameters<'a> = (ExogenousBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_13Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [42u8, 205u8, 93u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))` and selector `0x2e4d55cc`.
```solidity
function claimAndWithdraw(ClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_14Call {
        pub claimPayload: <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))`](claimAndWithdraw_14Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_14Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_14Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_14Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_14Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_14Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_14Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_14Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_14Call {
            type Parameters<'a> = (ClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_14Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [46u8, 77u8, 85u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x341056c5`.
```solidity
function claimAndWithdraw(ExogenousSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_15Call {
        pub claimPayload: <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_15Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_15Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_15Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_15Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_15Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_15Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_15Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_15Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_15Call {
            type Parameters<'a> = (ExogenousSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_15Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [52u8, 16u8, 86u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0x3f458a19`.
```solidity
function claimAndWithdraw(SplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_16Call {
        pub claimPayload: <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_16Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_16Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_16Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_16Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_16Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_16Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_16Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_16Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_16Call {
            type Parameters<'a> = (SplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_16Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [63u8, 69u8, 138u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x418a23f5`.
```solidity
function claimAndWithdraw(ExogenousQualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_17Call {
        pub claimPayload: <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_17Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_17Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_17Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_17Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_17Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_17Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_17Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_17Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_17Call {
            type Parameters<'a> = (ExogenousQualifiedMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_17Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [65u8, 138u8, 35u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))` and selector `0x4ad5205e`.
```solidity
function claimAndWithdraw(SplitClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_18Call {
        pub claimPayload: <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_18Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_18Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_18Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_18Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_18Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_18Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_18Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_18Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_18Call {
            type Parameters<'a> = (SplitClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_18Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [74u8, 213u8, 32u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))` and selector `0x4e55a548`.
```solidity
function claimAndWithdraw(BatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_19Call {
        pub claimPayload: <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_19Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_19Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_19Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_19Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_19Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_19Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_19Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_19Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_19Call {
            type Parameters<'a> = (BatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_19Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [78u8, 85u8, 165u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x548439e1`.
```solidity
function claimAndWithdraw(SplitBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_20Call {
        pub claimPayload: <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_20Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_20Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_20Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_20Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_20Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_20Call {
            type Parameters<'a> = (SplitBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_20Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [84u8, 132u8, 57u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x5d76a382`.
```solidity
function claimAndWithdraw(ExogenousSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_21Call {
        pub claimPayload: <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_21Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_21Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_21Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_21Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_21Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_21Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_21Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_21Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_21Call {
            type Parameters<'a> = (ExogenousSplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_21Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [93u8, 118u8, 163u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x62a420bb`.
```solidity
function claimAndWithdraw(SplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_22Call {
        pub claimPayload: <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_22Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_22Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_22Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_22Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_22Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_22Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_22Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_22Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_22Call {
            type Parameters<'a> = (SplitBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_22Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [98u8, 164u8, 32u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x64870556`.
```solidity
function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_23Call {
        pub claimPayload: <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_23Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_23Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedSplitMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_23Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_23Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_23Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_23Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_23Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_23Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_23Call {
            type Parameters<'a> = (ExogenousQualifiedSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_23Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [100u8, 135u8, 5u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x71f50127`.
```solidity
function claimAndWithdraw(SplitClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_24Call {
        pub claimPayload: <SplitClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_24Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_24Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_24Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_24Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_24Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_24Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_24Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_24Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_24Call {
            type Parameters<'a> = (SplitClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_24Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [113u8, 245u8, 1u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<SplitClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0x721f6292`.
```solidity
function claimAndWithdraw(BatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_25Call {
        pub claimPayload: <BatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_25Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_25Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_25Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_25Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_25Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_25Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_25Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_25Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_25Call {
            type Parameters<'a> = (BatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_25Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [114u8, 31u8, 98u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BatchClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))` and selector `0x76d531d4`.
```solidity
function claimAndWithdraw(MultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_26Call {
        pub claimPayload: <MultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))`](claimAndWithdraw_26Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_26Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (MultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <MultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_26Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_26Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_26Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_26Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_26Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_26Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_26Call {
            type Parameters<'a> = (MultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_26Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [118u8, 213u8, 49u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <MultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0x843719f0`.
```solidity
function claimAndWithdraw(ExogenousQualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_27Call {
        pub claimPayload: <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_27Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_27Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_27Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_27Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_27Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_27Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_27Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_27Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_27Call {
            type Parameters<'a> = (ExogenousQualifiedSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_27Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [132u8, 55u8, 25u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))` and selector `0x88d247c4`.
```solidity
function claimAndWithdraw(SplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_28Call {
        pub claimPayload: <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_28Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_28Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_28Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_28Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_28Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_28Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_28Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_28Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_28Call {
            type Parameters<'a> = (SplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_28Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [136u8, 210u8, 71u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0x88da84d4`.
```solidity
function claimAndWithdraw(ExogenousQualifiedSplitBatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_29Call {
        pub claimPayload: <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_29Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_29Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedSplitBatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_29Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_29Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_29Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_29Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_29Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_29Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_29Call {
            type Parameters<'a> = (ExogenousQualifiedSplitBatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_29Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [136u8, 218u8, 132u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitBatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0x89ce0661`.
```solidity
function claimAndWithdraw(ExogenousMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_30Call {
        pub claimPayload: <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_30Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_30Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_30Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_30Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_30Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_30Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_30Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_30Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_30Call {
            type Parameters<'a> = (ExogenousMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_30Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [137u8, 206u8, 6u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))` and selector `0xb20abc48`.
```solidity
function claimAndWithdraw(QualifiedBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_31Call {
        pub claimPayload: <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_31Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_31Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_31Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_31Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_31Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_31Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_31Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_31Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_31Call {
            type Parameters<'a> = (QualifiedBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_31Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [178u8, 10u8, 188u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))` and selector `0xb602ae02`.
```solidity
function claimAndWithdraw(BasicClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_32Call {
        pub claimPayload: <BasicClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_32Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BasicClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BasicClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_32Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_32Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_32Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_32Call {
            type Parameters<'a> = (BasicClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [182u8, 2u8, 174u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<BasicClaim as alloy_sol_types::SolType>::tokenize(&self.claimPayload),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0xbc95bd7a`.
```solidity
function claimAndWithdraw(BatchMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_33Call {
        pub claimPayload: <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))`](claimAndWithdraw_33Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_33Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_33Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_33Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_33Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_33Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_33Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_33Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_33Call {
            type Parameters<'a> = (BatchMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_33Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [188u8, 149u8, 189u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))` and selector `0xc4d195e8`.
```solidity
function claimAndWithdraw(BatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_34Call {
        pub claimPayload: <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))`](claimAndWithdraw_34Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_34Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_34Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_34Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_34Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_34Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_34Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_34Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_34Call {
            type Parameters<'a> = (BatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_34Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [196u8, 209u8, 149u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <BatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0xca6cc39f`.
```solidity
function claimAndWithdraw(ExogenousMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_35Call {
        pub claimPayload: <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_35Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_35Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_35Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_35Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_35Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_35Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_35Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_35Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_35Call {
            type Parameters<'a> = (ExogenousMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_35Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [202u8, 108u8, 195u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xd2a1805f`.
```solidity
function claimAndWithdraw(QualifiedSplitMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_36Call {
        pub claimPayload: <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_36Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_36Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_36Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_36Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_36Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_36Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_36Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_36Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_36Call {
            type Parameters<'a> = (QualifiedSplitMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_36Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [210u8, 161u8, 128u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))` and selector `0xd3917f3c`.
```solidity
function claimAndWithdraw(QualifiedMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_37Call {
        pub claimPayload: <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))`](claimAndWithdraw_37Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_37Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_37Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_37Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_37Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_37Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_37Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_37Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_37Call {
            type Parameters<'a> = (QualifiedMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_37Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [211u8, 145u8, 127u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))` and selector `0xd921f36a`.
```solidity
function claimAndWithdraw(ExogenousQualifiedSplitBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_38Call {
        pub claimPayload: <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_38Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_38Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_38Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_38Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_38Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_38Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_38Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_38Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_38Call {
            type Parameters<'a> = (
                ExogenousQualifiedSplitBatchMultichainClaimWithWitness,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_38Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [217u8, 33u8, 243u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))` and selector `0xe05c6e7d`.
```solidity
function claimAndWithdraw(ExogenousSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_39Call {
        pub claimPayload: <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_39Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_39Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_39Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_39Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_39Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_39Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_39Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_39Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_39Call {
            type Parameters<'a> = (ExogenousSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_39Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32[],uint256,uint256,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [224u8, 92u8, 110u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))` and selector `0xeb196008`.
```solidity
function claimAndWithdraw(QualifiedSplitMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_40Call {
        pub claimPayload: <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_40Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_40Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_40Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_40Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_40Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_40Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_40Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_40Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_40Call {
            type Parameters<'a> = (QualifiedSplitMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_40Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [235u8, 25u8, 96u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))` and selector `0xeea77a78`.
```solidity
function claimAndWithdraw(ExogenousQualifiedMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_41Call {
        pub claimPayload: <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))`](claimAndWithdraw_41Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_41Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousQualifiedMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_41Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_41Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_41Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_41Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_41Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_41Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_41Call {
            type Parameters<'a> = (ExogenousQualifiedMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_41Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [238u8, 167u8, 122u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0xeed93572`.
```solidity
function claimAndWithdraw(ExogenousBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_42Call {
        pub claimPayload: <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_42Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_42Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ExogenousBatchMultichainClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_42Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_42Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_42Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_42Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_42Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_42Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_42Call {
            type Parameters<'a> = (ExogenousBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_42Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [238u8, 217u8, 53u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))` and selector `0xf23d923d`.
```solidity
function claimAndWithdraw(QualifiedMultichainClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_43Call {
        pub claimPayload: <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))`](claimAndWithdraw_43Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_43Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedMultichainClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_43Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_43Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_43Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_43Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_43Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_43Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_43Call {
            type Parameters<'a> = (QualifiedMultichainClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_43Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,bytes32[],uint256,uint256,address,uint256))";
            const SELECTOR: [u8; 4] = [242u8, 61u8, 146u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedMultichainClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))` and selector `0xf2f0def1`.
```solidity
function claimAndWithdraw(SplitBatchClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_44Call {
        pub claimPayload: <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))`](claimAndWithdraw_44Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_44Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SplitBatchClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_44Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_44Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_44Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_44Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_44Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_44Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_44Call {
            type Parameters<'a> = (SplitBatchClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_44Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,(uint256,uint256,(address,uint256)[])[]))";
            const SELECTOR: [u8; 4] = [242u8, 240u8, 222u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SplitBatchClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))` and selector `0xf44a3452`.
```solidity
function claimAndWithdraw(QualifiedBatchClaim memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_45Call {
        pub claimPayload: <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_45Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_45Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedBatchClaim,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_45Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_45Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_45Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_45Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_45Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_45Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_45Call {
            type Parameters<'a> = (QualifiedBatchClaim,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_45Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,bytes,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [244u8, 74u8, 52u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedBatchClaim as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))` and selector `0xf95d3d16`.
```solidity
function claimAndWithdraw(QualifiedSplitClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_46Call {
        pub claimPayload: <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))`](claimAndWithdraw_46Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_46Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QualifiedSplitClaimWithWitness,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_46Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_46Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_46Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_46Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_46Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_46Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_46Call {
            type Parameters<'a> = (QualifiedSplitClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_46Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,uint256,uint256,(address,uint256)[]))";
            const SELECTOR: [u8; 4] = [249u8, 93u8, 61u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <QualifiedSplitClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))` and selector `0xfcfe431a`.
```solidity
function claimAndWithdraw(ExogenousQualifiedBatchMultichainClaimWithWitness memory claimPayload) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_47Call {
        pub claimPayload: <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))`](claimAndWithdraw_47Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimAndWithdraw_47Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ExogenousQualifiedBatchMultichainClaimWithWitness,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_47Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_47Call) -> Self {
                    (value.claimPayload,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_47Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimPayload: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimAndWithdraw_47Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimAndWithdraw_47Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimAndWithdraw_47Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimAndWithdraw_47Call {
            type Parameters<'a> = (ExogenousQualifiedBatchMultichainClaimWithWitness,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimAndWithdraw_47Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimAndWithdraw((bytes,bytes,address,uint256,uint256,bytes32,string,bytes32,bytes,bytes32[],uint256,uint256,(uint256,uint256,uint256)[],address))";
            const SELECTOR: [u8; 4] = [252u8, 254u8, 67u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy_sol_types::SolType>::tokenize(
                        &self.claimPayload,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `consume(uint256[])` and selector `0x12d48885`.
```solidity
function consume(uint256[] memory nonces) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct consumeCall {
        pub nonces: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`consume(uint256[])`](consumeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct consumeReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<consumeCall> for UnderlyingRustTuple<'_> {
                fn from(value: consumeCall) -> Self {
                    (value.nonces,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for consumeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nonces: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<consumeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: consumeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for consumeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for consumeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = consumeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "consume(uint256[])";
            const SELECTOR: [u8; 4] = [18u8, 212u8, 136u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonces),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decimals(uint256)` and selector `0x3f47e662`.
```solidity
function decimals(uint256 id) external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsCall {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`decimals(uint256)`](decimalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsReturn {
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decimalsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decimalsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decimals(uint256)";
            const SELECTOR: [u8; 4] = [63u8, 71u8, 230u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deposit(address,uint256,uint256,uint256,address,address,uint8,uint8,address,bytes)` and selector `0x10d82672`.
```solidity
function deposit(address token, uint256, uint256, uint256, address, address, ResetPeriod, Scope, address recipient, bytes memory signature) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_0Call {
        pub token: alloy::sol_types::private::Address,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
        pub _2: alloy::sol_types::private::primitives::aliases::U256,
        pub _3: alloy::sol_types::private::primitives::aliases::U256,
        pub _4: alloy::sol_types::private::Address,
        pub _5: alloy::sol_types::private::Address,
        pub _6: <ResetPeriod as alloy::sol_types::SolType>::RustType,
        pub _7: <Scope as alloy::sol_types::SolType>::RustType,
        pub recipient: alloy::sol_types::private::Address,
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`deposit(address,uint256,uint256,uint256,address,address,uint8,uint8,address,bytes)`](deposit_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_0Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                <ResetPeriod as alloy::sol_types::SolType>::RustType,
                <Scope as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_0Call) -> Self {
                    (
                        value.token,
                        value._1,
                        value._2,
                        value._3,
                        value._4,
                        value._5,
                        value._6,
                        value._7,
                        value.recipient,
                        value.signature,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        _4: tuple.4,
                        _5: tuple.5,
                        _6: tuple.6,
                        _7: tuple.7,
                        recipient: tuple.8,
                        signature: tuple.9,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deposit_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deposit_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(address,uint256,uint256,uint256,address,address,uint8,uint8,address,bytes)";
            const SELECTOR: [u8; 4] = [16u8, 216u8, 38u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._4,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._5,
                    ),
                    <ResetPeriod as alloy_sol_types::SolType>::tokenize(&self._6),
                    <Scope as alloy_sol_types::SolType>::tokenize(&self._7),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deposit(address,uint8,uint8,address)` and selector `0x507cb46f`.
```solidity
function deposit(address allocator, ResetPeriod resetPeriod, Scope scope, address recipient) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_1Call {
        pub allocator: alloy::sol_types::private::Address,
        pub resetPeriod: <ResetPeriod as alloy::sol_types::SolType>::RustType,
        pub scope: <Scope as alloy::sol_types::SolType>::RustType,
        pub recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`deposit(address,uint8,uint8,address)`](deposit_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_1Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <ResetPeriod as alloy::sol_types::SolType>::RustType,
                <Scope as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_1Call) -> Self {
                    (value.allocator, value.resetPeriod, value.scope, value.recipient)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        allocator: tuple.0,
                        resetPeriod: tuple.1,
                        scope: tuple.2,
                        recipient: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deposit_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deposit_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(address,uint8,uint8,address)";
            const SELECTOR: [u8; 4] = [80u8, 124u8, 180u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                    <ResetPeriod as alloy_sol_types::SolType>::tokenize(
                        &self.resetPeriod,
                    ),
                    <Scope as alloy_sol_types::SolType>::tokenize(&self.scope),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deposit(address,address,uint8,uint8,uint256,address)` and selector `0x671b3bd6`.
```solidity
function deposit(address token, address allocator, ResetPeriod resetPeriod, Scope scope, uint256 amount, address recipient) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_2Call {
        pub token: alloy::sol_types::private::Address,
        pub allocator: alloy::sol_types::private::Address,
        pub resetPeriod: <ResetPeriod as alloy::sol_types::SolType>::RustType,
        pub scope: <Scope as alloy::sol_types::SolType>::RustType,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        pub recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`deposit(address,address,uint8,uint8,uint256,address)`](deposit_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_2Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                <ResetPeriod as alloy::sol_types::SolType>::RustType,
                <Scope as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_2Call) -> Self {
                    (
                        value.token,
                        value.allocator,
                        value.resetPeriod,
                        value.scope,
                        value.amount,
                        value.recipient,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        allocator: tuple.1,
                        resetPeriod: tuple.2,
                        scope: tuple.3,
                        amount: tuple.4,
                        recipient: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deposit_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deposit_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(address,address,uint8,uint8,uint256,address)";
            const SELECTOR: [u8; 4] = [103u8, 27u8, 59u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                    <ResetPeriod as alloy_sol_types::SolType>::tokenize(
                        &self.resetPeriod,
                    ),
                    <Scope as alloy_sol_types::SolType>::tokenize(&self.scope),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deposit(address,address,uint256)` and selector `0x8340f549`.
```solidity
function deposit(address token, address allocator, uint256 amount) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_3Call {
        pub token: alloy::sol_types::private::Address,
        pub allocator: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`deposit(address,address,uint256)`](deposit_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_3Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_3Call) -> Self {
                    (value.token, value.allocator, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        allocator: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deposit_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deposit_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(address,address,uint256)";
            const SELECTOR: [u8; 4] = [131u8, 64u8, 245u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deposit(address,(address,uint256)[],uint256,uint256,address,uint8,uint8,address,bytes)` and selector `0x99cf8b9b`.
```solidity
function deposit(address, ISignatureTransfer.TokenPermissions[] memory permitted, uint256, uint256, address, ResetPeriod, Scope, address recipient, bytes memory signature) external payable returns (uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_4Call {
        pub _0: alloy::sol_types::private::Address,
        pub permitted: alloy::sol_types::private::Vec<
            <ISignatureTransfer::TokenPermissions as alloy::sol_types::SolType>::RustType,
        >,
        pub _2: alloy::sol_types::private::primitives::aliases::U256,
        pub _3: alloy::sol_types::private::primitives::aliases::U256,
        pub _4: alloy::sol_types::private::Address,
        pub _5: <ResetPeriod as alloy::sol_types::SolType>::RustType,
        pub _6: <Scope as alloy::sol_types::SolType>::RustType,
        pub recipient: alloy::sol_types::private::Address,
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`deposit(address,(address,uint256)[],uint256,uint256,address,uint8,uint8,address,bytes)`](deposit_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_4Return {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<ISignatureTransfer::TokenPermissions>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<
                    <ISignatureTransfer::TokenPermissions as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                <ResetPeriod as alloy::sol_types::SolType>::RustType,
                <Scope as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_4Call> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_4Call) -> Self {
                    (
                        value._0,
                        value.permitted,
                        value._2,
                        value._3,
                        value._4,
                        value._5,
                        value._6,
                        value.recipient,
                        value.signature,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        permitted: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        _4: tuple.4,
                        _5: tuple.5,
                        _6: tuple.6,
                        recipient: tuple.7,
                        signature: tuple.8,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_4Return> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_4Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deposit_4Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<ISignatureTransfer::TokenPermissions>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deposit_4Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(address,(address,uint256)[],uint256,uint256,address,uint8,uint8,address,bytes)";
            const SELECTOR: [u8; 4] = [153u8, 207u8, 139u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        ISignatureTransfer::TokenPermissions,
                    > as alloy_sol_types::SolType>::tokenize(&self.permitted),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._4,
                    ),
                    <ResetPeriod as alloy_sol_types::SolType>::tokenize(&self._5),
                    <Scope as alloy_sol_types::SolType>::tokenize(&self._6),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deposit(uint256[2][],address)` and selector `0xc8091041`.
```solidity
function deposit(uint256[2][] memory idsAndAmounts, address recipient) external payable returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_5Call {
        pub idsAndAmounts: alloy::sol_types::private::Vec<
            [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        >,
        pub recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`deposit(uint256[2][],address)`](deposit_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_5Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    >,
                >,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    [alloy::sol_types::private::primitives::aliases::U256; 2usize],
                >,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_5Call> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_5Call) -> Self {
                    (value.idsAndAmounts, value.recipient)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        idsAndAmounts: tuple.0,
                        recipient: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_5Return> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_5Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deposit_5Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    >,
                >,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deposit_5Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(uint256[2][],address)";
            const SELECTOR: [u8; 4] = [200u8, 9u8, 16u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedArray<
                            alloy::sol_types::sol_data::Uint<256>,
                            2usize,
                        >,
                    > as alloy_sol_types::SolType>::tokenize(&self.idsAndAmounts),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deposit(address)` and selector `0xf340fa01`.
```solidity
function deposit(address allocator) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_6Call {
        pub allocator: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`deposit(address)`](deposit_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deposit_6Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_6Call> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_6Call) -> Self {
                    (value.allocator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { allocator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deposit_6Return> for UnderlyingRustTuple<'_> {
                fn from(value: deposit_6Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deposit_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deposit_6Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deposit_6Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(address)";
            const SELECTOR: [u8; 4] = [243u8, 64u8, 250u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `depositAndRegister(address,uint256,uint256,uint256,address,address,uint8,uint8,bytes32,uint8,string,bytes)` and selector `0x53e50067`.
```solidity
function depositAndRegister(address token, uint256, uint256, uint256, address depositor, address, ResetPeriod resetPeriod, Scope, bytes32 claimHash, CompactCategory compactCategory, string memory witness, bytes memory signature) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_0Call {
        pub token: alloy::sol_types::private::Address,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
        pub _2: alloy::sol_types::private::primitives::aliases::U256,
        pub _3: alloy::sol_types::private::primitives::aliases::U256,
        pub depositor: alloy::sol_types::private::Address,
        pub _5: alloy::sol_types::private::Address,
        pub resetPeriod: <ResetPeriod as alloy::sol_types::SolType>::RustType,
        pub _7: <Scope as alloy::sol_types::SolType>::RustType,
        pub claimHash: alloy::sol_types::private::FixedBytes<32>,
        pub compactCategory: <CompactCategory as alloy::sol_types::SolType>::RustType,
        pub witness: alloy::sol_types::private::String,
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`depositAndRegister(address,uint256,uint256,uint256,address,address,uint8,uint8,bytes32,uint8,string,bytes)`](depositAndRegister_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_0Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::FixedBytes<32>,
                CompactCategory,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                <ResetPeriod as alloy::sol_types::SolType>::RustType,
                <Scope as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                <CompactCategory as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_0Call) -> Self {
                    (
                        value.token,
                        value._1,
                        value._2,
                        value._3,
                        value.depositor,
                        value._5,
                        value.resetPeriod,
                        value._7,
                        value.claimHash,
                        value.compactCategory,
                        value.witness,
                        value.signature,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        depositor: tuple.4,
                        _5: tuple.5,
                        resetPeriod: tuple.6,
                        _7: tuple.7,
                        claimHash: tuple.8,
                        compactCategory: tuple.9,
                        witness: tuple.10,
                        signature: tuple.11,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositAndRegister_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::FixedBytes<32>,
                CompactCategory,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositAndRegister_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositAndRegister(address,uint256,uint256,uint256,address,address,uint8,uint8,bytes32,uint8,string,bytes)";
            const SELECTOR: [u8; 4] = [83u8, 229u8, 0u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.depositor,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._5,
                    ),
                    <ResetPeriod as alloy_sol_types::SolType>::tokenize(
                        &self.resetPeriod,
                    ),
                    <Scope as alloy_sol_types::SolType>::tokenize(&self._7),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimHash),
                    <CompactCategory as alloy_sol_types::SolType>::tokenize(
                        &self.compactCategory,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witness,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `depositAndRegister(uint256[2][],bytes32[2][],uint256)` and selector `0x5b6016ec`.
```solidity
function depositAndRegister(uint256[2][] memory idsAndAmounts, bytes32[2][] memory claimHashesAndTypehashes, uint256 duration) external payable returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_1Call {
        pub idsAndAmounts: alloy::sol_types::private::Vec<
            [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        >,
        pub claimHashesAndTypehashes: alloy::sol_types::private::Vec<
            [alloy::sol_types::private::FixedBytes<32>; 2usize],
        >,
        pub duration: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`depositAndRegister(uint256[2][],bytes32[2][],uint256)`](depositAndRegister_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_1Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    >,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    >,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    [alloy::sol_types::private::primitives::aliases::U256; 2usize],
                >,
                alloy::sol_types::private::Vec<
                    [alloy::sol_types::private::FixedBytes<32>; 2usize],
                >,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_1Call) -> Self {
                    (value.idsAndAmounts, value.claimHashesAndTypehashes, value.duration)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        idsAndAmounts: tuple.0,
                        claimHashesAndTypehashes: tuple.1,
                        duration: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositAndRegister_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    >,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    >,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositAndRegister_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositAndRegister(uint256[2][],bytes32[2][],uint256)";
            const SELECTOR: [u8; 4] = [91u8, 96u8, 22u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedArray<
                            alloy::sol_types::sol_data::Uint<256>,
                            2usize,
                        >,
                    > as alloy_sol_types::SolType>::tokenize(&self.idsAndAmounts),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedArray<
                            alloy::sol_types::sol_data::FixedBytes<32>,
                            2usize,
                        >,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.claimHashesAndTypehashes,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `depositAndRegister(address,bytes32,bytes32)` and selector `0xaa8b845d`.
```solidity
function depositAndRegister(address allocator, bytes32 claimHash, bytes32 typehash) external payable returns (uint256 id);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_2Call {
        pub allocator: alloy::sol_types::private::Address,
        pub claimHash: alloy::sol_types::private::FixedBytes<32>,
        pub typehash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`depositAndRegister(address,bytes32,bytes32)`](depositAndRegister_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_2Return {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_2Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_2Call) -> Self {
                    (value.allocator, value.claimHash, value.typehash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        allocator: tuple.0,
                        claimHash: tuple.1,
                        typehash: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_2Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_2Return) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositAndRegister_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositAndRegister_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositAndRegister(address,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 139u8, 132u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.typehash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `depositAndRegister(address,(address,uint256)[],uint256,uint256,address,uint8,uint8,bytes32,uint8,string,bytes)` and selector `0xda15ee7f`.
```solidity
function depositAndRegister(address depositor, ISignatureTransfer.TokenPermissions[] memory permitted, uint256, uint256, address, ResetPeriod resetPeriod, Scope, bytes32 claimHash, CompactCategory compactCategory, string memory witness, bytes memory signature) external payable returns (uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_3Call {
        pub depositor: alloy::sol_types::private::Address,
        pub permitted: alloy::sol_types::private::Vec<
            <ISignatureTransfer::TokenPermissions as alloy::sol_types::SolType>::RustType,
        >,
        pub _2: alloy::sol_types::private::primitives::aliases::U256,
        pub _3: alloy::sol_types::private::primitives::aliases::U256,
        pub _4: alloy::sol_types::private::Address,
        pub resetPeriod: <ResetPeriod as alloy::sol_types::SolType>::RustType,
        pub _6: <Scope as alloy::sol_types::SolType>::RustType,
        pub claimHash: alloy::sol_types::private::FixedBytes<32>,
        pub compactCategory: <CompactCategory as alloy::sol_types::SolType>::RustType,
        pub witness: alloy::sol_types::private::String,
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`depositAndRegister(address,(address,uint256)[],uint256,uint256,address,uint8,uint8,bytes32,uint8,string,bytes)`](depositAndRegister_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_3Return {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<ISignatureTransfer::TokenPermissions>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::FixedBytes<32>,
                CompactCategory,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<
                    <ISignatureTransfer::TokenPermissions as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                <ResetPeriod as alloy::sol_types::SolType>::RustType,
                <Scope as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
                <CompactCategory as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_3Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_3Call) -> Self {
                    (
                        value.depositor,
                        value.permitted,
                        value._2,
                        value._3,
                        value._4,
                        value.resetPeriod,
                        value._6,
                        value.claimHash,
                        value.compactCategory,
                        value.witness,
                        value.signature,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        depositor: tuple.0,
                        permitted: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        _4: tuple.4,
                        resetPeriod: tuple.5,
                        _6: tuple.6,
                        claimHash: tuple.7,
                        compactCategory: tuple.8,
                        witness: tuple.9,
                        signature: tuple.10,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_3Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositAndRegister_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<ISignatureTransfer::TokenPermissions>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
                alloy::sol_types::sol_data::FixedBytes<32>,
                CompactCategory,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositAndRegister_3Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositAndRegister(address,(address,uint256)[],uint256,uint256,address,uint8,uint8,bytes32,uint8,string,bytes)";
            const SELECTOR: [u8; 4] = [218u8, 21u8, 238u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.depositor,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        ISignatureTransfer::TokenPermissions,
                    > as alloy_sol_types::SolType>::tokenize(&self.permitted),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._4,
                    ),
                    <ResetPeriod as alloy_sol_types::SolType>::tokenize(
                        &self.resetPeriod,
                    ),
                    <Scope as alloy_sol_types::SolType>::tokenize(&self._6),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimHash),
                    <CompactCategory as alloy_sol_types::SolType>::tokenize(
                        &self.compactCategory,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.witness,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `depositAndRegister(address,address,uint256,bytes32,bytes32)` and selector `0xecaca40e`.
```solidity
function depositAndRegister(address token, address allocator, uint256 amount, bytes32 claimHash, bytes32 typehash) external returns (uint256 id);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_4Call {
        pub token: alloy::sol_types::private::Address,
        pub allocator: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        pub claimHash: alloy::sol_types::private::FixedBytes<32>,
        pub typehash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`depositAndRegister(address,address,uint256,bytes32,bytes32)`](depositAndRegister_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndRegister_4Return {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_4Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_4Call) -> Self {
                    (
                        value.token,
                        value.allocator,
                        value.amount,
                        value.claimHash,
                        value.typehash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        allocator: tuple.1,
                        amount: tuple.2,
                        claimHash: tuple.3,
                        typehash: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndRegister_4Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndRegister_4Return) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndRegister_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositAndRegister_4Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositAndRegister_4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositAndRegister(address,address,uint256,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [236u8, 172u8, 164u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.typehash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `disableForcedWithdrawal(uint256)` and selector `0x70030190`.
```solidity
function disableForcedWithdrawal(uint256 id) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableForcedWithdrawalCall {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`disableForcedWithdrawal(uint256)`](disableForcedWithdrawalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableForcedWithdrawalReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableForcedWithdrawalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: disableForcedWithdrawalCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for disableForcedWithdrawalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableForcedWithdrawalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: disableForcedWithdrawalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for disableForcedWithdrawalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for disableForcedWithdrawalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = disableForcedWithdrawalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "disableForcedWithdrawal(uint256)";
            const SELECTOR: [u8; 4] = [112u8, 3u8, 1u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `enableForcedWithdrawal(uint256)` and selector `0xeb35a6d2`.
```solidity
function enableForcedWithdrawal(uint256 id) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableForcedWithdrawalCall {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`enableForcedWithdrawal(uint256)`](enableForcedWithdrawalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableForcedWithdrawalReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableForcedWithdrawalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: enableForcedWithdrawalCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for enableForcedWithdrawalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableForcedWithdrawalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: enableForcedWithdrawalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for enableForcedWithdrawalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enableForcedWithdrawalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = enableForcedWithdrawalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enableForcedWithdrawal(uint256)";
            const SELECTOR: [u8; 4] = [235u8, 53u8, 166u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `extsload(bytes32)` and selector `0x1e2eaeaf`.
```solidity
function extsload(bytes32 slot) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct extsload_0Call {
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`extsload(bytes32)`](extsload_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct extsload_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_0Call) -> Self {
                    (value.slot,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slot: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extsload_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = extsload_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extsload(bytes32)";
            const SELECTOR: [u8; 4] = [30u8, 46u8, 174u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `extsload(bytes32[])` and selector `0xdbd035ff`.
```solidity
function extsload(bytes32[] memory slots) external view returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct extsload_1Call {
        pub slots: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`extsload(bytes32[])`](extsload_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct extsload_1Return {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_1Call) -> Self {
                    (value.slots,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slots: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extsload_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = extsload_1Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extsload(bytes32[])";
            const SELECTOR: [u8; 4] = [219u8, 208u8, 53u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.slots),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `exttload(bytes32)` and selector `0xf135baaa`.
```solidity
function exttload(bytes32 slot) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct exttloadCall {
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`exttload(bytes32)`](exttloadCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct exttloadReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttloadCall> for UnderlyingRustTuple<'_> {
                fn from(value: exttloadCall) -> Self {
                    (value.slot,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttloadCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slot: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttloadReturn> for UnderlyingRustTuple<'_> {
                fn from(value: exttloadReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttloadReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exttloadCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = exttloadReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exttload(bytes32)";
            const SELECTOR: [u8; 4] = [241u8, 53u8, 186u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `forcedWithdrawal(uint256,address,uint256)` and selector `0x2e3ff2f7`.
```solidity
function forcedWithdrawal(uint256 id, address recipient, uint256 amount) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forcedWithdrawalCall {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub recipient: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`forcedWithdrawal(uint256,address,uint256)`](forcedWithdrawalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct forcedWithdrawalReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forcedWithdrawalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: forcedWithdrawalCall) -> Self {
                    (value.id, value.recipient, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for forcedWithdrawalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        id: tuple.0,
                        recipient: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<forcedWithdrawalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: forcedWithdrawalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for forcedWithdrawalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for forcedWithdrawalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = forcedWithdrawalReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "forcedWithdrawal(uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [46u8, 63u8, 242u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getForcedWithdrawalStatus(address,uint256)` and selector `0x144bd5b5`.
```solidity
function getForcedWithdrawalStatus(address account, uint256 id) external view returns (ForcedWithdrawalStatus, uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getForcedWithdrawalStatusCall {
        pub account: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getForcedWithdrawalStatus(address,uint256)`](getForcedWithdrawalStatusCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getForcedWithdrawalStatusReturn {
        pub _0: <ForcedWithdrawalStatus as alloy::sol_types::SolType>::RustType,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getForcedWithdrawalStatusCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getForcedWithdrawalStatusCall) -> Self {
                    (value.account, value.id)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getForcedWithdrawalStatusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        id: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ForcedWithdrawalStatus,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ForcedWithdrawalStatus as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getForcedWithdrawalStatusReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getForcedWithdrawalStatusReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getForcedWithdrawalStatusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getForcedWithdrawalStatusCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getForcedWithdrawalStatusReturn;
            type ReturnTuple<'a> = (
                ForcedWithdrawalStatus,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getForcedWithdrawalStatus(address,uint256)";
            const SELECTOR: [u8; 4] = [20u8, 75u8, 213u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLockDetails(uint256)` and selector `0x5b15bfd9`.
```solidity
function getLockDetails(uint256 id) external view returns (address, address, ResetPeriod, Scope);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLockDetailsCall {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getLockDetails(uint256)`](getLockDetailsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLockDetailsReturn {
        pub _0: alloy::sol_types::private::Address,
        pub _1: alloy::sol_types::private::Address,
        pub _2: <ResetPeriod as alloy::sol_types::SolType>::RustType,
        pub _3: <Scope as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLockDetailsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLockDetailsCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLockDetailsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                <ResetPeriod as alloy::sol_types::SolType>::RustType,
                <Scope as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLockDetailsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLockDetailsReturn) -> Self {
                    (value._0, value._1, value._2, value._3)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLockDetailsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLockDetailsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLockDetailsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                ResetPeriod,
                Scope,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLockDetails(uint256)";
            const SELECTOR: [u8; 4] = [91u8, 21u8, 191u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRegistrationStatus(address,bytes32,bytes32)` and selector `0x440a0ec3`.
```solidity
function getRegistrationStatus(address sponsor, bytes32 claimHash, bytes32 typehash) external view returns (bool isActive, uint256 expires);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRegistrationStatusCall {
        pub sponsor: alloy::sol_types::private::Address,
        pub claimHash: alloy::sol_types::private::FixedBytes<32>,
        pub typehash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRegistrationStatus(address,bytes32,bytes32)`](getRegistrationStatusCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRegistrationStatusReturn {
        pub isActive: bool,
        pub expires: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRegistrationStatusCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRegistrationStatusCall) -> Self {
                    (value.sponsor, value.claimHash, value.typehash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRegistrationStatusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sponsor: tuple.0,
                        claimHash: tuple.1,
                        typehash: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRegistrationStatusReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRegistrationStatusReturn) -> Self {
                    (value.isActive, value.expires)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRegistrationStatusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        isActive: tuple.0,
                        expires: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRegistrationStatusCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRegistrationStatusReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRegistrationStatus(address,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [68u8, 10u8, 14u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.typehash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasConsumedAllocatorNonce(uint256,address)` and selector `0xda2f268b`.
```solidity
function hasConsumedAllocatorNonce(uint256 nonce, address allocator) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasConsumedAllocatorNonceCall {
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        pub allocator: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasConsumedAllocatorNonce(uint256,address)`](hasConsumedAllocatorNonceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasConsumedAllocatorNonceReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasConsumedAllocatorNonceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasConsumedAllocatorNonceCall) -> Self {
                    (value.nonce, value.allocator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasConsumedAllocatorNonceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        nonce: tuple.0,
                        allocator: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasConsumedAllocatorNonceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hasConsumedAllocatorNonceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hasConsumedAllocatorNonceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasConsumedAllocatorNonceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasConsumedAllocatorNonceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasConsumedAllocatorNonce(uint256,address)";
            const SELECTOR: [u8; 4] = [218u8, 47u8, 38u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.allocator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isOperator(address,address)` and selector `0xb6363cf2`.
```solidity
function isOperator(address owner, address spender) external view returns (bool status);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOperatorCall {
        pub owner: alloy::sol_types::private::Address,
        pub spender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isOperator(address,address)`](isOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOperatorReturn {
        pub status: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorCall) -> Self {
                    (value.owner, value.spender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorReturn) -> Self {
                    (value.status,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { status: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isOperatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isOperator(address,address)";
            const SELECTOR: [u8; 4] = [182u8, 54u8, 60u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name(uint256)` and selector `0x00ad800c`.
```solidity
function name(uint256 id) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct name_0Call {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`name(uint256)`](name_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct name_0Return {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<name_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: name_0Call) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for name_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<name_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: name_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for name_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for name_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = name_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name(uint256)";
            const SELECTOR: [u8; 4] = [0u8, 173u8, 128u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external pure returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct name_1Call {}
    ///Container type for the return parameters of the [`name()`](name_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct name_1Return {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<name_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: name_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for name_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<name_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: name_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for name_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for name_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = name_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `register(bytes32[2][],uint256)` and selector `0x31bbae3e`.
```solidity
function register(bytes32[2][] memory claimHashesAndTypehashes, uint256 duration) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct register_0Call {
        pub claimHashesAndTypehashes: alloy::sol_types::private::Vec<
            [alloy::sol_types::private::FixedBytes<32>; 2usize],
        >,
        pub duration: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`register(bytes32[2][],uint256)`](register_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct register_0Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    >,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    [alloy::sol_types::private::FixedBytes<32>; 2usize],
                >,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<register_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: register_0Call) -> Self {
                    (value.claimHashesAndTypehashes, value.duration)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for register_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        claimHashesAndTypehashes: tuple.0,
                        duration: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<register_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: register_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for register_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for register_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                        2usize,
                    >,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = register_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "register(bytes32[2][],uint256)";
            const SELECTOR: [u8; 4] = [49u8, 187u8, 174u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedArray<
                            alloy::sol_types::sol_data::FixedBytes<32>,
                            2usize,
                        >,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.claimHashesAndTypehashes,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `register(bytes32,bytes32,uint256)` and selector `0x4073c0cc`.
```solidity
function register(bytes32 claimHash, bytes32 typehash, uint256 duration) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct register_1Call {
        pub claimHash: alloy::sol_types::private::FixedBytes<32>,
        pub typehash: alloy::sol_types::private::FixedBytes<32>,
        pub duration: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`register(bytes32,bytes32,uint256)`](register_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct register_1Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<register_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: register_1Call) -> Self {
                    (value.claimHash, value.typehash, value.duration)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for register_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        claimHash: tuple.0,
                        typehash: tuple.1,
                        duration: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<register_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: register_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for register_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for register_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = register_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "register(bytes32,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 115u8, 192u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.typehash),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.duration),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setOperator(address,bool)` and selector `0x558a7297`.
```solidity
function setOperator(address operator, bool approved) external payable returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOperatorCall {
        pub operator: alloy::sol_types::private::Address,
        pub approved: bool,
    }
    ///Container type for the return parameters of the [`setOperator(address,bool)`](setOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOperatorReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorCall) -> Self {
                    (value.operator, value.approved)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        approved: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setOperatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setOperator(address,bool)";
            const SELECTOR: [u8; 4] = [85u8, 138u8, 114u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        pub result: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `symbol(uint256)` and selector `0x4e41a1fb`.
```solidity
function symbol(uint256 id) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`symbol(uint256)`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = symbolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol(uint256)";
            const SELECTOR: [u8; 4] = [78u8, 65u8, 161u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `tokenURI(uint256)` and selector `0xc87b56dd`.
```solidity
function tokenURI(uint256 id) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenURICall {
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`tokenURI(uint256)`](tokenURICall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tokenURIReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenURICall> for UnderlyingRustTuple<'_> {
                fn from(value: tokenURICall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenURICall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tokenURIReturn> for UnderlyingRustTuple<'_> {
                fn from(value: tokenURIReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tokenURIReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tokenURICall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = tokenURIReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tokenURI(uint256)";
            const SELECTOR: [u8; 4] = [200u8, 123u8, 86u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256,uint256)` and selector `0x095bcdb6`.
```solidity
function transfer(address to, uint256 id, uint256 amount) external payable returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferCall {
        pub to: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.to, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 91u8, 205u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256,uint256)` and selector `0xfe99049a`.
```solidity
function transferFrom(address from, address to, uint256 id, uint256 amount) external payable returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        pub from: alloy::sol_types::private::Address,
        pub to: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        id: tuple.2,
                        amount: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [254u8, 153u8, 4u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`TheCompact`](self) function calls.
    pub enum TheCompactCalls {
        DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
        __activateTstore(__activateTstoreCall),
        __registerAllocator(__registerAllocatorCall),
        allocatedTransfer_0(allocatedTransfer_0Call),
        allocatedTransfer_1(allocatedTransfer_1Call),
        allocatedTransfer_2(allocatedTransfer_2Call),
        allocatedTransfer_3(allocatedTransfer_3Call),
        allocatedWithdrawal_0(allocatedWithdrawal_0Call),
        allocatedWithdrawal_1(allocatedWithdrawal_1Call),
        allocatedWithdrawal_2(allocatedWithdrawal_2Call),
        allocatedWithdrawal_3(allocatedWithdrawal_3Call),
        allowance(allowanceCall),
        approve(approveCall),
        balanceOf(balanceOfCall),
        claim_0(claim_0Call),
        claim_1(claim_1Call),
        claim_2(claim_2Call),
        claim_3(claim_3Call),
        claim_4(claim_4Call),
        claim_5(claim_5Call),
        claim_6(claim_6Call),
        claim_7(claim_7Call),
        claim_8(claim_8Call),
        claim_9(claim_9Call),
        claim_10(claim_10Call),
        claim_11(claim_11Call),
        claim_12(claim_12Call),
        claim_13(claim_13Call),
        claim_14(claim_14Call),
        claim_15(claim_15Call),
        claim_16(claim_16Call),
        claim_17(claim_17Call),
        claim_18(claim_18Call),
        claim_19(claim_19Call),
        claim_20(claim_20Call),
        claim_21(claim_21Call),
        claim_22(claim_22Call),
        claim_23(claim_23Call),
        claim_24(claim_24Call),
        claim_25(claim_25Call),
        claim_26(claim_26Call),
        claim_27(claim_27Call),
        claim_28(claim_28Call),
        claim_29(claim_29Call),
        claim_30(claim_30Call),
        claim_31(claim_31Call),
        claim_32(claim_32Call),
        claim_33(claim_33Call),
        claim_34(claim_34Call),
        claim_35(claim_35Call),
        claim_36(claim_36Call),
        claim_37(claim_37Call),
        claim_38(claim_38Call),
        claim_39(claim_39Call),
        claim_40(claim_40Call),
        claim_41(claim_41Call),
        claim_42(claim_42Call),
        claim_43(claim_43Call),
        claim_44(claim_44Call),
        claim_45(claim_45Call),
        claim_46(claim_46Call),
        claim_47(claim_47Call),
        claimAndWithdraw_0(claimAndWithdraw_0Call),
        claimAndWithdraw_1(claimAndWithdraw_1Call),
        claimAndWithdraw_2(claimAndWithdraw_2Call),
        claimAndWithdraw_3(claimAndWithdraw_3Call),
        claimAndWithdraw_4(claimAndWithdraw_4Call),
        claimAndWithdraw_5(claimAndWithdraw_5Call),
        claimAndWithdraw_6(claimAndWithdraw_6Call),
        claimAndWithdraw_7(claimAndWithdraw_7Call),
        claimAndWithdraw_8(claimAndWithdraw_8Call),
        claimAndWithdraw_9(claimAndWithdraw_9Call),
        claimAndWithdraw_10(claimAndWithdraw_10Call),
        claimAndWithdraw_11(claimAndWithdraw_11Call),
        claimAndWithdraw_12(claimAndWithdraw_12Call),
        claimAndWithdraw_13(claimAndWithdraw_13Call),
        claimAndWithdraw_14(claimAndWithdraw_14Call),
        claimAndWithdraw_15(claimAndWithdraw_15Call),
        claimAndWithdraw_16(claimAndWithdraw_16Call),
        claimAndWithdraw_17(claimAndWithdraw_17Call),
        claimAndWithdraw_18(claimAndWithdraw_18Call),
        claimAndWithdraw_19(claimAndWithdraw_19Call),
        claimAndWithdraw_20(claimAndWithdraw_20Call),
        claimAndWithdraw_21(claimAndWithdraw_21Call),
        claimAndWithdraw_22(claimAndWithdraw_22Call),
        claimAndWithdraw_23(claimAndWithdraw_23Call),
        claimAndWithdraw_24(claimAndWithdraw_24Call),
        claimAndWithdraw_25(claimAndWithdraw_25Call),
        claimAndWithdraw_26(claimAndWithdraw_26Call),
        claimAndWithdraw_27(claimAndWithdraw_27Call),
        claimAndWithdraw_28(claimAndWithdraw_28Call),
        claimAndWithdraw_29(claimAndWithdraw_29Call),
        claimAndWithdraw_30(claimAndWithdraw_30Call),
        claimAndWithdraw_31(claimAndWithdraw_31Call),
        claimAndWithdraw_32(claimAndWithdraw_32Call),
        claimAndWithdraw_33(claimAndWithdraw_33Call),
        claimAndWithdraw_34(claimAndWithdraw_34Call),
        claimAndWithdraw_35(claimAndWithdraw_35Call),
        claimAndWithdraw_36(claimAndWithdraw_36Call),
        claimAndWithdraw_37(claimAndWithdraw_37Call),
        claimAndWithdraw_38(claimAndWithdraw_38Call),
        claimAndWithdraw_39(claimAndWithdraw_39Call),
        claimAndWithdraw_40(claimAndWithdraw_40Call),
        claimAndWithdraw_41(claimAndWithdraw_41Call),
        claimAndWithdraw_42(claimAndWithdraw_42Call),
        claimAndWithdraw_43(claimAndWithdraw_43Call),
        claimAndWithdraw_44(claimAndWithdraw_44Call),
        claimAndWithdraw_45(claimAndWithdraw_45Call),
        claimAndWithdraw_46(claimAndWithdraw_46Call),
        claimAndWithdraw_47(claimAndWithdraw_47Call),
        consume(consumeCall),
        decimals(decimalsCall),
        deposit_0(deposit_0Call),
        deposit_1(deposit_1Call),
        deposit_2(deposit_2Call),
        deposit_3(deposit_3Call),
        deposit_4(deposit_4Call),
        deposit_5(deposit_5Call),
        deposit_6(deposit_6Call),
        depositAndRegister_0(depositAndRegister_0Call),
        depositAndRegister_1(depositAndRegister_1Call),
        depositAndRegister_2(depositAndRegister_2Call),
        depositAndRegister_3(depositAndRegister_3Call),
        depositAndRegister_4(depositAndRegister_4Call),
        disableForcedWithdrawal(disableForcedWithdrawalCall),
        enableForcedWithdrawal(enableForcedWithdrawalCall),
        extsload_0(extsload_0Call),
        extsload_1(extsload_1Call),
        exttload(exttloadCall),
        forcedWithdrawal(forcedWithdrawalCall),
        getForcedWithdrawalStatus(getForcedWithdrawalStatusCall),
        getLockDetails(getLockDetailsCall),
        getRegistrationStatus(getRegistrationStatusCall),
        hasConsumedAllocatorNonce(hasConsumedAllocatorNonceCall),
        isOperator(isOperatorCall),
        name_0(name_0Call),
        name_1(name_1Call),
        register_0(register_0Call),
        register_1(register_1Call),
        setOperator(setOperatorCall),
        supportsInterface(supportsInterfaceCall),
        symbol(symbolCall),
        tokenURI(tokenURICall),
        transfer(transferCall),
        transferFrom(transferFromCall),
    }
    #[automatically_derived]
    impl TheCompactCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 173u8, 128u8, 12u8],
            [0u8, 253u8, 213u8, 142u8],
            [1u8, 255u8, 201u8, 167u8],
            [3u8, 65u8, 125u8, 114u8],
            [6u8, 101u8, 155u8, 127u8],
            [6u8, 232u8, 204u8, 24u8],
            [6u8, 253u8, 222u8, 3u8],
            [8u8, 230u8, 0u8, 238u8],
            [9u8, 91u8, 205u8, 182u8],
            [10u8, 19u8, 60u8, 242u8],
            [13u8, 87u8, 254u8, 201u8],
            [15u8, 94u8, 234u8, 223u8],
            [16u8, 125u8, 78u8, 228u8],
            [16u8, 216u8, 38u8, 114u8],
            [18u8, 161u8, 230u8, 234u8],
            [18u8, 212u8, 136u8, 133u8],
            [18u8, 249u8, 210u8, 30u8],
            [19u8, 88u8, 155u8, 254u8],
            [19u8, 140u8, 216u8, 25u8],
            [20u8, 75u8, 213u8, 181u8],
            [20u8, 134u8, 89u8, 7u8],
            [23u8, 111u8, 64u8, 90u8],
            [27u8, 152u8, 182u8, 63u8],
            [27u8, 184u8, 26u8, 129u8],
            [29u8, 71u8, 75u8, 20u8],
            [30u8, 46u8, 174u8, 175u8],
            [32u8, 15u8, 12u8, 77u8],
            [32u8, 102u8, 32u8, 161u8],
            [37u8, 215u8, 119u8, 107u8],
            [39u8, 55u8, 237u8, 185u8],
            [39u8, 199u8, 119u8, 169u8],
            [42u8, 156u8, 77u8, 13u8],
            [42u8, 205u8, 93u8, 195u8],
            [44u8, 75u8, 189u8, 23u8],
            [46u8, 63u8, 242u8, 247u8],
            [46u8, 77u8, 85u8, 204u8],
            [49u8, 187u8, 174u8, 62u8],
            [50u8, 226u8, 168u8, 3u8],
            [52u8, 16u8, 86u8, 197u8],
            [54u8, 68u8, 229u8, 21u8],
            [57u8, 60u8, 51u8, 226u8],
            [63u8, 69u8, 138u8, 25u8],
            [63u8, 71u8, 230u8, 98u8],
            [64u8, 115u8, 192u8, 204u8],
            [64u8, 155u8, 58u8, 126u8],
            [65u8, 79u8, 217u8, 20u8],
            [65u8, 138u8, 35u8, 245u8],
            [66u8, 106u8, 132u8, 147u8],
            [68u8, 10u8, 14u8, 195u8],
            [68u8, 185u8, 125u8, 120u8],
            [74u8, 213u8, 32u8, 94u8],
            [76u8, 16u8, 36u8, 22u8],
            [77u8, 88u8, 95u8, 191u8],
            [78u8, 65u8, 161u8, 251u8],
            [78u8, 85u8, 165u8, 72u8],
            [80u8, 124u8, 180u8, 111u8],
            [83u8, 229u8, 0u8, 103u8],
            [84u8, 132u8, 57u8, 225u8],
            [85u8, 138u8, 114u8, 151u8],
            [87u8, 124u8, 220u8, 100u8],
            [89u8, 32u8, 33u8, 40u8],
            [89u8, 138u8, 249u8, 231u8],
            [90u8, 194u8, 204u8, 241u8],
            [91u8, 21u8, 191u8, 217u8],
            [91u8, 96u8, 22u8, 236u8],
            [93u8, 118u8, 163u8, 130u8],
            [94u8, 108u8, 145u8, 255u8],
            [98u8, 164u8, 32u8, 187u8],
            [99u8, 245u8, 177u8, 173u8],
            [100u8, 135u8, 5u8, 86u8],
            [103u8, 27u8, 59u8, 214u8],
            [106u8, 154u8, 76u8, 68u8],
            [106u8, 242u8, 121u8, 27u8],
            [112u8, 3u8, 1u8, 144u8],
            [113u8, 18u8, 64u8, 109u8],
            [113u8, 245u8, 1u8, 39u8],
            [114u8, 31u8, 98u8, 146u8],
            [116u8, 35u8, 235u8, 60u8],
            [118u8, 213u8, 49u8, 212u8],
            [131u8, 64u8, 245u8, 73u8],
            [132u8, 55u8, 25u8, 240u8],
            [134u8, 120u8, 85u8, 89u8],
            [136u8, 210u8, 71u8, 196u8],
            [136u8, 218u8, 132u8, 212u8],
            [137u8, 206u8, 6u8, 97u8],
            [147u8, 94u8, 210u8, 186u8],
            [151u8, 48u8, 244u8, 253u8],
            [153u8, 109u8, 58u8, 172u8],
            [153u8, 207u8, 139u8, 155u8],
            [155u8, 229u8, 245u8, 55u8],
            [162u8, 57u8, 65u8, 71u8],
            [164u8, 199u8, 189u8, 147u8],
            [170u8, 65u8, 200u8, 126u8],
            [170u8, 139u8, 132u8, 93u8],
            [178u8, 10u8, 188u8, 72u8],
            [178u8, 72u8, 73u8, 183u8],
            [179u8, 36u8, 67u8, 137u8],
            [180u8, 3u8, 159u8, 194u8],
            [181u8, 75u8, 174u8, 253u8],
            [182u8, 2u8, 174u8, 2u8],
            [182u8, 54u8, 60u8, 242u8],
            [183u8, 172u8, 224u8, 71u8],
            [184u8, 165u8, 187u8, 173u8],
            [188u8, 149u8, 189u8, 122u8],
            [196u8, 209u8, 149u8, 232u8],
            [200u8, 9u8, 16u8, 65u8],
            [200u8, 123u8, 86u8, 221u8],
            [202u8, 108u8, 195u8, 159u8],
            [210u8, 4u8, 241u8, 30u8],
            [210u8, 161u8, 128u8, 95u8],
            [211u8, 77u8, 220u8, 130u8],
            [211u8, 80u8, 24u8, 140u8],
            [211u8, 145u8, 127u8, 60u8],
            [217u8, 33u8, 243u8, 106u8],
            [218u8, 21u8, 238u8, 127u8],
            [218u8, 47u8, 38u8, 139u8],
            [219u8, 4u8, 188u8, 114u8],
            [219u8, 208u8, 53u8, 255u8],
            [221u8, 88u8, 156u8, 252u8],
            [224u8, 86u8, 92u8, 73u8],
            [224u8, 92u8, 110u8, 125u8],
            [230u8, 197u8, 182u8, 84u8],
            [232u8, 103u8, 47u8, 147u8],
            [234u8, 20u8, 83u8, 46u8],
            [234u8, 166u8, 116u8, 131u8],
            [235u8, 25u8, 96u8, 8u8],
            [235u8, 53u8, 166u8, 210u8],
            [235u8, 67u8, 24u8, 33u8],
            [235u8, 203u8, 215u8, 181u8],
            [236u8, 172u8, 164u8, 14u8],
            [238u8, 167u8, 122u8, 120u8],
            [238u8, 214u8, 52u8, 173u8],
            [238u8, 217u8, 53u8, 114u8],
            [241u8, 53u8, 186u8, 170u8],
            [242u8, 61u8, 146u8, 61u8],
            [242u8, 240u8, 222u8, 241u8],
            [243u8, 64u8, 250u8, 1u8],
            [244u8, 74u8, 52u8, 82u8],
            [247u8, 69u8, 56u8, 28u8],
            [249u8, 93u8, 61u8, 22u8],
            [250u8, 28u8, 85u8, 0u8],
            [251u8, 117u8, 251u8, 105u8],
            [252u8, 254u8, 67u8, 26u8],
            [253u8, 192u8, 96u8, 231u8],
            [254u8, 153u8, 4u8, 154u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TheCompactCalls {
        const NAME: &'static str = "TheCompactCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 145usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DOMAIN_SEPARATOR(_) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::__activateTstore(_) => {
                    <__activateTstoreCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::__registerAllocator(_) => {
                    <__registerAllocatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocatedTransfer_0(_) => {
                    <allocatedTransfer_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocatedTransfer_1(_) => {
                    <allocatedTransfer_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocatedTransfer_2(_) => {
                    <allocatedTransfer_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocatedTransfer_3(_) => {
                    <allocatedTransfer_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocatedWithdrawal_0(_) => {
                    <allocatedWithdrawal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocatedWithdrawal_1(_) => {
                    <allocatedWithdrawal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocatedWithdrawal_2(_) => {
                    <allocatedWithdrawal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocatedWithdrawal_3(_) => {
                    <allocatedWithdrawal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claim_0(_) => <claim_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_1(_) => <claim_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_2(_) => <claim_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_3(_) => <claim_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_4(_) => <claim_4Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_5(_) => <claim_5Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_6(_) => <claim_6Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_7(_) => <claim_7Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_8(_) => <claim_8Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_9(_) => <claim_9Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_10(_) => <claim_10Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_11(_) => <claim_11Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_12(_) => <claim_12Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_13(_) => <claim_13Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_14(_) => <claim_14Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_15(_) => <claim_15Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_16(_) => <claim_16Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_17(_) => <claim_17Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_18(_) => <claim_18Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_19(_) => <claim_19Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_20(_) => <claim_20Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_21(_) => <claim_21Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_22(_) => <claim_22Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_23(_) => <claim_23Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_24(_) => <claim_24Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_25(_) => <claim_25Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_26(_) => <claim_26Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_27(_) => <claim_27Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_28(_) => <claim_28Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_29(_) => <claim_29Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_30(_) => <claim_30Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_31(_) => <claim_31Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_32(_) => <claim_32Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_33(_) => <claim_33Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_34(_) => <claim_34Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_35(_) => <claim_35Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_36(_) => <claim_36Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_37(_) => <claim_37Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_38(_) => <claim_38Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_39(_) => <claim_39Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_40(_) => <claim_40Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_41(_) => <claim_41Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_42(_) => <claim_42Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_43(_) => <claim_43Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_44(_) => <claim_44Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_45(_) => <claim_45Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_46(_) => <claim_46Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claim_47(_) => <claim_47Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claimAndWithdraw_0(_) => {
                    <claimAndWithdraw_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_1(_) => {
                    <claimAndWithdraw_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_2(_) => {
                    <claimAndWithdraw_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_3(_) => {
                    <claimAndWithdraw_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_4(_) => {
                    <claimAndWithdraw_4Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_5(_) => {
                    <claimAndWithdraw_5Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_6(_) => {
                    <claimAndWithdraw_6Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_7(_) => {
                    <claimAndWithdraw_7Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_8(_) => {
                    <claimAndWithdraw_8Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_9(_) => {
                    <claimAndWithdraw_9Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_10(_) => {
                    <claimAndWithdraw_10Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_11(_) => {
                    <claimAndWithdraw_11Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_12(_) => {
                    <claimAndWithdraw_12Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_13(_) => {
                    <claimAndWithdraw_13Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_14(_) => {
                    <claimAndWithdraw_14Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_15(_) => {
                    <claimAndWithdraw_15Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_16(_) => {
                    <claimAndWithdraw_16Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_17(_) => {
                    <claimAndWithdraw_17Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_18(_) => {
                    <claimAndWithdraw_18Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_19(_) => {
                    <claimAndWithdraw_19Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_20(_) => {
                    <claimAndWithdraw_20Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_21(_) => {
                    <claimAndWithdraw_21Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_22(_) => {
                    <claimAndWithdraw_22Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_23(_) => {
                    <claimAndWithdraw_23Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_24(_) => {
                    <claimAndWithdraw_24Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_25(_) => {
                    <claimAndWithdraw_25Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_26(_) => {
                    <claimAndWithdraw_26Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_27(_) => {
                    <claimAndWithdraw_27Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_28(_) => {
                    <claimAndWithdraw_28Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_29(_) => {
                    <claimAndWithdraw_29Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_30(_) => {
                    <claimAndWithdraw_30Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_31(_) => {
                    <claimAndWithdraw_31Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_32(_) => {
                    <claimAndWithdraw_32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_33(_) => {
                    <claimAndWithdraw_33Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_34(_) => {
                    <claimAndWithdraw_34Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_35(_) => {
                    <claimAndWithdraw_35Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_36(_) => {
                    <claimAndWithdraw_36Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_37(_) => {
                    <claimAndWithdraw_37Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_38(_) => {
                    <claimAndWithdraw_38Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_39(_) => {
                    <claimAndWithdraw_39Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_40(_) => {
                    <claimAndWithdraw_40Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_41(_) => {
                    <claimAndWithdraw_41Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_42(_) => {
                    <claimAndWithdraw_42Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_43(_) => {
                    <claimAndWithdraw_43Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_44(_) => {
                    <claimAndWithdraw_44Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_45(_) => {
                    <claimAndWithdraw_45Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_46(_) => {
                    <claimAndWithdraw_46Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimAndWithdraw_47(_) => {
                    <claimAndWithdraw_47Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::consume(_) => <consumeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::deposit_0(_) => {
                    <deposit_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit_1(_) => {
                    <deposit_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit_2(_) => {
                    <deposit_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit_3(_) => {
                    <deposit_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit_4(_) => {
                    <deposit_4Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit_5(_) => {
                    <deposit_5Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit_6(_) => {
                    <deposit_6Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositAndRegister_0(_) => {
                    <depositAndRegister_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositAndRegister_1(_) => {
                    <depositAndRegister_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositAndRegister_2(_) => {
                    <depositAndRegister_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositAndRegister_3(_) => {
                    <depositAndRegister_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositAndRegister_4(_) => {
                    <depositAndRegister_4Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::disableForcedWithdrawal(_) => {
                    <disableForcedWithdrawalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enableForcedWithdrawal(_) => {
                    <enableForcedWithdrawalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::extsload_0(_) => {
                    <extsload_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::extsload_1(_) => {
                    <extsload_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exttload(_) => <exttloadCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::forcedWithdrawal(_) => {
                    <forcedWithdrawalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getForcedWithdrawalStatus(_) => {
                    <getForcedWithdrawalStatusCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getLockDetails(_) => {
                    <getLockDetailsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRegistrationStatus(_) => {
                    <getRegistrationStatusCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasConsumedAllocatorNonce(_) => {
                    <hasConsumedAllocatorNonceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isOperator(_) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::name_0(_) => <name_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::name_1(_) => <name_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::register_0(_) => {
                    <register_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::register_1(_) => {
                    <register_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setOperator(_) => {
                    <setOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::tokenURI(_) => <tokenURICall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TheCompactCalls>] = &[
                {
                    fn name_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <name_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::name_0)
                    }
                    name_0
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn claimAndWithdraw_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_0)
                    }
                    claimAndWithdraw_0
                },
                {
                    fn claim_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_0)
                    }
                    claim_0
                },
                {
                    fn claimAndWithdraw_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_1)
                    }
                    claimAndWithdraw_1
                },
                {
                    fn name_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <name_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::name_1)
                    }
                    name_1
                },
                {
                    fn claimAndWithdraw_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_2)
                    }
                    claimAndWithdraw_2
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::transfer)
                    }
                    transfer
                },
                {
                    fn claimAndWithdraw_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_3)
                    }
                    claimAndWithdraw_3
                },
                {
                    fn claim_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_1)
                    }
                    claim_1
                },
                {
                    fn claimAndWithdraw_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_4)
                    }
                    claimAndWithdraw_4
                },
                {
                    fn claim_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_2)
                    }
                    claim_2
                },
                {
                    fn deposit_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <deposit_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::deposit_0)
                    }
                    deposit_0
                },
                {
                    fn claim_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_3)
                    }
                    claim_3
                },
                {
                    fn consume(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <consumeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::consume)
                    }
                    consume
                },
                {
                    fn claim_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_4)
                    }
                    claim_4
                },
                {
                    fn claimAndWithdraw_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_5Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_5)
                    }
                    claimAndWithdraw_5
                },
                {
                    fn claimAndWithdraw_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_6Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_6)
                    }
                    claimAndWithdraw_6
                },
                {
                    fn getForcedWithdrawalStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <getForcedWithdrawalStatusCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::getForcedWithdrawalStatus)
                    }
                    getForcedWithdrawalStatus
                },
                {
                    fn claimAndWithdraw_7(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_7Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_7)
                    }
                    claimAndWithdraw_7
                },
                {
                    fn claim_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_5Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_5)
                    }
                    claim_5
                },
                {
                    fn claimAndWithdraw_8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_8Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_8)
                    }
                    claimAndWithdraw_8
                },
                {
                    fn claimAndWithdraw_9(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_9Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_9)
                    }
                    claimAndWithdraw_9
                },
                {
                    fn claim_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_6Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_6)
                    }
                    claim_6
                },
                {
                    fn extsload_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <extsload_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::extsload_0)
                    }
                    extsload_0
                },
                {
                    fn allocatedTransfer_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allocatedTransfer_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allocatedTransfer_0)
                    }
                    allocatedTransfer_0
                },
                {
                    fn claimAndWithdraw_10(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_10Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_10)
                    }
                    claimAndWithdraw_10
                },
                {
                    fn claimAndWithdraw_11(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_11Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_11)
                    }
                    claimAndWithdraw_11
                },
                {
                    fn claimAndWithdraw_12(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_12Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_12)
                    }
                    claimAndWithdraw_12
                },
                {
                    fn allocatedWithdrawal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allocatedWithdrawal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allocatedWithdrawal_0)
                    }
                    allocatedWithdrawal_0
                },
                {
                    fn __registerAllocator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <__registerAllocatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::__registerAllocator)
                    }
                    __registerAllocator
                },
                {
                    fn claimAndWithdraw_13(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_13Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_13)
                    }
                    claimAndWithdraw_13
                },
                {
                    fn claim_7(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_7Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_7)
                    }
                    claim_7
                },
                {
                    fn forcedWithdrawal(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <forcedWithdrawalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::forcedWithdrawal)
                    }
                    forcedWithdrawal
                },
                {
                    fn claimAndWithdraw_14(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_14Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_14)
                    }
                    claimAndWithdraw_14
                },
                {
                    fn register_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <register_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::register_0)
                    }
                    register_0
                },
                {
                    fn claim_8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_8Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_8)
                    }
                    claim_8
                },
                {
                    fn claimAndWithdraw_15(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_15Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_15)
                    }
                    claimAndWithdraw_15
                },
                {
                    fn DOMAIN_SEPARATOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::DOMAIN_SEPARATOR)
                    }
                    DOMAIN_SEPARATOR
                },
                {
                    fn allocatedWithdrawal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allocatedWithdrawal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allocatedWithdrawal_1)
                    }
                    allocatedWithdrawal_1
                },
                {
                    fn claimAndWithdraw_16(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_16Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_16)
                    }
                    claimAndWithdraw_16
                },
                {
                    fn decimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::decimals)
                    }
                    decimals
                },
                {
                    fn register_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <register_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::register_1)
                    }
                    register_1
                },
                {
                    fn claim_9(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_9Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_9)
                    }
                    claim_9
                },
                {
                    fn claim_10(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_10Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_10)
                    }
                    claim_10
                },
                {
                    fn claimAndWithdraw_17(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_17Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_17)
                    }
                    claimAndWithdraw_17
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::approve)
                    }
                    approve
                },
                {
                    fn getRegistrationStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <getRegistrationStatusCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::getRegistrationStatus)
                    }
                    getRegistrationStatus
                },
                {
                    fn claim_11(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_11Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_11)
                    }
                    claim_11
                },
                {
                    fn claimAndWithdraw_18(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_18Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_18)
                    }
                    claimAndWithdraw_18
                },
                {
                    fn claim_12(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_12Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_12)
                    }
                    claim_12
                },
                {
                    fn claim_13(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_13Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_13)
                    }
                    claim_13
                },
                {
                    fn symbol(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::symbol)
                    }
                    symbol
                },
                {
                    fn claimAndWithdraw_19(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_19Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_19)
                    }
                    claimAndWithdraw_19
                },
                {
                    fn deposit_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <deposit_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::deposit_1)
                    }
                    deposit_1
                },
                {
                    fn depositAndRegister_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <depositAndRegister_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::depositAndRegister_0)
                    }
                    depositAndRegister_0
                },
                {
                    fn claimAndWithdraw_20(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_20)
                    }
                    claimAndWithdraw_20
                },
                {
                    fn setOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <setOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::setOperator)
                    }
                    setOperator
                },
                {
                    fn claim_14(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_14Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_14)
                    }
                    claim_14
                },
                {
                    fn claim_15(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_15Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_15)
                    }
                    claim_15
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allowance)
                    }
                    allowance
                },
                {
                    fn claim_16(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_16Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_16)
                    }
                    claim_16
                },
                {
                    fn getLockDetails(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <getLockDetailsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::getLockDetails)
                    }
                    getLockDetails
                },
                {
                    fn depositAndRegister_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <depositAndRegister_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::depositAndRegister_1)
                    }
                    depositAndRegister_1
                },
                {
                    fn claimAndWithdraw_21(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_21Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_21)
                    }
                    claimAndWithdraw_21
                },
                {
                    fn claim_17(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_17Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_17)
                    }
                    claim_17
                },
                {
                    fn claimAndWithdraw_22(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_22Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_22)
                    }
                    claimAndWithdraw_22
                },
                {
                    fn claim_18(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_18Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_18)
                    }
                    claim_18
                },
                {
                    fn claimAndWithdraw_23(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_23Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_23)
                    }
                    claimAndWithdraw_23
                },
                {
                    fn deposit_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <deposit_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::deposit_2)
                    }
                    deposit_2
                },
                {
                    fn allocatedWithdrawal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allocatedWithdrawal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allocatedWithdrawal_2)
                    }
                    allocatedWithdrawal_2
                },
                {
                    fn claim_19(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_19Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_19)
                    }
                    claim_19
                },
                {
                    fn disableForcedWithdrawal(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <disableForcedWithdrawalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::disableForcedWithdrawal)
                    }
                    disableForcedWithdrawal
                },
                {
                    fn allocatedTransfer_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allocatedTransfer_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allocatedTransfer_1)
                    }
                    allocatedTransfer_1
                },
                {
                    fn claimAndWithdraw_24(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_24Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_24)
                    }
                    claimAndWithdraw_24
                },
                {
                    fn claimAndWithdraw_25(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_25Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_25)
                    }
                    claimAndWithdraw_25
                },
                {
                    fn __activateTstore(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <__activateTstoreCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::__activateTstore)
                    }
                    __activateTstore
                },
                {
                    fn claimAndWithdraw_26(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_26Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_26)
                    }
                    claimAndWithdraw_26
                },
                {
                    fn deposit_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <deposit_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::deposit_3)
                    }
                    deposit_3
                },
                {
                    fn claimAndWithdraw_27(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_27Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_27)
                    }
                    claimAndWithdraw_27
                },
                {
                    fn claim_20(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_20)
                    }
                    claim_20
                },
                {
                    fn claimAndWithdraw_28(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_28Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_28)
                    }
                    claimAndWithdraw_28
                },
                {
                    fn claimAndWithdraw_29(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_29Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_29)
                    }
                    claimAndWithdraw_29
                },
                {
                    fn claimAndWithdraw_30(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_30Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_30)
                    }
                    claimAndWithdraw_30
                },
                {
                    fn claim_21(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_21Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_21)
                    }
                    claim_21
                },
                {
                    fn claim_22(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_22Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_22)
                    }
                    claim_22
                },
                {
                    fn claim_23(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_23Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_23)
                    }
                    claim_23
                },
                {
                    fn deposit_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <deposit_4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::deposit_4)
                    }
                    deposit_4
                },
                {
                    fn claim_24(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_24Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_24)
                    }
                    claim_24
                },
                {
                    fn allocatedTransfer_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allocatedTransfer_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allocatedTransfer_2)
                    }
                    allocatedTransfer_2
                },
                {
                    fn claim_25(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_25Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_25)
                    }
                    claim_25
                },
                {
                    fn claim_26(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_26Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_26)
                    }
                    claim_26
                },
                {
                    fn depositAndRegister_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <depositAndRegister_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::depositAndRegister_2)
                    }
                    depositAndRegister_2
                },
                {
                    fn claimAndWithdraw_31(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_31Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_31)
                    }
                    claimAndWithdraw_31
                },
                {
                    fn claim_27(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_27Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_27)
                    }
                    claim_27
                },
                {
                    fn claim_28(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_28Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_28)
                    }
                    claim_28
                },
                {
                    fn claim_29(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_29Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_29)
                    }
                    claim_29
                },
                {
                    fn claim_30(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_30Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_30)
                    }
                    claim_30
                },
                {
                    fn claimAndWithdraw_32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_32)
                    }
                    claimAndWithdraw_32
                },
                {
                    fn isOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <isOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::isOperator)
                    }
                    isOperator
                },
                {
                    fn claim_31(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_31Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_31)
                    }
                    claim_31
                },
                {
                    fn claim_32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_32)
                    }
                    claim_32
                },
                {
                    fn claimAndWithdraw_33(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_33Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_33)
                    }
                    claimAndWithdraw_33
                },
                {
                    fn claimAndWithdraw_34(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_34Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_34)
                    }
                    claimAndWithdraw_34
                },
                {
                    fn deposit_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <deposit_5Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::deposit_5)
                    }
                    deposit_5
                },
                {
                    fn tokenURI(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <tokenURICall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::tokenURI)
                    }
                    tokenURI
                },
                {
                    fn claimAndWithdraw_35(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_35Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_35)
                    }
                    claimAndWithdraw_35
                },
                {
                    fn claim_33(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_33Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_33)
                    }
                    claim_33
                },
                {
                    fn claimAndWithdraw_36(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_36Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_36)
                    }
                    claimAndWithdraw_36
                },
                {
                    fn claim_34(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_34Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_34)
                    }
                    claim_34
                },
                {
                    fn claim_35(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_35Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_35)
                    }
                    claim_35
                },
                {
                    fn claimAndWithdraw_37(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_37Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_37)
                    }
                    claimAndWithdraw_37
                },
                {
                    fn claimAndWithdraw_38(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_38Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_38)
                    }
                    claimAndWithdraw_38
                },
                {
                    fn depositAndRegister_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <depositAndRegister_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::depositAndRegister_3)
                    }
                    depositAndRegister_3
                },
                {
                    fn hasConsumedAllocatorNonce(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <hasConsumedAllocatorNonceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::hasConsumedAllocatorNonce)
                    }
                    hasConsumedAllocatorNonce
                },
                {
                    fn claim_36(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_36Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_36)
                    }
                    claim_36
                },
                {
                    fn extsload_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <extsload_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::extsload_1)
                    }
                    extsload_1
                },
                {
                    fn allocatedTransfer_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allocatedTransfer_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allocatedTransfer_3)
                    }
                    allocatedTransfer_3
                },
                {
                    fn claim_37(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_37Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_37)
                    }
                    claim_37
                },
                {
                    fn claimAndWithdraw_39(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_39Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_39)
                    }
                    claimAndWithdraw_39
                },
                {
                    fn claim_38(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_38Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_38)
                    }
                    claim_38
                },
                {
                    fn claim_39(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_39Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_39)
                    }
                    claim_39
                },
                {
                    fn claim_40(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_40Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_40)
                    }
                    claim_40
                },
                {
                    fn claim_41(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_41Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_41)
                    }
                    claim_41
                },
                {
                    fn claimAndWithdraw_40(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_40Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_40)
                    }
                    claimAndWithdraw_40
                },
                {
                    fn enableForcedWithdrawal(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <enableForcedWithdrawalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::enableForcedWithdrawal)
                    }
                    enableForcedWithdrawal
                },
                {
                    fn claim_42(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_42Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_42)
                    }
                    claim_42
                },
                {
                    fn claim_43(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_43Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_43)
                    }
                    claim_43
                },
                {
                    fn depositAndRegister_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <depositAndRegister_4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::depositAndRegister_4)
                    }
                    depositAndRegister_4
                },
                {
                    fn claimAndWithdraw_41(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_41Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_41)
                    }
                    claimAndWithdraw_41
                },
                {
                    fn claim_44(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_44Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_44)
                    }
                    claim_44
                },
                {
                    fn claimAndWithdraw_42(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_42Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_42)
                    }
                    claimAndWithdraw_42
                },
                {
                    fn exttload(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <exttloadCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::exttload)
                    }
                    exttload
                },
                {
                    fn claimAndWithdraw_43(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_43Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_43)
                    }
                    claimAndWithdraw_43
                },
                {
                    fn claimAndWithdraw_44(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_44Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_44)
                    }
                    claimAndWithdraw_44
                },
                {
                    fn deposit_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <deposit_6Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::deposit_6)
                    }
                    deposit_6
                },
                {
                    fn claimAndWithdraw_45(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_45Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_45)
                    }
                    claimAndWithdraw_45
                },
                {
                    fn claim_45(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_45Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_45)
                    }
                    claim_45
                },
                {
                    fn claimAndWithdraw_46(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_46Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_46)
                    }
                    claimAndWithdraw_46
                },
                {
                    fn claim_46(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_46Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_46)
                    }
                    claim_46
                },
                {
                    fn claim_47(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claim_47Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claim_47)
                    }
                    claim_47
                },
                {
                    fn claimAndWithdraw_47(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <claimAndWithdraw_47Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::claimAndWithdraw_47)
                    }
                    claimAndWithdraw_47
                },
                {
                    fn allocatedWithdrawal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <allocatedWithdrawal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::allocatedWithdrawal_3)
                    }
                    allocatedWithdrawal_3
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactCalls::transferFrom)
                    }
                    transferFrom
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::__activateTstore(inner) => {
                    <__activateTstoreCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::__registerAllocator(inner) => {
                    <__registerAllocatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocatedTransfer_0(inner) => {
                    <allocatedTransfer_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocatedTransfer_1(inner) => {
                    <allocatedTransfer_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocatedTransfer_2(inner) => {
                    <allocatedTransfer_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocatedTransfer_3(inner) => {
                    <allocatedTransfer_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocatedWithdrawal_0(inner) => {
                    <allocatedWithdrawal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocatedWithdrawal_1(inner) => {
                    <allocatedWithdrawal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocatedWithdrawal_2(inner) => {
                    <allocatedWithdrawal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocatedWithdrawal_3(inner) => {
                    <allocatedWithdrawal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_0(inner) => {
                    <claim_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_1(inner) => {
                    <claim_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_2(inner) => {
                    <claim_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_3(inner) => {
                    <claim_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_4(inner) => {
                    <claim_4Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_5(inner) => {
                    <claim_5Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_6(inner) => {
                    <claim_6Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_7(inner) => {
                    <claim_7Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_8(inner) => {
                    <claim_8Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_9(inner) => {
                    <claim_9Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_10(inner) => {
                    <claim_10Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_11(inner) => {
                    <claim_11Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_12(inner) => {
                    <claim_12Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_13(inner) => {
                    <claim_13Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_14(inner) => {
                    <claim_14Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_15(inner) => {
                    <claim_15Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_16(inner) => {
                    <claim_16Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_17(inner) => {
                    <claim_17Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_18(inner) => {
                    <claim_18Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_19(inner) => {
                    <claim_19Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_20(inner) => {
                    <claim_20Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_21(inner) => {
                    <claim_21Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_22(inner) => {
                    <claim_22Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_23(inner) => {
                    <claim_23Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_24(inner) => {
                    <claim_24Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_25(inner) => {
                    <claim_25Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_26(inner) => {
                    <claim_26Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_27(inner) => {
                    <claim_27Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_28(inner) => {
                    <claim_28Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_29(inner) => {
                    <claim_29Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_30(inner) => {
                    <claim_30Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_31(inner) => {
                    <claim_31Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_32(inner) => {
                    <claim_32Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_33(inner) => {
                    <claim_33Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_34(inner) => {
                    <claim_34Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_35(inner) => {
                    <claim_35Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_36(inner) => {
                    <claim_36Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_37(inner) => {
                    <claim_37Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_38(inner) => {
                    <claim_38Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_39(inner) => {
                    <claim_39Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_40(inner) => {
                    <claim_40Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_41(inner) => {
                    <claim_41Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_42(inner) => {
                    <claim_42Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_43(inner) => {
                    <claim_43Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_44(inner) => {
                    <claim_44Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_45(inner) => {
                    <claim_45Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_46(inner) => {
                    <claim_46Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claim_47(inner) => {
                    <claim_47Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claimAndWithdraw_0(inner) => {
                    <claimAndWithdraw_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_1(inner) => {
                    <claimAndWithdraw_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_2(inner) => {
                    <claimAndWithdraw_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_3(inner) => {
                    <claimAndWithdraw_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_4(inner) => {
                    <claimAndWithdraw_4Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_5(inner) => {
                    <claimAndWithdraw_5Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_6(inner) => {
                    <claimAndWithdraw_6Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_7(inner) => {
                    <claimAndWithdraw_7Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_8(inner) => {
                    <claimAndWithdraw_8Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_9(inner) => {
                    <claimAndWithdraw_9Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_10(inner) => {
                    <claimAndWithdraw_10Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_11(inner) => {
                    <claimAndWithdraw_11Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_12(inner) => {
                    <claimAndWithdraw_12Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_13(inner) => {
                    <claimAndWithdraw_13Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_14(inner) => {
                    <claimAndWithdraw_14Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_15(inner) => {
                    <claimAndWithdraw_15Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_16(inner) => {
                    <claimAndWithdraw_16Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_17(inner) => {
                    <claimAndWithdraw_17Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_18(inner) => {
                    <claimAndWithdraw_18Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_19(inner) => {
                    <claimAndWithdraw_19Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_20(inner) => {
                    <claimAndWithdraw_20Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_21(inner) => {
                    <claimAndWithdraw_21Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_22(inner) => {
                    <claimAndWithdraw_22Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_23(inner) => {
                    <claimAndWithdraw_23Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_24(inner) => {
                    <claimAndWithdraw_24Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_25(inner) => {
                    <claimAndWithdraw_25Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_26(inner) => {
                    <claimAndWithdraw_26Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_27(inner) => {
                    <claimAndWithdraw_27Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_28(inner) => {
                    <claimAndWithdraw_28Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_29(inner) => {
                    <claimAndWithdraw_29Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_30(inner) => {
                    <claimAndWithdraw_30Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_31(inner) => {
                    <claimAndWithdraw_31Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_32(inner) => {
                    <claimAndWithdraw_32Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_33(inner) => {
                    <claimAndWithdraw_33Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_34(inner) => {
                    <claimAndWithdraw_34Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_35(inner) => {
                    <claimAndWithdraw_35Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_36(inner) => {
                    <claimAndWithdraw_36Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_37(inner) => {
                    <claimAndWithdraw_37Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_38(inner) => {
                    <claimAndWithdraw_38Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_39(inner) => {
                    <claimAndWithdraw_39Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_40(inner) => {
                    <claimAndWithdraw_40Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_41(inner) => {
                    <claimAndWithdraw_41Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_42(inner) => {
                    <claimAndWithdraw_42Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_43(inner) => {
                    <claimAndWithdraw_43Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_44(inner) => {
                    <claimAndWithdraw_44Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_45(inner) => {
                    <claimAndWithdraw_45Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_46(inner) => {
                    <claimAndWithdraw_46Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimAndWithdraw_47(inner) => {
                    <claimAndWithdraw_47Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::consume(inner) => {
                    <consumeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::deposit_0(inner) => {
                    <deposit_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::deposit_1(inner) => {
                    <deposit_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::deposit_2(inner) => {
                    <deposit_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::deposit_3(inner) => {
                    <deposit_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::deposit_4(inner) => {
                    <deposit_4Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::deposit_5(inner) => {
                    <deposit_5Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::deposit_6(inner) => {
                    <deposit_6Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::depositAndRegister_0(inner) => {
                    <depositAndRegister_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositAndRegister_1(inner) => {
                    <depositAndRegister_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositAndRegister_2(inner) => {
                    <depositAndRegister_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositAndRegister_3(inner) => {
                    <depositAndRegister_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositAndRegister_4(inner) => {
                    <depositAndRegister_4Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::disableForcedWithdrawal(inner) => {
                    <disableForcedWithdrawalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enableForcedWithdrawal(inner) => {
                    <enableForcedWithdrawalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::extsload_0(inner) => {
                    <extsload_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::extsload_1(inner) => {
                    <extsload_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::exttload(inner) => {
                    <exttloadCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::forcedWithdrawal(inner) => {
                    <forcedWithdrawalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getForcedWithdrawalStatus(inner) => {
                    <getForcedWithdrawalStatusCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getLockDetails(inner) => {
                    <getLockDetailsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRegistrationStatus(inner) => {
                    <getRegistrationStatusCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hasConsumedAllocatorNonce(inner) => {
                    <hasConsumedAllocatorNonceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isOperator(inner) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::name_0(inner) => {
                    <name_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::name_1(inner) => {
                    <name_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::register_0(inner) => {
                    <register_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::register_1(inner) => {
                    <register_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setOperator(inner) => {
                    <setOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::tokenURI(inner) => {
                    <tokenURICall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::__activateTstore(inner) => {
                    <__activateTstoreCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::__registerAllocator(inner) => {
                    <__registerAllocatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocatedTransfer_0(inner) => {
                    <allocatedTransfer_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocatedTransfer_1(inner) => {
                    <allocatedTransfer_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocatedTransfer_2(inner) => {
                    <allocatedTransfer_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocatedTransfer_3(inner) => {
                    <allocatedTransfer_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocatedWithdrawal_0(inner) => {
                    <allocatedWithdrawal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocatedWithdrawal_1(inner) => {
                    <allocatedWithdrawal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocatedWithdrawal_2(inner) => {
                    <allocatedWithdrawal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocatedWithdrawal_3(inner) => {
                    <allocatedWithdrawal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_0(inner) => {
                    <claim_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_1(inner) => {
                    <claim_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_2(inner) => {
                    <claim_2Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_3(inner) => {
                    <claim_3Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_4(inner) => {
                    <claim_4Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_5(inner) => {
                    <claim_5Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_6(inner) => {
                    <claim_6Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_7(inner) => {
                    <claim_7Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_8(inner) => {
                    <claim_8Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_9(inner) => {
                    <claim_9Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claim_10(inner) => {
                    <claim_10Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_11(inner) => {
                    <claim_11Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_12(inner) => {
                    <claim_12Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_13(inner) => {
                    <claim_13Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_14(inner) => {
                    <claim_14Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_15(inner) => {
                    <claim_15Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_16(inner) => {
                    <claim_16Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_17(inner) => {
                    <claim_17Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_18(inner) => {
                    <claim_18Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_19(inner) => {
                    <claim_19Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_20(inner) => {
                    <claim_20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_21(inner) => {
                    <claim_21Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_22(inner) => {
                    <claim_22Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_23(inner) => {
                    <claim_23Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_24(inner) => {
                    <claim_24Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_25(inner) => {
                    <claim_25Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_26(inner) => {
                    <claim_26Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_27(inner) => {
                    <claim_27Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_28(inner) => {
                    <claim_28Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_29(inner) => {
                    <claim_29Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_30(inner) => {
                    <claim_30Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_31(inner) => {
                    <claim_31Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_32(inner) => {
                    <claim_32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_33(inner) => {
                    <claim_33Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_34(inner) => {
                    <claim_34Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_35(inner) => {
                    <claim_35Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_36(inner) => {
                    <claim_36Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_37(inner) => {
                    <claim_37Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_38(inner) => {
                    <claim_38Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_39(inner) => {
                    <claim_39Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_40(inner) => {
                    <claim_40Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_41(inner) => {
                    <claim_41Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_42(inner) => {
                    <claim_42Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_43(inner) => {
                    <claim_43Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_44(inner) => {
                    <claim_44Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_45(inner) => {
                    <claim_45Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_46(inner) => {
                    <claim_46Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claim_47(inner) => {
                    <claim_47Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_0(inner) => {
                    <claimAndWithdraw_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_1(inner) => {
                    <claimAndWithdraw_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_2(inner) => {
                    <claimAndWithdraw_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_3(inner) => {
                    <claimAndWithdraw_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_4(inner) => {
                    <claimAndWithdraw_4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_5(inner) => {
                    <claimAndWithdraw_5Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_6(inner) => {
                    <claimAndWithdraw_6Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_7(inner) => {
                    <claimAndWithdraw_7Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_8(inner) => {
                    <claimAndWithdraw_8Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_9(inner) => {
                    <claimAndWithdraw_9Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_10(inner) => {
                    <claimAndWithdraw_10Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_11(inner) => {
                    <claimAndWithdraw_11Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_12(inner) => {
                    <claimAndWithdraw_12Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_13(inner) => {
                    <claimAndWithdraw_13Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_14(inner) => {
                    <claimAndWithdraw_14Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_15(inner) => {
                    <claimAndWithdraw_15Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_16(inner) => {
                    <claimAndWithdraw_16Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_17(inner) => {
                    <claimAndWithdraw_17Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_18(inner) => {
                    <claimAndWithdraw_18Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_19(inner) => {
                    <claimAndWithdraw_19Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_20(inner) => {
                    <claimAndWithdraw_20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_21(inner) => {
                    <claimAndWithdraw_21Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_22(inner) => {
                    <claimAndWithdraw_22Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_23(inner) => {
                    <claimAndWithdraw_23Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_24(inner) => {
                    <claimAndWithdraw_24Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_25(inner) => {
                    <claimAndWithdraw_25Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_26(inner) => {
                    <claimAndWithdraw_26Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_27(inner) => {
                    <claimAndWithdraw_27Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_28(inner) => {
                    <claimAndWithdraw_28Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_29(inner) => {
                    <claimAndWithdraw_29Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_30(inner) => {
                    <claimAndWithdraw_30Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_31(inner) => {
                    <claimAndWithdraw_31Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_32(inner) => {
                    <claimAndWithdraw_32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_33(inner) => {
                    <claimAndWithdraw_33Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_34(inner) => {
                    <claimAndWithdraw_34Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_35(inner) => {
                    <claimAndWithdraw_35Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_36(inner) => {
                    <claimAndWithdraw_36Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_37(inner) => {
                    <claimAndWithdraw_37Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_38(inner) => {
                    <claimAndWithdraw_38Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_39(inner) => {
                    <claimAndWithdraw_39Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_40(inner) => {
                    <claimAndWithdraw_40Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_41(inner) => {
                    <claimAndWithdraw_41Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_42(inner) => {
                    <claimAndWithdraw_42Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_43(inner) => {
                    <claimAndWithdraw_43Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_44(inner) => {
                    <claimAndWithdraw_44Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_45(inner) => {
                    <claimAndWithdraw_45Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_46(inner) => {
                    <claimAndWithdraw_46Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimAndWithdraw_47(inner) => {
                    <claimAndWithdraw_47Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::consume(inner) => {
                    <consumeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit_0(inner) => {
                    <deposit_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit_1(inner) => {
                    <deposit_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit_2(inner) => {
                    <deposit_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit_3(inner) => {
                    <deposit_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit_4(inner) => {
                    <deposit_4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit_5(inner) => {
                    <deposit_5Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit_6(inner) => {
                    <deposit_6Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositAndRegister_0(inner) => {
                    <depositAndRegister_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositAndRegister_1(inner) => {
                    <depositAndRegister_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositAndRegister_2(inner) => {
                    <depositAndRegister_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositAndRegister_3(inner) => {
                    <depositAndRegister_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositAndRegister_4(inner) => {
                    <depositAndRegister_4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::disableForcedWithdrawal(inner) => {
                    <disableForcedWithdrawalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enableForcedWithdrawal(inner) => {
                    <enableForcedWithdrawalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::extsload_0(inner) => {
                    <extsload_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::extsload_1(inner) => {
                    <extsload_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exttload(inner) => {
                    <exttloadCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::forcedWithdrawal(inner) => {
                    <forcedWithdrawalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getForcedWithdrawalStatus(inner) => {
                    <getForcedWithdrawalStatusCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getLockDetails(inner) => {
                    <getLockDetailsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRegistrationStatus(inner) => {
                    <getRegistrationStatusCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasConsumedAllocatorNonce(inner) => {
                    <hasConsumedAllocatorNonceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isOperator(inner) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::name_0(inner) => {
                    <name_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::name_1(inner) => {
                    <name_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::register_0(inner) => {
                    <register_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::register_1(inner) => {
                    <register_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setOperator(inner) => {
                    <setOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::tokenURI(inner) => {
                    <tokenURICall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TheCompact`](self) custom errors.
    pub enum TheCompactErrors {
        AllocatedAmountExceeded(AllocatedAmountExceeded),
        BalanceOverflow(BalanceOverflow),
        Expired(Expired),
        ForcedWithdrawalAlreadyDisabled(ForcedWithdrawalAlreadyDisabled),
        InsufficientBalance(InsufficientBalance),
        InsufficientPermission(InsufficientPermission),
        InvalidBatchAllocation(InvalidBatchAllocation),
        InvalidBatchDepositStructure(InvalidBatchDepositStructure),
        InvalidDepositBalanceChange(InvalidDepositBalanceChange),
        InvalidDepositTokenOrdering(InvalidDepositTokenOrdering),
        InvalidRegistrationDuration(InvalidRegistrationDuration),
        InvalidRegistrationProof(InvalidRegistrationProof),
        InvalidScope(InvalidScope),
        InvalidSignature(InvalidSignature),
        InvalidToken(InvalidToken),
        OnlyDirectCalls(OnlyDirectCalls),
        Permit2CallFailed(Permit2CallFailed),
        PrematureWithdrawal(PrematureWithdrawal),
        ReentrantCall(ReentrantCall),
        TStoreAlreadyActivated(TStoreAlreadyActivated),
        TStoreNotSupported(TStoreNotSupported),
        TloadTestContractDeploymentFailed(TloadTestContractDeploymentFailed),
        UnallocatedTransfer(UnallocatedTransfer),
    }
    #[automatically_derived]
    impl TheCompactErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 76u8, 147u8, 16u8],
            [15u8, 47u8, 30u8, 81u8],
            [31u8, 154u8, 150u8, 244u8],
            [37u8, 153u8, 67u8, 20u8],
            [42u8, 234u8, 88u8, 135u8],
            [48u8, 120u8, 178u8, 246u8],
            [58u8, 3u8, 211u8, 187u8],
            [66u8, 109u8, 141u8, 207u8],
            [78u8, 127u8, 73u8, 43u8],
            [112u8, 164u8, 7u8, 143u8],
            [127u8, 40u8, 198u8, 30u8],
            [137u8, 86u8, 12u8, 161u8],
            [139u8, 170u8, 87u8, 159u8],
            [146u8, 135u8, 188u8, 176u8],
            [150u8, 28u8, 154u8, 79u8],
            [160u8, 99u8, 86u8, 245u8],
            [202u8, 15u8, 192u8, 142u8],
            [222u8, 218u8, 144u8, 48u8],
            [230u8, 50u8, 219u8, 173u8],
            [244u8, 91u8, 152u8, 176u8],
            [244u8, 214u8, 120u8, 184u8],
            [245u8, 124u8, 68u8, 139u8],
            [248u8, 13u8, 186u8, 234u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TheCompactErrors {
        const NAME: &'static str = "TheCompactErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 23usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AllocatedAmountExceeded(_) => {
                    <AllocatedAmountExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BalanceOverflow(_) => {
                    <BalanceOverflow as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Expired(_) => <Expired as alloy_sol_types::SolError>::SELECTOR,
                Self::ForcedWithdrawalAlreadyDisabled(_) => {
                    <ForcedWithdrawalAlreadyDisabled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientPermission(_) => {
                    <InsufficientPermission as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidBatchAllocation(_) => {
                    <InvalidBatchAllocation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidBatchDepositStructure(_) => {
                    <InvalidBatchDepositStructure as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDepositBalanceChange(_) => {
                    <InvalidDepositBalanceChange as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDepositTokenOrdering(_) => {
                    <InvalidDepositTokenOrdering as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidRegistrationDuration(_) => {
                    <InvalidRegistrationDuration as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidRegistrationProof(_) => {
                    <InvalidRegistrationProof as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidScope(_) => {
                    <InvalidScope as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSignature(_) => {
                    <InvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidToken(_) => {
                    <InvalidToken as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OnlyDirectCalls(_) => {
                    <OnlyDirectCalls as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Permit2CallFailed(_) => {
                    <Permit2CallFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PrematureWithdrawal(_) => {
                    <PrematureWithdrawal as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrantCall(_) => {
                    <ReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TStoreAlreadyActivated(_) => {
                    <TStoreAlreadyActivated as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TStoreNotSupported(_) => {
                    <TStoreNotSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TloadTestContractDeploymentFailed(_) => {
                    <TloadTestContractDeploymentFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnallocatedTransfer(_) => {
                    <UnallocatedTransfer as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TheCompactErrors>] = &[
                {
                    fn UnallocatedTransfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <UnallocatedTransfer as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::UnallocatedTransfer)
                    }
                    UnallocatedTransfer
                },
                {
                    fn InvalidDepositTokenOrdering(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidDepositTokenOrdering as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidDepositTokenOrdering)
                    }
                    InvalidDepositTokenOrdering
                },
                {
                    fn InvalidRegistrationDuration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidRegistrationDuration as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidRegistrationDuration)
                    }
                    InvalidRegistrationDuration
                },
                {
                    fn OnlyDirectCalls(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <OnlyDirectCalls as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::OnlyDirectCalls)
                    }
                    OnlyDirectCalls
                },
                {
                    fn TloadTestContractDeploymentFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <TloadTestContractDeploymentFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::TloadTestContractDeploymentFailed)
                    }
                    TloadTestContractDeploymentFailed
                },
                {
                    fn AllocatedAmountExceeded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <AllocatedAmountExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::AllocatedAmountExceeded)
                    }
                    AllocatedAmountExceeded
                },
                {
                    fn InvalidBatchAllocation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidBatchAllocation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidBatchAllocation)
                    }
                    InvalidBatchAllocation
                },
                {
                    fn InvalidDepositBalanceChange(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidDepositBalanceChange as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidDepositBalanceChange)
                    }
                    InvalidDepositBalanceChange
                },
                {
                    fn InvalidRegistrationProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidRegistrationProof as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidRegistrationProof)
                    }
                    InvalidRegistrationProof
                },
                {
                    fn TStoreNotSupported(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <TStoreNotSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::TStoreNotSupported)
                    }
                    TStoreNotSupported
                },
                {
                    fn Permit2CallFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <Permit2CallFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::Permit2CallFailed)
                    }
                    Permit2CallFailed
                },
                {
                    fn BalanceOverflow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <BalanceOverflow as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::BalanceOverflow)
                    }
                    BalanceOverflow
                },
                {
                    fn InvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidSignature)
                    }
                    InvalidSignature
                },
                {
                    fn PrematureWithdrawal(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <PrematureWithdrawal as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::PrematureWithdrawal)
                    }
                    PrematureWithdrawal
                },
                {
                    fn InvalidToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidToken as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidToken)
                    }
                    InvalidToken
                },
                {
                    fn InvalidScope(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidScope as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidScope)
                    }
                    InvalidScope
                },
                {
                    fn InvalidBatchDepositStructure(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InvalidBatchDepositStructure as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InvalidBatchDepositStructure)
                    }
                    InvalidBatchDepositStructure
                },
                {
                    fn InsufficientPermission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InsufficientPermission as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InsufficientPermission)
                    }
                    InsufficientPermission
                },
                {
                    fn ForcedWithdrawalAlreadyDisabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <ForcedWithdrawalAlreadyDisabled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::ForcedWithdrawalAlreadyDisabled)
                    }
                    ForcedWithdrawalAlreadyDisabled
                },
                {
                    fn TStoreAlreadyActivated(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <TStoreAlreadyActivated as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::TStoreAlreadyActivated)
                    }
                    TStoreAlreadyActivated
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn ReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <ReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::ReentrantCall)
                    }
                    ReentrantCall
                },
                {
                    fn Expired(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TheCompactErrors> {
                        <Expired as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TheCompactErrors::Expired)
                    }
                    Expired
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AllocatedAmountExceeded(inner) => {
                    <AllocatedAmountExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BalanceOverflow(inner) => {
                    <BalanceOverflow as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Expired(inner) => {
                    <Expired as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ForcedWithdrawalAlreadyDisabled(inner) => {
                    <ForcedWithdrawalAlreadyDisabled as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientPermission(inner) => {
                    <InsufficientPermission as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidBatchAllocation(inner) => {
                    <InvalidBatchAllocation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidBatchDepositStructure(inner) => {
                    <InvalidBatchDepositStructure as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDepositBalanceChange(inner) => {
                    <InvalidDepositBalanceChange as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDepositTokenOrdering(inner) => {
                    <InvalidDepositTokenOrdering as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidRegistrationDuration(inner) => {
                    <InvalidRegistrationDuration as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidRegistrationProof(inner) => {
                    <InvalidRegistrationProof as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidScope(inner) => {
                    <InvalidScope as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidSignature(inner) => {
                    <InvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidToken(inner) => {
                    <InvalidToken as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::OnlyDirectCalls(inner) => {
                    <OnlyDirectCalls as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Permit2CallFailed(inner) => {
                    <Permit2CallFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PrematureWithdrawal(inner) => {
                    <PrematureWithdrawal as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrantCall(inner) => {
                    <ReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::TStoreAlreadyActivated(inner) => {
                    <TStoreAlreadyActivated as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TStoreNotSupported(inner) => {
                    <TStoreNotSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TloadTestContractDeploymentFailed(inner) => {
                    <TloadTestContractDeploymentFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnallocatedTransfer(inner) => {
                    <UnallocatedTransfer as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AllocatedAmountExceeded(inner) => {
                    <AllocatedAmountExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BalanceOverflow(inner) => {
                    <BalanceOverflow as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Expired(inner) => {
                    <Expired as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::ForcedWithdrawalAlreadyDisabled(inner) => {
                    <ForcedWithdrawalAlreadyDisabled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientPermission(inner) => {
                    <InsufficientPermission as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidBatchAllocation(inner) => {
                    <InvalidBatchAllocation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidBatchDepositStructure(inner) => {
                    <InvalidBatchDepositStructure as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDepositBalanceChange(inner) => {
                    <InvalidDepositBalanceChange as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDepositTokenOrdering(inner) => {
                    <InvalidDepositTokenOrdering as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidRegistrationDuration(inner) => {
                    <InvalidRegistrationDuration as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidRegistrationProof(inner) => {
                    <InvalidRegistrationProof as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidScope(inner) => {
                    <InvalidScope as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSignature(inner) => {
                    <InvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidToken(inner) => {
                    <InvalidToken as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OnlyDirectCalls(inner) => {
                    <OnlyDirectCalls as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Permit2CallFailed(inner) => {
                    <Permit2CallFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PrematureWithdrawal(inner) => {
                    <PrematureWithdrawal as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrantCall(inner) => {
                    <ReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TStoreAlreadyActivated(inner) => {
                    <TStoreAlreadyActivated as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TStoreNotSupported(inner) => {
                    <TStoreNotSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TloadTestContractDeploymentFailed(inner) => {
                    <TloadTestContractDeploymentFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnallocatedTransfer(inner) => {
                    <UnallocatedTransfer as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TheCompact`](self) events.
    pub enum TheCompactEvents {
        AllocatorRegistered(AllocatorRegistered),
        Approval(Approval),
        Claim(Claim),
        CompactRegistered(CompactRegistered),
        ForcedWithdrawalStatusUpdated(ForcedWithdrawalStatusUpdated),
        OperatorSet(OperatorSet),
        Transfer(Transfer),
    }
    #[automatically_derived]
    impl TheCompactEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                27u8,
                61u8,
                126u8,
                219u8,
                46u8,
                156u8,
                11u8,
                14u8,
                124u8,
                82u8,
                91u8,
                32u8,
                170u8,
                174u8,
                240u8,
                245u8,
                148u8,
                13u8,
                46u8,
                215u8,
                22u8,
                99u8,
                199u8,
                211u8,
                146u8,
                102u8,
                236u8,
                175u8,
                172u8,
                114u8,
                136u8,
                89u8,
            ],
            [
                119u8,
                12u8,
                50u8,
                162u8,
                49u8,
                75u8,
                112u8,
                13u8,
                98u8,
                57u8,
                238u8,
                53u8,
                186u8,
                35u8,
                169u8,
                105u8,
                15u8,
                47u8,
                206u8,
                185u8,
                58u8,
                85u8,
                216u8,
                199u8,
                83u8,
                233u8,
                83u8,
                5u8,
                155u8,
                59u8,
                24u8,
                212u8,
            ],
            [
                179u8,
                253u8,
                80u8,
                113u8,
                131u8,
                88u8,
                135u8,
                86u8,
                122u8,
                6u8,
                113u8,
                21u8,
                17u8,
                33u8,
                137u8,
                77u8,
                220u8,
                204u8,
                40u8,
                66u8,
                241u8,
                209u8,
                11u8,
                237u8,
                173u8,
                19u8,
                224u8,
                209u8,
                124u8,
                172u8,
                233u8,
                167u8,
            ],
            [
                197u8,
                77u8,
                202u8,
                166u8,
                122u8,
                143u8,
                215u8,
                180u8,
                169u8,
                170u8,
                111u8,
                213u8,
                115u8,
                81u8,
                147u8,
                76u8,
                121u8,
                38u8,
                19u8,
                213u8,
                236u8,
                26u8,
                203u8,
                214u8,
                82u8,
                116u8,
                39u8,
                14u8,
                109u8,
                232u8,
                247u8,
                228u8,
            ],
            [
                206u8,
                181u8,
                118u8,
                217u8,
                241u8,
                94u8,
                78u8,
                32u8,
                15u8,
                219u8,
                80u8,
                150u8,
                214u8,
                77u8,
                93u8,
                253u8,
                102u8,
                126u8,
                22u8,
                222u8,
                242u8,
                12u8,
                30u8,
                239u8,
                209u8,
                66u8,
                86u8,
                216u8,
                227u8,
                250u8,
                162u8,
                103u8,
            ],
            [
                226u8,
                127u8,
                94u8,
                3u8,
                130u8,
                207u8,
                83u8,
                71u8,
                150u8,
                95u8,
                200u8,
                29u8,
                92u8,
                129u8,
                205u8,
                20u8,
                24u8,
                151u8,
                254u8,
                156u8,
                228u8,
                2u8,
                210u8,
                44u8,
                73u8,
                107u8,
                124u8,
                45u8,
                220u8,
                132u8,
                229u8,
                253u8,
            ],
            [
                247u8,
                138u8,
                47u8,
                51u8,
                255u8,
                128u8,
                239u8,
                67u8,
                145u8,
                247u8,
                68u8,
                156u8,
                116u8,
                141u8,
                194u8,
                213u8,
                119u8,
                166u8,
                44u8,
                214u8,
                69u8,
                16u8,
                143u8,
                79u8,
                64u8,
                105u8,
                244u8,
                167u8,
                224u8,
                99u8,
                91u8,
                106u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TheCompactEvents {
        const NAME: &'static str = "TheCompactEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AllocatorRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AllocatorRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AllocatorRegistered)
                }
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(<Claim as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Claim as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Claim)
                }
                Some(
                    <CompactRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <CompactRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CompactRegistered)
                }
                Some(
                    <ForcedWithdrawalStatusUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ForcedWithdrawalStatusUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ForcedWithdrawalStatusUpdated)
                }
                Some(<OperatorSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorSet)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TheCompactEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AllocatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Claim(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CompactRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ForcedWithdrawalStatusUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AllocatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Claim(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CompactRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ForcedWithdrawalStatusUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TheCompact`](self) contract instance.

See the [wrapper's documentation](`TheCompactInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TheCompactInstance<T, P, N> {
        TheCompactInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TheCompactInstance<T, P, N>>,
    > {
        TheCompactInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        TheCompactInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`TheCompact`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TheCompact`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TheCompactInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TheCompactInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TheCompactInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TheCompactInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`TheCompact`](self) contract instance.

See the [wrapper's documentation](`TheCompactInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<TheCompactInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TheCompactInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TheCompactInstance<T, P, N> {
            TheCompactInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TheCompactInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
        pub fn DOMAIN_SEPARATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DOMAIN_SEPARATORCall, N> {
            self.call_builder(&DOMAIN_SEPARATORCall {})
        }
        ///Creates a new call builder for the [`__activateTstore`] function.
        pub fn __activateTstore(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, __activateTstoreCall, N> {
            self.call_builder(&__activateTstoreCall {})
        }
        ///Creates a new call builder for the [`__registerAllocator`] function.
        pub fn __registerAllocator(
            &self,
            allocator: alloy::sol_types::private::Address,
            proof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, __registerAllocatorCall, N> {
            self.call_builder(
                &__registerAllocatorCall {
                    allocator,
                    proof,
                },
            )
        }
        ///Creates a new call builder for the [`allocatedTransfer_0`] function.
        pub fn allocatedTransfer_0(
            &self,
            transfer: <BatchTransfer as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocatedTransfer_0Call, N> {
            self.call_builder(
                &allocatedTransfer_0Call {
                    transfer,
                },
            )
        }
        ///Creates a new call builder for the [`allocatedTransfer_1`] function.
        pub fn allocatedTransfer_1(
            &self,
            transfer: <SplitBatchTransfer as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocatedTransfer_1Call, N> {
            self.call_builder(
                &allocatedTransfer_1Call {
                    transfer,
                },
            )
        }
        ///Creates a new call builder for the [`allocatedTransfer_2`] function.
        pub fn allocatedTransfer_2(
            &self,
            transfer: <SplitTransfer as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocatedTransfer_2Call, N> {
            self.call_builder(
                &allocatedTransfer_2Call {
                    transfer,
                },
            )
        }
        ///Creates a new call builder for the [`allocatedTransfer_3`] function.
        pub fn allocatedTransfer_3(
            &self,
            transfer: <BasicTransfer as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocatedTransfer_3Call, N> {
            self.call_builder(
                &allocatedTransfer_3Call {
                    transfer,
                },
            )
        }
        ///Creates a new call builder for the [`allocatedWithdrawal_0`] function.
        pub fn allocatedWithdrawal_0(
            &self,
            withdrawal: <BasicTransfer as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocatedWithdrawal_0Call, N> {
            self.call_builder(
                &allocatedWithdrawal_0Call {
                    withdrawal,
                },
            )
        }
        ///Creates a new call builder for the [`allocatedWithdrawal_1`] function.
        pub fn allocatedWithdrawal_1(
            &self,
            withdrawal: <SplitBatchTransfer as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocatedWithdrawal_1Call, N> {
            self.call_builder(
                &allocatedWithdrawal_1Call {
                    withdrawal,
                },
            )
        }
        ///Creates a new call builder for the [`allocatedWithdrawal_2`] function.
        pub fn allocatedWithdrawal_2(
            &self,
            withdrawal: <BatchTransfer as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocatedWithdrawal_2Call, N> {
            self.call_builder(
                &allocatedWithdrawal_2Call {
                    withdrawal,
                },
            )
        }
        ///Creates a new call builder for the [`allocatedWithdrawal_3`] function.
        pub fn allocatedWithdrawal_3(
            &self,
            withdrawal: <SplitTransfer as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocatedWithdrawal_3Call, N> {
            self.call_builder(
                &allocatedWithdrawal_3Call {
                    withdrawal,
                },
            )
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(
                &allowanceCall {
                    owner,
                    spender,
                    id,
                },
            )
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, id, amount })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            owner: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { owner, id })
        }
        ///Creates a new call builder for the [`claim_0`] function.
        pub fn claim_0(
            &self,
            claimPayload: <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_0Call, N> {
            self.call_builder(&claim_0Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_1`] function.
        pub fn claim_1(
            &self,
            claimPayload: <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_1Call, N> {
            self.call_builder(&claim_1Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_2`] function.
        pub fn claim_2(
            &self,
            claimPayload: <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_2Call, N> {
            self.call_builder(&claim_2Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_3`] function.
        pub fn claim_3(
            &self,
            claimPayload: <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_3Call, N> {
            self.call_builder(&claim_3Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_4`] function.
        pub fn claim_4(
            &self,
            claimPayload: <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_4Call, N> {
            self.call_builder(&claim_4Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_5`] function.
        pub fn claim_5(
            &self,
            claimPayload: <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_5Call, N> {
            self.call_builder(&claim_5Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_6`] function.
        pub fn claim_6(
            &self,
            claimPayload: <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_6Call, N> {
            self.call_builder(&claim_6Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_7`] function.
        pub fn claim_7(
            &self,
            claimPayload: <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_7Call, N> {
            self.call_builder(&claim_7Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_8`] function.
        pub fn claim_8(
            &self,
            claimPayload: <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_8Call, N> {
            self.call_builder(&claim_8Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_9`] function.
        pub fn claim_9(
            &self,
            claimPayload: <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_9Call, N> {
            self.call_builder(&claim_9Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_10`] function.
        pub fn claim_10(
            &self,
            claimPayload: <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_10Call, N> {
            self.call_builder(&claim_10Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_11`] function.
        pub fn claim_11(
            &self,
            claimPayload: <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_11Call, N> {
            self.call_builder(&claim_11Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_12`] function.
        pub fn claim_12(
            &self,
            claimPayload: <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_12Call, N> {
            self.call_builder(&claim_12Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_13`] function.
        pub fn claim_13(
            &self,
            claimPayload: <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_13Call, N> {
            self.call_builder(&claim_13Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_14`] function.
        pub fn claim_14(
            &self,
            claimPayload: <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_14Call, N> {
            self.call_builder(&claim_14Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_15`] function.
        pub fn claim_15(
            &self,
            claimPayload: <BatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_15Call, N> {
            self.call_builder(&claim_15Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_16`] function.
        pub fn claim_16(
            &self,
            claimPayload: <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_16Call, N> {
            self.call_builder(&claim_16Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_17`] function.
        pub fn claim_17(
            &self,
            claimPayload: <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_17Call, N> {
            self.call_builder(&claim_17Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_18`] function.
        pub fn claim_18(
            &self,
            claimPayload: <QualifiedClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_18Call, N> {
            self.call_builder(&claim_18Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_19`] function.
        pub fn claim_19(
            &self,
            claimPayload: <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_19Call, N> {
            self.call_builder(&claim_19Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_20`] function.
        pub fn claim_20(
            &self,
            claimPayload: <BasicClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_20Call, N> {
            self.call_builder(&claim_20Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_21`] function.
        pub fn claim_21(
            &self,
            claimPayload: <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_21Call, N> {
            self.call_builder(&claim_21Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_22`] function.
        pub fn claim_22(
            &self,
            claimPayload: <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_22Call, N> {
            self.call_builder(&claim_22Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_23`] function.
        pub fn claim_23(
            &self,
            claimPayload: <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_23Call, N> {
            self.call_builder(&claim_23Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_24`] function.
        pub fn claim_24(
            &self,
            claimPayload: <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_24Call, N> {
            self.call_builder(&claim_24Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_25`] function.
        pub fn claim_25(
            &self,
            claimPayload: <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_25Call, N> {
            self.call_builder(&claim_25Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_26`] function.
        pub fn claim_26(
            &self,
            claimPayload: <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_26Call, N> {
            self.call_builder(&claim_26Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_27`] function.
        pub fn claim_27(
            &self,
            claimPayload: <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_27Call, N> {
            self.call_builder(&claim_27Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_28`] function.
        pub fn claim_28(
            &self,
            claimPayload: <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_28Call, N> {
            self.call_builder(&claim_28Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_29`] function.
        pub fn claim_29(
            &self,
            claimPayload: <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_29Call, N> {
            self.call_builder(&claim_29Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_30`] function.
        pub fn claim_30(
            &self,
            claimPayload: <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_30Call, N> {
            self.call_builder(&claim_30Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_31`] function.
        pub fn claim_31(
            &self,
            claimPayload: <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_31Call, N> {
            self.call_builder(&claim_31Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_32`] function.
        pub fn claim_32(
            &self,
            claimPayload: <SplitClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_32Call, N> {
            self.call_builder(&claim_32Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_33`] function.
        pub fn claim_33(
            &self,
            claimPayload: <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_33Call, N> {
            self.call_builder(&claim_33Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_34`] function.
        pub fn claim_34(
            &self,
            claimPayload: <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_34Call, N> {
            self.call_builder(&claim_34Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_35`] function.
        pub fn claim_35(
            &self,
            claimPayload: <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_35Call, N> {
            self.call_builder(&claim_35Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_36`] function.
        pub fn claim_36(
            &self,
            claimPayload: <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_36Call, N> {
            self.call_builder(&claim_36Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_37`] function.
        pub fn claim_37(
            &self,
            claimPayload: <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_37Call, N> {
            self.call_builder(&claim_37Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_38`] function.
        pub fn claim_38(
            &self,
            claimPayload: <MultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_38Call, N> {
            self.call_builder(&claim_38Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_39`] function.
        pub fn claim_39(
            &self,
            claimPayload: <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_39Call, N> {
            self.call_builder(&claim_39Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_40`] function.
        pub fn claim_40(
            &self,
            claimPayload: <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_40Call, N> {
            self.call_builder(&claim_40Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_41`] function.
        pub fn claim_41(
            &self,
            claimPayload: <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_41Call, N> {
            self.call_builder(&claim_41Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_42`] function.
        pub fn claim_42(
            &self,
            claimPayload: <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_42Call, N> {
            self.call_builder(&claim_42Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_43`] function.
        pub fn claim_43(
            &self,
            claimPayload: <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_43Call, N> {
            self.call_builder(&claim_43Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_44`] function.
        pub fn claim_44(
            &self,
            claimPayload: <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_44Call, N> {
            self.call_builder(&claim_44Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_45`] function.
        pub fn claim_45(
            &self,
            claimPayload: <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_45Call, N> {
            self.call_builder(&claim_45Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_46`] function.
        pub fn claim_46(
            &self,
            claimPayload: <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_46Call, N> {
            self.call_builder(&claim_46Call { claimPayload })
        }
        ///Creates a new call builder for the [`claim_47`] function.
        pub fn claim_47(
            &self,
            claimPayload: <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claim_47Call, N> {
            self.call_builder(&claim_47Call { claimPayload })
        }
        ///Creates a new call builder for the [`claimAndWithdraw_0`] function.
        pub fn claimAndWithdraw_0(
            &self,
            claimPayload: <ExogenousQualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_0Call, N> {
            self.call_builder(
                &claimAndWithdraw_0Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_1`] function.
        pub fn claimAndWithdraw_1(
            &self,
            claimPayload: <QualifiedSplitClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_1Call, N> {
            self.call_builder(
                &claimAndWithdraw_1Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_2`] function.
        pub fn claimAndWithdraw_2(
            &self,
            claimPayload: <QualifiedSplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_2Call, N> {
            self.call_builder(
                &claimAndWithdraw_2Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_3`] function.
        pub fn claimAndWithdraw_3(
            &self,
            claimPayload: <QualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_3Call, N> {
            self.call_builder(
                &claimAndWithdraw_3Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_4`] function.
        pub fn claimAndWithdraw_4(
            &self,
            claimPayload: <QualifiedBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_4Call, N> {
            self.call_builder(
                &claimAndWithdraw_4Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_5`] function.
        pub fn claimAndWithdraw_5(
            &self,
            claimPayload: <QualifiedSplitBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_5Call, N> {
            self.call_builder(
                &claimAndWithdraw_5Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_6`] function.
        pub fn claimAndWithdraw_6(
            &self,
            claimPayload: <QualifiedClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_6Call, N> {
            self.call_builder(
                &claimAndWithdraw_6Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_7`] function.
        pub fn claimAndWithdraw_7(
            &self,
            claimPayload: <QualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_7Call, N> {
            self.call_builder(
                &claimAndWithdraw_7Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_8`] function.
        pub fn claimAndWithdraw_8(
            &self,
            claimPayload: <MultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_8Call, N> {
            self.call_builder(
                &claimAndWithdraw_8Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_9`] function.
        pub fn claimAndWithdraw_9(
            &self,
            claimPayload: <QualifiedClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_9Call, N> {
            self.call_builder(
                &claimAndWithdraw_9Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_10`] function.
        pub fn claimAndWithdraw_10(
            &self,
            claimPayload: <ExogenousSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_10Call, N> {
            self.call_builder(
                &claimAndWithdraw_10Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_11`] function.
        pub fn claimAndWithdraw_11(
            &self,
            claimPayload: <QualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_11Call, N> {
            self.call_builder(
                &claimAndWithdraw_11Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_12`] function.
        pub fn claimAndWithdraw_12(
            &self,
            claimPayload: <SplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_12Call, N> {
            self.call_builder(
                &claimAndWithdraw_12Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_13`] function.
        pub fn claimAndWithdraw_13(
            &self,
            claimPayload: <ExogenousBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_13Call, N> {
            self.call_builder(
                &claimAndWithdraw_13Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_14`] function.
        pub fn claimAndWithdraw_14(
            &self,
            claimPayload: <ClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_14Call, N> {
            self.call_builder(
                &claimAndWithdraw_14Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_15`] function.
        pub fn claimAndWithdraw_15(
            &self,
            claimPayload: <ExogenousSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_15Call, N> {
            self.call_builder(
                &claimAndWithdraw_15Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_16`] function.
        pub fn claimAndWithdraw_16(
            &self,
            claimPayload: <SplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_16Call, N> {
            self.call_builder(
                &claimAndWithdraw_16Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_17`] function.
        pub fn claimAndWithdraw_17(
            &self,
            claimPayload: <ExogenousQualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_17Call, N> {
            self.call_builder(
                &claimAndWithdraw_17Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_18`] function.
        pub fn claimAndWithdraw_18(
            &self,
            claimPayload: <SplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_18Call, N> {
            self.call_builder(
                &claimAndWithdraw_18Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_19`] function.
        pub fn claimAndWithdraw_19(
            &self,
            claimPayload: <BatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_19Call, N> {
            self.call_builder(
                &claimAndWithdraw_19Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_20`] function.
        pub fn claimAndWithdraw_20(
            &self,
            claimPayload: <SplitBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_20Call, N> {
            self.call_builder(
                &claimAndWithdraw_20Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_21`] function.
        pub fn claimAndWithdraw_21(
            &self,
            claimPayload: <ExogenousSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_21Call, N> {
            self.call_builder(
                &claimAndWithdraw_21Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_22`] function.
        pub fn claimAndWithdraw_22(
            &self,
            claimPayload: <SplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_22Call, N> {
            self.call_builder(
                &claimAndWithdraw_22Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_23`] function.
        pub fn claimAndWithdraw_23(
            &self,
            claimPayload: <ExogenousQualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_23Call, N> {
            self.call_builder(
                &claimAndWithdraw_23Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_24`] function.
        pub fn claimAndWithdraw_24(
            &self,
            claimPayload: <SplitClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_24Call, N> {
            self.call_builder(
                &claimAndWithdraw_24Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_25`] function.
        pub fn claimAndWithdraw_25(
            &self,
            claimPayload: <BatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_25Call, N> {
            self.call_builder(
                &claimAndWithdraw_25Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_26`] function.
        pub fn claimAndWithdraw_26(
            &self,
            claimPayload: <MultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_26Call, N> {
            self.call_builder(
                &claimAndWithdraw_26Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_27`] function.
        pub fn claimAndWithdraw_27(
            &self,
            claimPayload: <ExogenousQualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_27Call, N> {
            self.call_builder(
                &claimAndWithdraw_27Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_28`] function.
        pub fn claimAndWithdraw_28(
            &self,
            claimPayload: <SplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_28Call, N> {
            self.call_builder(
                &claimAndWithdraw_28Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_29`] function.
        pub fn claimAndWithdraw_29(
            &self,
            claimPayload: <ExogenousQualifiedSplitBatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_29Call, N> {
            self.call_builder(
                &claimAndWithdraw_29Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_30`] function.
        pub fn claimAndWithdraw_30(
            &self,
            claimPayload: <ExogenousMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_30Call, N> {
            self.call_builder(
                &claimAndWithdraw_30Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_31`] function.
        pub fn claimAndWithdraw_31(
            &self,
            claimPayload: <QualifiedBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_31Call, N> {
            self.call_builder(
                &claimAndWithdraw_31Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_32`] function.
        pub fn claimAndWithdraw_32(
            &self,
            claimPayload: <BasicClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_32Call, N> {
            self.call_builder(
                &claimAndWithdraw_32Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_33`] function.
        pub fn claimAndWithdraw_33(
            &self,
            claimPayload: <BatchMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_33Call, N> {
            self.call_builder(
                &claimAndWithdraw_33Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_34`] function.
        pub fn claimAndWithdraw_34(
            &self,
            claimPayload: <BatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_34Call, N> {
            self.call_builder(
                &claimAndWithdraw_34Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_35`] function.
        pub fn claimAndWithdraw_35(
            &self,
            claimPayload: <ExogenousMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_35Call, N> {
            self.call_builder(
                &claimAndWithdraw_35Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_36`] function.
        pub fn claimAndWithdraw_36(
            &self,
            claimPayload: <QualifiedSplitMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_36Call, N> {
            self.call_builder(
                &claimAndWithdraw_36Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_37`] function.
        pub fn claimAndWithdraw_37(
            &self,
            claimPayload: <QualifiedMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_37Call, N> {
            self.call_builder(
                &claimAndWithdraw_37Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_38`] function.
        pub fn claimAndWithdraw_38(
            &self,
            claimPayload: <ExogenousQualifiedSplitBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_38Call, N> {
            self.call_builder(
                &claimAndWithdraw_38Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_39`] function.
        pub fn claimAndWithdraw_39(
            &self,
            claimPayload: <ExogenousSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_39Call, N> {
            self.call_builder(
                &claimAndWithdraw_39Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_40`] function.
        pub fn claimAndWithdraw_40(
            &self,
            claimPayload: <QualifiedSplitMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_40Call, N> {
            self.call_builder(
                &claimAndWithdraw_40Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_41`] function.
        pub fn claimAndWithdraw_41(
            &self,
            claimPayload: <ExogenousQualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_41Call, N> {
            self.call_builder(
                &claimAndWithdraw_41Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_42`] function.
        pub fn claimAndWithdraw_42(
            &self,
            claimPayload: <ExogenousBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_42Call, N> {
            self.call_builder(
                &claimAndWithdraw_42Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_43`] function.
        pub fn claimAndWithdraw_43(
            &self,
            claimPayload: <QualifiedMultichainClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_43Call, N> {
            self.call_builder(
                &claimAndWithdraw_43Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_44`] function.
        pub fn claimAndWithdraw_44(
            &self,
            claimPayload: <SplitBatchClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_44Call, N> {
            self.call_builder(
                &claimAndWithdraw_44Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_45`] function.
        pub fn claimAndWithdraw_45(
            &self,
            claimPayload: <QualifiedBatchClaim as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_45Call, N> {
            self.call_builder(
                &claimAndWithdraw_45Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_46`] function.
        pub fn claimAndWithdraw_46(
            &self,
            claimPayload: <QualifiedSplitClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_46Call, N> {
            self.call_builder(
                &claimAndWithdraw_46Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`claimAndWithdraw_47`] function.
        pub fn claimAndWithdraw_47(
            &self,
            claimPayload: <ExogenousQualifiedBatchMultichainClaimWithWitness as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimAndWithdraw_47Call, N> {
            self.call_builder(
                &claimAndWithdraw_47Call {
                    claimPayload,
                },
            )
        }
        ///Creates a new call builder for the [`consume`] function.
        pub fn consume(
            &self,
            nonces: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, consumeCall, N> {
            self.call_builder(&consumeCall { nonces })
        }
        ///Creates a new call builder for the [`decimals`] function.
        pub fn decimals(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
            self.call_builder(&decimalsCall { id })
        }
        ///Creates a new call builder for the [`deposit_0`] function.
        pub fn deposit_0(
            &self,
            token: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::primitives::aliases::U256,
            _2: alloy::sol_types::private::primitives::aliases::U256,
            _3: alloy::sol_types::private::primitives::aliases::U256,
            _4: alloy::sol_types::private::Address,
            _5: alloy::sol_types::private::Address,
            _6: <ResetPeriod as alloy::sol_types::SolType>::RustType,
            _7: <Scope as alloy::sol_types::SolType>::RustType,
            recipient: alloy::sol_types::private::Address,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, deposit_0Call, N> {
            self.call_builder(
                &deposit_0Call {
                    token,
                    _1,
                    _2,
                    _3,
                    _4,
                    _5,
                    _6,
                    _7,
                    recipient,
                    signature,
                },
            )
        }
        ///Creates a new call builder for the [`deposit_1`] function.
        pub fn deposit_1(
            &self,
            allocator: alloy::sol_types::private::Address,
            resetPeriod: <ResetPeriod as alloy::sol_types::SolType>::RustType,
            scope: <Scope as alloy::sol_types::SolType>::RustType,
            recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, deposit_1Call, N> {
            self.call_builder(
                &deposit_1Call {
                    allocator,
                    resetPeriod,
                    scope,
                    recipient,
                },
            )
        }
        ///Creates a new call builder for the [`deposit_2`] function.
        pub fn deposit_2(
            &self,
            token: alloy::sol_types::private::Address,
            allocator: alloy::sol_types::private::Address,
            resetPeriod: <ResetPeriod as alloy::sol_types::SolType>::RustType,
            scope: <Scope as alloy::sol_types::SolType>::RustType,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, deposit_2Call, N> {
            self.call_builder(
                &deposit_2Call {
                    token,
                    allocator,
                    resetPeriod,
                    scope,
                    amount,
                    recipient,
                },
            )
        }
        ///Creates a new call builder for the [`deposit_3`] function.
        pub fn deposit_3(
            &self,
            token: alloy::sol_types::private::Address,
            allocator: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, deposit_3Call, N> {
            self.call_builder(
                &deposit_3Call {
                    token,
                    allocator,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`deposit_4`] function.
        pub fn deposit_4(
            &self,
            _0: alloy::sol_types::private::Address,
            permitted: alloy::sol_types::private::Vec<
                <ISignatureTransfer::TokenPermissions as alloy::sol_types::SolType>::RustType,
            >,
            _2: alloy::sol_types::private::primitives::aliases::U256,
            _3: alloy::sol_types::private::primitives::aliases::U256,
            _4: alloy::sol_types::private::Address,
            _5: <ResetPeriod as alloy::sol_types::SolType>::RustType,
            _6: <Scope as alloy::sol_types::SolType>::RustType,
            recipient: alloy::sol_types::private::Address,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, deposit_4Call, N> {
            self.call_builder(
                &deposit_4Call {
                    _0,
                    permitted,
                    _2,
                    _3,
                    _4,
                    _5,
                    _6,
                    recipient,
                    signature,
                },
            )
        }
        ///Creates a new call builder for the [`deposit_5`] function.
        pub fn deposit_5(
            &self,
            idsAndAmounts: alloy::sol_types::private::Vec<
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            >,
            recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, deposit_5Call, N> {
            self.call_builder(
                &deposit_5Call {
                    idsAndAmounts,
                    recipient,
                },
            )
        }
        ///Creates a new call builder for the [`deposit_6`] function.
        pub fn deposit_6(
            &self,
            allocator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, deposit_6Call, N> {
            self.call_builder(&deposit_6Call { allocator })
        }
        ///Creates a new call builder for the [`depositAndRegister_0`] function.
        pub fn depositAndRegister_0(
            &self,
            token: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::primitives::aliases::U256,
            _2: alloy::sol_types::private::primitives::aliases::U256,
            _3: alloy::sol_types::private::primitives::aliases::U256,
            depositor: alloy::sol_types::private::Address,
            _5: alloy::sol_types::private::Address,
            resetPeriod: <ResetPeriod as alloy::sol_types::SolType>::RustType,
            _7: <Scope as alloy::sol_types::SolType>::RustType,
            claimHash: alloy::sol_types::private::FixedBytes<32>,
            compactCategory: <CompactCategory as alloy::sol_types::SolType>::RustType,
            witness: alloy::sol_types::private::String,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositAndRegister_0Call, N> {
            self.call_builder(
                &depositAndRegister_0Call {
                    token,
                    _1,
                    _2,
                    _3,
                    depositor,
                    _5,
                    resetPeriod,
                    _7,
                    claimHash,
                    compactCategory,
                    witness,
                    signature,
                },
            )
        }
        ///Creates a new call builder for the [`depositAndRegister_1`] function.
        pub fn depositAndRegister_1(
            &self,
            idsAndAmounts: alloy::sol_types::private::Vec<
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            >,
            claimHashesAndTypehashes: alloy::sol_types::private::Vec<
                [alloy::sol_types::private::FixedBytes<32>; 2usize],
            >,
            duration: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositAndRegister_1Call, N> {
            self.call_builder(
                &depositAndRegister_1Call {
                    idsAndAmounts,
                    claimHashesAndTypehashes,
                    duration,
                },
            )
        }
        ///Creates a new call builder for the [`depositAndRegister_2`] function.
        pub fn depositAndRegister_2(
            &self,
            allocator: alloy::sol_types::private::Address,
            claimHash: alloy::sol_types::private::FixedBytes<32>,
            typehash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositAndRegister_2Call, N> {
            self.call_builder(
                &depositAndRegister_2Call {
                    allocator,
                    claimHash,
                    typehash,
                },
            )
        }
        ///Creates a new call builder for the [`depositAndRegister_3`] function.
        pub fn depositAndRegister_3(
            &self,
            depositor: alloy::sol_types::private::Address,
            permitted: alloy::sol_types::private::Vec<
                <ISignatureTransfer::TokenPermissions as alloy::sol_types::SolType>::RustType,
            >,
            _2: alloy::sol_types::private::primitives::aliases::U256,
            _3: alloy::sol_types::private::primitives::aliases::U256,
            _4: alloy::sol_types::private::Address,
            resetPeriod: <ResetPeriod as alloy::sol_types::SolType>::RustType,
            _6: <Scope as alloy::sol_types::SolType>::RustType,
            claimHash: alloy::sol_types::private::FixedBytes<32>,
            compactCategory: <CompactCategory as alloy::sol_types::SolType>::RustType,
            witness: alloy::sol_types::private::String,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositAndRegister_3Call, N> {
            self.call_builder(
                &depositAndRegister_3Call {
                    depositor,
                    permitted,
                    _2,
                    _3,
                    _4,
                    resetPeriod,
                    _6,
                    claimHash,
                    compactCategory,
                    witness,
                    signature,
                },
            )
        }
        ///Creates a new call builder for the [`depositAndRegister_4`] function.
        pub fn depositAndRegister_4(
            &self,
            token: alloy::sol_types::private::Address,
            allocator: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            claimHash: alloy::sol_types::private::FixedBytes<32>,
            typehash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositAndRegister_4Call, N> {
            self.call_builder(
                &depositAndRegister_4Call {
                    token,
                    allocator,
                    amount,
                    claimHash,
                    typehash,
                },
            )
        }
        ///Creates a new call builder for the [`disableForcedWithdrawal`] function.
        pub fn disableForcedWithdrawal(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, disableForcedWithdrawalCall, N> {
            self.call_builder(&disableForcedWithdrawalCall { id })
        }
        ///Creates a new call builder for the [`enableForcedWithdrawal`] function.
        pub fn enableForcedWithdrawal(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, enableForcedWithdrawalCall, N> {
            self.call_builder(&enableForcedWithdrawalCall { id })
        }
        ///Creates a new call builder for the [`extsload_0`] function.
        pub fn extsload_0(
            &self,
            slot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, extsload_0Call, N> {
            self.call_builder(&extsload_0Call { slot })
        }
        ///Creates a new call builder for the [`extsload_1`] function.
        pub fn extsload_1(
            &self,
            slots: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, extsload_1Call, N> {
            self.call_builder(&extsload_1Call { slots })
        }
        ///Creates a new call builder for the [`exttload`] function.
        pub fn exttload(
            &self,
            slot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, exttloadCall, N> {
            self.call_builder(&exttloadCall { slot })
        }
        ///Creates a new call builder for the [`forcedWithdrawal`] function.
        pub fn forcedWithdrawal(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
            recipient: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, forcedWithdrawalCall, N> {
            self.call_builder(
                &forcedWithdrawalCall {
                    id,
                    recipient,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`getForcedWithdrawalStatus`] function.
        pub fn getForcedWithdrawalStatus(
            &self,
            account: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getForcedWithdrawalStatusCall, N> {
            self.call_builder(
                &getForcedWithdrawalStatusCall {
                    account,
                    id,
                },
            )
        }
        ///Creates a new call builder for the [`getLockDetails`] function.
        pub fn getLockDetails(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLockDetailsCall, N> {
            self.call_builder(&getLockDetailsCall { id })
        }
        ///Creates a new call builder for the [`getRegistrationStatus`] function.
        pub fn getRegistrationStatus(
            &self,
            sponsor: alloy::sol_types::private::Address,
            claimHash: alloy::sol_types::private::FixedBytes<32>,
            typehash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRegistrationStatusCall, N> {
            self.call_builder(
                &getRegistrationStatusCall {
                    sponsor,
                    claimHash,
                    typehash,
                },
            )
        }
        ///Creates a new call builder for the [`hasConsumedAllocatorNonce`] function.
        pub fn hasConsumedAllocatorNonce(
            &self,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            allocator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasConsumedAllocatorNonceCall, N> {
            self.call_builder(
                &hasConsumedAllocatorNonceCall {
                    nonce,
                    allocator,
                },
            )
        }
        ///Creates a new call builder for the [`isOperator`] function.
        pub fn isOperator(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isOperatorCall, N> {
            self.call_builder(&isOperatorCall { owner, spender })
        }
        ///Creates a new call builder for the [`name_0`] function.
        pub fn name_0(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, name_0Call, N> {
            self.call_builder(&name_0Call { id })
        }
        ///Creates a new call builder for the [`name_1`] function.
        pub fn name_1(&self) -> alloy_contract::SolCallBuilder<T, &P, name_1Call, N> {
            self.call_builder(&name_1Call {})
        }
        ///Creates a new call builder for the [`register_0`] function.
        pub fn register_0(
            &self,
            claimHashesAndTypehashes: alloy::sol_types::private::Vec<
                [alloy::sol_types::private::FixedBytes<32>; 2usize],
            >,
            duration: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, register_0Call, N> {
            self.call_builder(
                &register_0Call {
                    claimHashesAndTypehashes,
                    duration,
                },
            )
        }
        ///Creates a new call builder for the [`register_1`] function.
        pub fn register_1(
            &self,
            claimHash: alloy::sol_types::private::FixedBytes<32>,
            typehash: alloy::sol_types::private::FixedBytes<32>,
            duration: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, register_1Call, N> {
            self.call_builder(
                &register_1Call {
                    claimHash,
                    typehash,
                    duration,
                },
            )
        }
        ///Creates a new call builder for the [`setOperator`] function.
        pub fn setOperator(
            &self,
            operator: alloy::sol_types::private::Address,
            approved: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setOperatorCall, N> {
            self.call_builder(
                &setOperatorCall {
                    operator,
                    approved,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
            self.call_builder(&symbolCall { id })
        }
        ///Creates a new call builder for the [`tokenURI`] function.
        pub fn tokenURI(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, tokenURICall, N> {
            self.call_builder(&tokenURICall { id })
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            to: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall { to, id, amount })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::primitives::aliases::U256,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    id,
                    amount,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TheCompactInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AllocatorRegistered`] event.
        pub fn AllocatorRegistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AllocatorRegistered, N> {
            self.event_filter::<AllocatorRegistered>()
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`Claim`] event.
        pub fn Claim_filter(&self) -> alloy_contract::Event<T, &P, Claim, N> {
            self.event_filter::<Claim>()
        }
        ///Creates a new event filter for the [`CompactRegistered`] event.
        pub fn CompactRegistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CompactRegistered, N> {
            self.event_filter::<CompactRegistered>()
        }
        ///Creates a new event filter for the [`ForcedWithdrawalStatusUpdated`] event.
        pub fn ForcedWithdrawalStatusUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ForcedWithdrawalStatusUpdated, N> {
            self.event_filter::<ForcedWithdrawalStatusUpdated>()
        }
        ///Creates a new event filter for the [`OperatorSet`] event.
        pub fn OperatorSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorSet, N> {
            self.event_filter::<OperatorSet>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
    }
}
